var tipuesearch = {"pages":[{"title":" OptaDOS ","text":"OptaDOS For high quality theoretical DOS, Projected-DOS, Joint-DOS, Optics and core-loss spectroscopy. A collaboration between the Departments of Materials at the Unvieristies of Birmimgham, Oxford and Cambridge. Developer Info The OptaDOS developers group","tags":"home","loc":"index.html"},{"title":"build_info_type – OptaDOS ","text":"type, public :: build_info_type Contents Variables build build_type comms_arch compile_date compile_time compiler source_date source_time Source Code build_info_type Components Type Visibility Attributes Name Initial character(len=20), public :: build = '' character(len=20), public :: build_type = 'debug' character(len=20), public :: comms_arch = 'serial' character(len=20), public :: compile_date = 'Mon 28 Aug 2023' character(len=20), public :: compile_time = '16:49 BST' character(len=20), public :: compiler = 'gfortran' character(len=20), public :: source_date = 'Mon 28 Aug 2023' character(len=20), public :: source_time = '16:47:50' Source Code type , public :: build_info_type character ( len = 20 ) :: build = '' character ( len = 20 ) :: compiler = 'gfortran' character ( len = 20 ) :: build_type = 'debug' character ( len = 20 ) :: comms_arch = 'serial' character ( len = 20 ) :: source_time = '16:47:50' character ( len = 20 ) :: source_date = 'Mon 28 Aug 2023' character ( len = 20 ) :: compile_date = 'Mon 28 Aug 2023' character ( len = 20 ) :: compile_time = '16:49 BST' end type build_info_type","tags":"","loc":"type/build_info_type.html"},{"title":"matrix_weights_array_boundaries – OptaDOS ","text":"type, public :: matrix_weights_array_boundaries Contents Variables nbands nkpoints norbitals nspins Source Code matrix_weights_array_boundaries Components Type Visibility Attributes Name Initial integer, public :: nbands integer, public :: nkpoints integer, public :: norbitals integer, public :: nspins Source Code type , public :: matrix_weights_array_boundaries integer :: norbitals integer :: nbands integer :: nkpoints integer :: nspins end type matrix_weights_array_boundaries","tags":"","loc":"type/matrix_weights_array_boundaries.html"},{"title":"orbitals – OptaDOS ","text":"type, public :: orbitals Contents Variables am_channel am_channel_name ion_no rank_in_species shell species_no Source Code orbitals Components Type Visibility Attributes Name Initial integer, public, allocatable :: am_channel (:) character(len=10), public, allocatable :: am_channel_name (:) integer, public, allocatable :: ion_no (:) integer, public, allocatable :: rank_in_species (:) integer, public, allocatable :: shell (:) integer, public, allocatable :: species_no (:) Source Code type , public :: orbitals integer , allocatable :: ion_no (:) ! Unique ion number integer , allocatable :: species_no (:) ! Unique species number integer , allocatable :: rank_in_species (:) ! Unique ion number within species integer , allocatable :: am_channel (:) ! The angular momentum Channel (l) integer , allocatable :: shell (:) ! Principal quantum number (n) !n.b typically only know this for core states character ( len = 10 ), allocatable :: am_channel_name (:) ! Name of angular momentum channel s,p,d, etc end type orbitals","tags":"","loc":"type/orbitals.html"},{"title":"my_DCOPY – OptaDOS","text":"subroutine my_DCOPY(N, DX, INCX, DY, INCY) Uses od_constants proc~~my_dcopy~~UsesGraph proc~my_dcopy my_DCOPY module~od_constants od_constants proc~my_dcopy->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer :: N real(kind=dp) :: DX (*) integer :: INCX real(kind=dp) :: DY (*) integer :: INCY Contents Source Code my_DCOPY Source Code subroutine my_DCOPY ( N , DX , INCX , DY , INCY ) use od_constants , only : dp !     .. Scalar Arguments .. integer INCX , INCY , N !     .. !     .. Array Arguments .. real ( kind = dp ) DX ( * ), DY ( * ) !     .. ! !  Purpose !  ======= ! !     copies a vector, x, to a vector, y. !     uses unrolled loops for increments equal to one. !     jack dongarra, linpack, 3/11/78. !     modified 12/3/93, array(1) declarations changed to array(*) ! ! !     .. Local Scalars .. integer I , IX , IY , M , MP1 !     .. !     .. Intrinsic Functions .. intrinsic MOD !     .. if ( N . le . 0 ) return if ( INCX . eq . 1 . and . INCY . eq . 1 ) GO TO 20 ! !        code for unequal increments or equal increments !          not equal to 1 ! IX = 1 IY = 1 if ( INCX . lt . 0 ) IX = ( - N + 1 ) * INCX + 1 if ( INCY . lt . 0 ) IY = ( - N + 1 ) * INCY + 1 do I = 1 , N DY ( IY ) = DX ( IX ) IX = IX + INCX IY = IY + INCY end do return ! !        code for both increments equal to 1 ! ! !        clean-up loop ! 20 M = mod ( N , 7 ) if ( M . eq . 0 ) GO TO 40 do I = 1 , M DY ( I ) = DX ( I ) end do if ( N . lt . 7 ) return 40 MP1 = M + 1 do I = MP1 , N , 7 DY ( I ) = DX ( I ) DY ( I + 1 ) = DX ( I + 1 ) DY ( I + 2 ) = DX ( I + 2 ) DY ( I + 3 ) = DX ( I + 3 ) DY ( I + 4 ) = DX ( I + 4 ) DY ( I + 5 ) = DX ( I + 5 ) DY ( I + 6 ) = DX ( I + 6 ) end do return end subroutine my_DCOPY","tags":"","loc":"proc/my_dcopy.html"},{"title":"my_ZCOPY – OptaDOS","text":"subroutine my_ZCOPY(N, ZX, INCX, ZY, INCY) Uses od_constants proc~~my_zcopy~~UsesGraph proc~my_zcopy my_ZCOPY module~od_constants od_constants proc~my_zcopy->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer :: N complex(kind=dp) :: ZX (*) integer :: INCX complex(kind=dp) :: ZY (*) integer :: INCY Contents Source Code my_ZCOPY Source Code subroutine my_ZCOPY ( N , ZX , INCX , ZY , INCY ) use od_constants , only : dp !     .. Scalar Arguments .. integer INCX , INCY , N !     .. !     .. Array Arguments .. complex ( kind = dp ) ZX ( * ), ZY ( * ) !     .. ! !  Purpose !  ======= ! !     copies a vector, x, to a vector, y. !     jack dongarra, linpack, 4/11/78. !     modified 12/3/93, array(1) declarations changed to array(*) ! ! !     .. Local Scalars .. integer I , IX , IY !     .. if ( N . le . 0 ) return if ( INCX . eq . 1 . and . INCY . eq . 1 ) GO TO 20 ! !        code for unequal increments or equal increments !          not equal to 1 ! IX = 1 IY = 1 if ( INCX . lt . 0 ) IX = ( - N + 1 ) * INCX + 1 if ( INCY . lt . 0 ) IY = ( - N + 1 ) * INCY + 1 do I = 1 , N ZY ( IY ) = ZX ( IX ) IX = IX + INCX IY = IY + INCY end do return ! !        code for both increments equal to 1 ! 20 do I = 1 , N ZY ( I ) = ZX ( I ) end do return end subroutine my_ZCOPY","tags":"","loc":"proc/my_zcopy.html"},{"title":"my_ICOPY – OptaDOS","text":"subroutine my_ICOPY(N, ZX, INCX, ZY, INCY) Arguments Type Intent Optional Attributes Name integer :: N integer :: ZX (*) integer :: INCX integer :: ZY (*) integer :: INCY Contents Source Code my_ICOPY Source Code subroutine my_ICOPY ( N , ZX , INCX , ZY , INCY ) !     .. Scalar Arguments .. integer INCX , INCY , N !     .. !     .. Array Arguments .. integer ZX ( * ), ZY ( * ) !     .. ! !  Purpose !  ======= ! !     copies a vector, x, to a vector, y. !     jack dongarra, linpack, 4/11/78. !     modified 12/3/93, array(1) declarations changed to array(*) ! ! !     .. Local Scalars .. integer I , IX , IY !     .. if ( N . le . 0 ) return if ( INCX . eq . 1 . and . INCY . eq . 1 ) GO TO 20 ! !        code for unequal increments or equal increments !          not equal to 1 ! IX = 1 IY = 1 if ( INCX . lt . 0 ) IX = ( - N + 1 ) * INCX + 1 if ( INCY . lt . 0 ) IY = ( - N + 1 ) * INCY + 1 do I = 1 , N ZY ( IY ) = ZX ( IX ) IX = IX + INCX IY = IY + INCY end do return ! !        code for both increments equal to 1 ! 20 do I = 1 , N ZY ( I ) = ZX ( I ) end do return end subroutine my_ICOPY","tags":"","loc":"proc/my_icopy.html"},{"title":"pdos_calculate – OptaDOS","text":"public  subroutine pdos_calculate() Uses od_parameters od_dos_utils od_comms od_electronic od_projection_utils od_io proc~~pdos_calculate~~UsesGraph proc~pdos_calculate pdos_calculate module~od_parameters od_parameters proc~pdos_calculate->module~od_parameters module~od_dos_utils od_dos_utils proc~pdos_calculate->module~od_dos_utils module~od_comms od_comms proc~pdos_calculate->module~od_comms module~od_projection_utils od_projection_utils proc~pdos_calculate->module~od_projection_utils module~od_electronic od_electronic proc~pdos_calculate->module~od_electronic module~od_io od_io proc~pdos_calculate->module~od_io module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_comms->module~od_constants module~od_projection_utils->module~od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~pdos_calculate~~CallsGraph proc~pdos_calculate pdos_calculate proc~elec_pdos_read elec_pdos_read proc~pdos_calculate->proc~elec_pdos_read proc~projection_get_string projection_get_string proc~pdos_calculate->proc~projection_get_string proc~projection_analyse_orbitals projection_analyse_orbitals proc~pdos_calculate->proc~projection_analyse_orbitals proc~projection_merge projection_merge proc~pdos_calculate->proc~projection_merge proc~dos_utils_calculate dos_utils_calculate proc~pdos_calculate->proc~dos_utils_calculate proc~dos_utils_set_efermi dos_utils_set_efermi proc~pdos_calculate->proc~dos_utils_set_efermi proc~io_file_unit io_file_unit proc~elec_pdos_read->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_pdos_read->interface~comms_bcast interface~comms_recv comms_recv proc~elec_pdos_read->interface~comms_recv interface~comms_send comms_send proc~elec_pdos_read->interface~comms_send proc~io_error io_error proc~elec_pdos_read->proc~io_error proc~projection_get_string->proc~io_error proc~projection_analyse_orbitals->proc~io_error proc~projection_merge->proc~io_error proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_calculate->proc~io_error proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~io_time io_time proc~dos_utils_calculate->proc~io_time proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_set_efermi->proc~io_error interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_merge->interface~comms_reduce proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->interface~comms_recv proc~elec_read_band_gradient->interface~comms_send proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~io_time proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pdos_calculate~~CalledByGraph proc~pdos_calculate pdos_calculate program~optados optados program~optados->proc~pdos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pdos_calculate Source Code subroutine pdos_calculate use od_electronic , only : elec_pdos_read , efermi , efermi_set use od_dos_utils , only : dos_utils_calculate , dos_utils_set_efermi use od_projection_utils , only : projection_merge , projection_get_string , projection_analyse_orbitals use od_comms , only : on_root use od_parameters , only : iprint , set_efermi_zero use od_io , only : stdout implicit none if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                 Projected Density Of States Calculation                    +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) end if ! read in the pdos weights call elec_pdos_read ! look at the orbitals and figure out which atoms / states we have call projection_analyse_orbitals ! parse the pdos string to see what we want call projection_get_string ! form the right matrix elements call projection_merge if ( on_root . and . ( iprint > 2 )) then call pdos_report_projectors end if ! now compute the weighted dos call dos_utils_calculate ( matrix_weights , dos_partial ) ! and write everything out if ( set_efermi_zero . and . . not . efermi_set ) call dos_utils_set_efermi if ( on_root ) then call pdos_write end if end subroutine pdos_calculate","tags":"","loc":"proc/pdos_calculate.html"},{"title":"projection_analyse_orbitals – OptaDOS","text":"public  subroutine projection_analyse_orbitals() Uses od_electronic od_io od_cell od_constants proc~~projection_analyse_orbitals~~UsesGraph proc~projection_analyse_orbitals projection_analyse_orbitals module~od_electronic od_electronic proc~projection_analyse_orbitals->module~od_electronic module~od_cell od_cell proc~projection_analyse_orbitals->module~od_cell module~od_io od_io proc~projection_analyse_orbitals->module~od_io module~od_constants od_constants proc~projection_analyse_orbitals->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~projection_analyse_orbitals~~CallsGraph proc~projection_analyse_orbitals projection_analyse_orbitals proc~io_error io_error proc~projection_analyse_orbitals->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~projection_analyse_orbitals~~CalledByGraph proc~projection_analyse_orbitals projection_analyse_orbitals proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~projection_analyse_orbitals proc~pdis_calculate pdis_calculate proc~pdis_calculate->proc~projection_analyse_orbitals program~optados optados program~optados->proc~pdos_calculate program~optados->proc~pdis_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code projection_analyse_orbitals Source Code subroutine projection_analyse_orbitals use od_electronic , only : pdos_orbital , pdos_mwab use od_cell , only : atoms_symbol , num_species use od_constants , only : periodic_table_name use od_io , only : io_error implicit none integer :: loop , loop2 , counter , ierr if ( maxval ( pdos_orbital % species_no (:)) > num_species ) & call io_error ( 'Error: projection_analyse_substring - more species in pdos file than in cell file' ) allocate ( proj_sites ( maxval ( pdos_orbital % species_no (:))), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of proj_sites failed' ) allocate ( proj_am ( maxval ( pdos_orbital % species_no (:)), max_am ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of proj_am failed' ) allocate ( proj_symbol ( maxval ( pdos_orbital % species_no (:))), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of proj_symbol failed' ) proj_sites = 0 ; proj_am = 0 do loop = 1 , pdos_mwab % norbitals if ( pdos_orbital % rank_in_species ( loop ) > proj_sites ( pdos_orbital % species_no ( loop ))) & proj_sites ( pdos_orbital % species_no ( loop )) = pdos_orbital % rank_in_species ( loop ) if ( pdos_orbital % rank_in_species ( loop ) == 1 ) & proj_am ( pdos_orbital % species_no ( loop ), pdos_orbital % am_channel ( loop ) + 1 ) = 1 end do !Now need to figure out symbols for each species counter = 1 do loop2 = 1 , 109 do loop = 1 , num_species if ( atoms_symbol ( loop ) == periodic_table_name ( loop2 )) then proj_symbol ( counter ) = periodic_table_name ( loop2 ) counter = counter + 1 !check atom count here end if end do end do end subroutine projection_analyse_orbitals","tags":"","loc":"proc/projection_analyse_orbitals.html"},{"title":"projection_get_string – OptaDOS","text":"public  subroutine projection_get_string() Uses od_cell od_io od_parameters proc~~projection_get_string~~UsesGraph proc~projection_get_string projection_get_string module~od_cell od_cell proc~projection_get_string->module~od_cell module~od_parameters od_parameters proc~projection_get_string->module~od_parameters module~od_io od_io proc~projection_get_string->module~od_io module~od_cell->module~od_io module~od_constants od_constants module~od_cell->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~projection_get_string~~CallsGraph proc~projection_get_string projection_get_string proc~io_error io_error proc~projection_get_string->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~projection_get_string~~CalledByGraph proc~projection_get_string projection_get_string proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~projection_get_string proc~pdis_calculate pdis_calculate proc~pdis_calculate->proc~projection_get_string program~optados optados program~optados->proc~pdos_calculate program~optados->proc~pdis_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code projection_get_string Source Code subroutine projection_get_string !=============================================================================== ! This is a mindbendingly horrific exercise in book-keeping !=============================================================================== use od_parameters , only : projectors_string use od_cell , only : num_species , atoms_species_num use od_io , only : maxlen , io_error implicit none character ( len = maxlen ) :: ctemp , ctemp2 , ctemp3 integer :: loop4 , loop3 , loop2 , ierr logical :: pdos_sum integer :: loop , pos , loop_l , loop_a , loop_p integer :: i_digit , species_count , species_proj character ( len = 1 ), parameter :: c_sep = \":\" integer , allocatable :: pdos_temp (:, :, :, :) !Check for any short cuts shortcut = . false . ctemp = projectors_string if ( index ( ctemp , 'species_ang' ) > 0 ) then num_proj = 0 do loop = 1 , num_species num_proj = num_proj + count ( proj_am ( loop , :) == 1 ) end do allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 loop_p = 1 do loop = 1 , num_species do loop_l = 1 , max_am if ( proj_am ( loop , loop_l ) == 0 ) cycle projection_array ( loop , :, loop_l , loop_p ) = 1 loop_p = loop_p + 1 end do end do shortcut = . true . elseif ( index ( ctemp , 'species' ) > 0 ) then num_proj = num_species allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 do loop = 1 , num_species projection_array ( loop , :, :, loop ) = 1 end do shortcut = . true . elseif ( index ( ctemp , 'sites' ) > 0 ) then num_proj = 0 do loop = 1 , num_species num_proj = num_proj + proj_sites ( loop ) end do allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 loop_p = 1 do loop = 1 , num_species do loop_a = 1 , proj_sites ( loop ) projection_array ( loop , loop_a , :, loop_p ) = 1 loop_p = loop_p + 1 end do end do shortcut = . true . elseif ( index ( ctemp , 'angular' ) > 0 ) then num_proj = max_am allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 loop_p = 0 do loop = 1 , num_proj projection_array (:, :, loop , loop ) = 1 end do shortcut = . true . end if if (. not . shortcut ) then !look for sum ctemp = projectors_string pdos_sum = . false . if ( index ( ctemp , 'sum:' ) == 1 ) then pdos_sum = . true . ctemp = ctemp ( 5 :) end if ! take 1st part of string ctemp2 = ctemp species_count = 1 ; num_proj = 0 do !look for each species section ! and pass to find number of projections pos = index ( ctemp2 , c_sep ) if ( pos == 0 ) then ctemp3 = ctemp2 else ctemp3 = ctemp2 ( 1 : pos - 1 ) end if call projection_analyse_substring ( ctemp3 , species_proj ) num_proj = num_proj + species_proj if ( pos == 0 ) exit species_count = species_count + 1 ctemp2 = ctemp2 ( pos + 1 :) end do ! now allocate the correct sized array allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 ctemp2 = ctemp do loop = 1 , species_count !loop for each species section !and pass fill in projection pos = index ( ctemp2 , c_sep ) if ( pos == 0 ) then ctemp3 = ctemp2 else ctemp3 = ctemp2 ( 1 : pos - 1 ) end if call projection_analyse_substring ( ctemp3 ) ctemp2 = ctemp2 ( pos + 1 :) end do if ( pdos_sum ) then allocate ( pdos_temp ( num_species , maxval ( atoms_species_num ), max_am , 1 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of pdos_temp failed' ) pdos_temp = 0 do loop4 = 1 , num_proj do loop3 = 1 , max_am do loop2 = 1 , maxval ( atoms_species_num ) do loop = 1 , num_species if ( projection_array ( loop , loop2 , loop3 , loop4 ) == 1 ) then pdos_temp ( loop , loop2 , loop3 , 1 ) = 1 end if end do end do end do end do deallocate ( projection_array , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - deallocation of projection_array failed' ) num_proj = 1 allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 projection_array = pdos_temp end if end if return contains !=============================================================================== subroutine projection_analyse_substring ( ctemp , species_proj ) !=============================================================================== ! This is a mindbendingly horrific exercise in book-keeping !=============================================================================== use od_cell , only : num_species , atoms_species_num use od_io , only : maxlen , io_error implicit none character ( len = maxlen ), intent ( inout ) :: ctemp integer , optional , intent ( out ) :: species_proj integer , save :: offset = 0 character ( len = maxlen ) :: ctemp2 , c_am , m_string integer :: pos_l , pos_r , ia , iz , idiff , ic1 , ic2 , species , num_sites , num_am character ( len = 3 ) :: c_symbol = '   ' logical :: am_sum , site_sum integer :: num1 , num2 , i_punc , pos3 , loop_l , loop_a , loop_p , loop_j integer :: counter , loop_r , range_size , ierr character ( len = maxlen ) :: dummy character ( len = 10 ), parameter :: c_digit = \"0123456789\" character ( len = 1 ), parameter :: c_range = \"-\" character ( len = 1 ), parameter :: c_sep = \",\" character ( len = 4 ), parameter :: c_punc = \" ,-:\" character ( len = 5 ) :: c_num1 , c_num2 integer , allocatable :: pdos_atoms (:), pdos_ang (:) logical :: lcount allocate ( pdos_atoms ( maxval ( atoms_species_num )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of pdos_atoms failed' ) allocate ( pdos_ang ( max_am ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of pdos_ang failed' ) lcount = . false . if ( present ( species_proj )) lcount = . true . pdos_atoms = 0 ; pdos_ang = 0 site_sum = . false . am_sum = . false . ! look for Ang Mtm string eg (s,p) c_am = '' pos_l = index ( ctemp , '(' ) if ( pos_l > 0 ) then pos_r = index ( ctemp , ')' ) if ( pos_r == 0 ) call io_error ( 'projection_analyse_substring: found ( but no )' ) if ( pos_r <= pos_l ) call io_error ( 'projection_analyse_substring: found ) before (' ) c_am = ctemp ( pos_l + 1 : pos_r - 1 ) ctemp = ctemp (: pos_l - 1 ) else ! implicit sum over AM am_sum = . true . end if ia = ichar ( 'a' ) iz = ichar ( 'z' ) idiff = ichar ( 'Z' ) - ichar ( 'z' ) ic1 = ichar ( ctemp ( 1 : 1 )) if ( ic1 < ia . or . ic1 > iz ) call io_error ( 'projection_analyse_substring: problem reading atomic symbol in pdos string' ) ic2 = ichar ( ctemp ( 2 : 2 )) if ( ic2 >= ia . and . ic1 <= iz ) then c_symbol ( 1 : 1 ) = char ( ic1 + idiff ) c_symbol ( 2 : 2 ) = ctemp ( 2 : 2 ) ctemp = ctemp ( 3 :) else c_symbol ( 1 : 1 ) = char ( ic1 + idiff ) c_symbol ( 2 : 2 ) = '' ctemp = ctemp ( 2 :) end if species = 0 do loop_j = 1 , num_species if ( adjustl ( c_symbol ) == adjustl ( proj_symbol ( loop_j ))) then species = loop_j end if end do if ( species == 0 ) call io_error ( 'projection_analyse_substring: Failed to match atomic symbol in pdos string' ) !Count atoms numbers counter = 0 dummy = adjustl ( ctemp ) if ( len_trim ( dummy ) > 0 ) then dummy = adjustl ( dummy ) do i_punc = scan ( dummy , c_punc ) if ( i_punc == 0 ) call io_error ( 'projection_analyse_substring: error looking for atom numbers' ) c_num1 = dummy ( 1 : i_punc - 1 ) read ( c_num1 , * , err = 101 , end = 101 ) num1 dummy = adjustl ( dummy ( i_punc :)) !look for range if ( scan ( dummy , c_range ) == 1 ) then i_digit = scan ( dummy , c_digit ) dummy = adjustl ( dummy ( i_digit :)) i_punc = scan ( dummy , c_punc ) c_num2 = dummy ( 1 : i_punc - 1 ) read ( c_num2 , * , err = 101 , end = 101 ) num2 dummy = adjustl ( dummy ( i_punc :)) range_size = abs ( num2 - num1 ) + 1 do loop_r = 1 , range_size counter = counter + 1 if ( min ( num1 , num2 ) + loop_r - 1 > proj_sites ( species )) & call io_error ( 'projection_analyse_substring: Atom number given in pdos string & &is greater than number of atoms for given species' ) pdos_atoms ( min ( num1 , num2 ) + loop_r - 1 ) = 1 end do else counter = counter + 1 if ( num1 > proj_sites ( species )) & call io_error ( 'projection_analyse_substring: Atom number given in pdos string & &is greater than number of atoms for given species' ) pdos_atoms ( num1 ) = 1 end if if ( scan ( dummy , c_sep ) == 1 ) dummy = adjustl ( dummy ( 2 :)) if ( scan ( dummy , c_range ) == 1 ) & & call io_error ( 'projection_analyse_substring: Error parsing atoms numbers - incorrect range' ) if ( index ( dummy , ' ' ) == 1 ) exit end do else site_sum = . true . end if ! count am counter = 0 dummy = adjustl ( c_am ) if ( len_trim ( dummy ) > 0 ) then do pos3 = index ( dummy , ',' ) if ( pos3 == 0 ) then ctemp2 = dummy else ctemp2 = dummy (: pos3 - 1 ) end if read ( ctemp2 ( 1 :), * , err = 106 , end = 106 ) m_string select case ( trim ( adjustl ( m_string ))) case ( 's' ) pdos_ang ( 1 ) = 1 case ( 'p' ) pdos_ang ( 2 ) = 1 case ( 'd' ) pdos_ang ( 3 ) = 1 case ( 'f' ) pdos_ang ( 4 ) = 1 case default call io_error ( 'projection_analyse_substring: Problem reading l state ' ) end select if ( pos3 == 0 ) exit dummy = dummy ( pos3 + 1 :) end do else am_sum = . true . end if if ( site_sum ) then num_sites = 1 else num_sites = count ( pdos_atoms == 1 ) end if if ( am_sum ) then num_am = 1 else num_am = count ( pdos_ang == 1 ) end if if ( lcount ) species_proj = num_am * num_sites if (. not . lcount ) then loop_p = 1 + offset if ( site_sum . and . am_sum ) then projection_array ( species , :, :, loop_p ) = 1 elseif ( site_sum . and . . not . am_sum ) then do loop_l = 1 , max_am if ( pdos_ang ( loop_l ) == 0 ) cycle projection_array ( species , :, loop_l , loop_p ) = 1 loop_p = loop_p + 1 end do elseif (. not . site_sum . and . am_sum ) then do loop_a = 1 , proj_sites ( species ) if ( pdos_atoms ( loop_a ) == 0 ) cycle projection_array ( species , loop_a , :, loop_p ) = 1 loop_p = loop_p + 1 end do else do loop_l = 1 , max_am if ( pdos_ang ( loop_l ) == 0 ) cycle do loop_a = 1 , proj_sites ( species ) if ( pdos_atoms ( loop_a ) == 0 ) cycle projection_array ( species , loop_a , loop_l , loop_p ) = 1 loop_p = loop_p + 1 end do end do end if offset = loop_p - 1 end if return 101 call io_error ( 'projection_analyse_substring Error parsing keyword ' ) 106 call io_error ( 'projection_analyse_substring: Problem reading l state into string ' ) end subroutine projection_analyse_substring end subroutine projection_get_string","tags":"","loc":"proc/projection_get_string.html"},{"title":"projection_merge – OptaDOS","text":"public  subroutine projection_merge() Uses od_electronic od_comms od_io od_cell proc~~projection_merge~~UsesGraph proc~projection_merge projection_merge module~od_electronic od_electronic proc~projection_merge->module~od_electronic module~od_comms od_comms proc~projection_merge->module~od_comms module~od_io od_io proc~projection_merge->module~od_io module~od_cell od_cell proc~projection_merge->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~projection_merge~~CallsGraph proc~projection_merge projection_merge proc~io_error io_error proc~projection_merge->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~projection_merge~~CalledByGraph proc~projection_merge projection_merge proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~projection_merge proc~pdis_calculate pdis_calculate proc~pdis_calculate->proc~projection_merge program~optados optados program~optados->proc~pdos_calculate program~optados->proc~pdis_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code projection_merge Source Code subroutine projection_merge !=============================================================================== ! This subroutine accumulates the weights of desired projectors into the ! matrix_weights array. !=============================================================================== use od_electronic , only : pdos_orbital , pdos_weights , pdos_mwab , nspins use od_cell , only : num_kpoints_on_node use od_comms , only : my_node_id use od_io , only : io_error , stdout implicit none integer :: N , N_spin , n_eigen , nproj , orb , ierr allocate ( matrix_weights ( num_proj , pdos_mwab % nbands , num_kpoints_on_node ( my_node_id ), nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_merge - allocation of matrix_weights failed' ) matrix_weights = 0.0_dp do N = 1 , num_kpoints_on_node ( my_node_id ) ! Loop over kpoints do N_spin = 1 , nspins ! Loop over spins do n_eigen = 1 , pdos_mwab % nbands ! Loop over unoccupied states do nproj = 1 , num_proj do orb = 1 , pdos_mwab % norbitals if ( projection_array ( pdos_orbital % species_no ( orb ), pdos_orbital % rank_in_species ( orb ) & , pdos_orbital % am_channel ( orb ) + 1 , nproj ) == 1 ) then matrix_weights ( nproj , n_eigen , N , N_spin ) = matrix_weights ( nproj , n_eigen , N , N_spin ) + & pdos_weights ( orb , n_eigen , N , N_spin ) end if end do end do end do end do end do return end subroutine projection_merge","tags":"","loc":"proc/projection_merge.html"},{"title":"algorithms_erf – OptaDOS","text":"public  function algorithms_erf(x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) Contents Source Code algorithms_erf Source Code function algorithms_erf ( x ) ! Calculate the error function ! From the NSWC Mathematics Subroutine Library implicit none real ( kind = dp ), intent ( in ) :: x real ( kind = dp ) :: algorithms_erf real ( kind = dp ) :: C = 0.564189583547756_dp real ( kind = dp ), dimension ( 1 : 5 ) :: A = ( / 0.771058495001320E-04_dp , - 0.133733772997339E-02_dp , & & 0.323076579225834E-01_dp , 0.479137145607681E-01_dp , 0.128379167095513E+00_dp / ) real ( kind = dp ), dimension ( 1 : 3 ) :: B = ( / 0.301048631703895E-02_dp , 0.538971687740286E-01_dp , & & 0.375795757275549E+00_dp / ) real ( kind = dp ), dimension ( 1 : 8 ) :: P = ( /- 1.36864857382717E-07_dp , 5.64195517478974E-01_dp , & & 7.21175825088309E+00_dp , 4.31622272220567E+01_dp , 1.52989285046940E+02_dp , & & 3.39320816734344E+02_dp , 4.51918953711873E+02_dp , 3.00459261020162E+02_dp / ) real ( kind = dp ), dimension ( 1 : 8 ) :: Q = ( / 1.00000000000000E+00_dp , 1.27827273196294E+01_dp , & & 7.70001529352295E+01_dp , 2.77585444743988E+02_dp , 6.38980264465631E+02_dp , & & 9.31354094850610E+02_dp , 7.90950925327898E+02_dp , 3.00459260956983E+02_dp / ) real ( kind = dp ), dimension ( 1 : 5 ) :: R = ( / 2.10144126479064E+00_dp , 2.62370141675169E+01_dp , & & 2.13688200555087E+01_dp , 4.65807828718470E+00_dp , 2.82094791773523E-01_dp / ) real ( kind = dp ), dimension ( 1 : 4 ) :: S = ( / 9.41537750555460E+01_dp , 1.87114811799590E+02_dp , & & 9.90191814623914E+01_dp , 1.80124575948747E+01_dp / ) real ( kind = dp ) :: ax , t , top , bot , x2 AX = abs ( X ) if ( AX <= 0.5_dp ) then T = X * X top = (((( A ( 1 ) * T + A ( 2 )) * T + A ( 3 )) * T + A ( 4 )) * T + A ( 5 )) + 1.0_dp bot = (( B ( 1 ) * T + B ( 2 )) * T + B ( 3 )) * T + 1.0_dp algorithms_erf = X * ( top / bot ) return elseif ( AX <= 4.0_dp ) then top = (((((( P ( 1 ) * AX + P ( 2 )) * AX + P ( 3 )) * AX + P ( 4 )) * AX + P ( 5 )) * AX & & + P ( 6 )) * AX + P ( 7 )) * AX + P ( 8 ) bot = (((((( Q ( 1 ) * AX + Q ( 2 )) * AX + Q ( 3 )) * AX + Q ( 4 )) * AX + Q ( 5 )) * AX & & + Q ( 6 )) * AX + Q ( 7 )) * AX + Q ( 8 ) algorithms_erf = 0.5_dp + ( 0.5_dp - exp ( - X * X ) * top / bot ) if ( X < 0.0_dp ) algorithms_erf = - algorithms_erf return elseif ( AX <= 5.8_dp ) then X2 = X * X T = 1.0_dp / X2 top = ((( R ( 1 ) * T + R ( 2 )) * T + R ( 3 )) * T + R ( 4 )) * T + R ( 5 ) bot = ((( S ( 1 ) * T + S ( 2 )) * T + S ( 3 )) * T + S ( 4 )) * T + 1.0 algorithms_erf = ( C - top / ( X2 * bot )) / AX algorithms_erf = 0.5_dp + ( 0.5_dp - exp ( - X2 ) * algorithms_erf ) if ( X < 0.0_dp ) algorithms_erf = - algorithms_erf return else algorithms_erf = 1.0_dp if ( X < 0.0_dp ) algorithms_erf = - algorithms_erf end if end function algorithms_erf","tags":"","loc":"proc/algorithms_erf.html"},{"title":"channel_to_am – OptaDOS","text":"public  function channel_to_am(no) Arguments Type Intent Optional Attributes Name integer, intent(in) :: no Return Value character(len=1) Contents Source Code channel_to_am Source Code function channel_to_am ( no ) implicit none character ( len = 1 ) :: channel_to_am integer , intent ( in ) :: no select case ( no ) case ( 1 ) channel_to_am = \"s\" case ( 2 ) channel_to_am = \"p\" case ( 3 ) channel_to_am = \"d\" case ( 4 ) channel_to_am = \"f\" case ( 5 ) channel_to_am = \"g\" end select end function channel_to_am","tags":"","loc":"proc/channel_to_am.html"},{"title":"gaussian – OptaDOS","text":"public  function gaussian(m, w, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: m real(kind=dp), intent(in) :: w real(kind=dp), intent(in) :: x Return Value real(kind=dp) Called by proc~~gaussian~~CalledByGraph proc~gaussian gaussian proc~calculate_jdos calculate_jdos proc~calculate_jdos->proc~gaussian proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code gaussian Source Code function gaussian ( m , w , x ) !=========================================================================! ! ** Return value of Gaussian(mean=m,width=w) at position x ! I don't know who's this function originally was, CJP? MIJP? !=========================================================================! implicit none real ( kind = dp ), intent ( in ) :: m , w , x real ( kind = dp ) :: gaussian if ( 0.5_dp * (( x - m ) / w ) ** 2 . gt . 3 0.0_dp ) then gaussian = 0.0_dp return else gaussian = inv_sqrt_two_pi * exp ( - 0.5_dp * (( x - m ) / w ) ** 2 ) / w end if return end function gaussian","tags":"","loc":"proc/gaussian.html"},{"title":"utility_lowercase – OptaDOS","text":"public  function utility_lowercase(string) Uses od_io proc~~utility_lowercase~~UsesGraph proc~utility_lowercase utility_lowercase module~od_io od_io proc~utility_lowercase->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=maxlen) Called by proc~~utility_lowercase~~CalledByGraph proc~utility_lowercase utility_lowercase proc~cell_read_cell cell_read_cell proc~cell_read_cell->proc~utility_lowercase proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->proc~utility_lowercase proc~param_read param_read proc~param_read->proc~cell_read_cell program~optados optados program~optados->proc~param_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code utility_lowercase Source Code function utility_lowercase ( string ) !=========================================================================! ! Takes a string and converts to lowercase characters !=========================================================================! use od_io , only : maxlen implicit none character ( len =* ), intent ( in ) :: string character ( len = maxlen ) :: utility_lowercase integer :: iA , iZ , idiff , ipos , ilett iA = ichar ( 'A' ) iZ = ichar ( 'Z' ) idiff = iZ - ichar ( 'z' ) utility_lowercase = string do ipos = 1 , len ( string ) ilett = ichar ( string ( ipos : ipos )) if (( ilett . ge . iA ) . and . ( ilett . le . iZ )) & utility_lowercase ( ipos : ipos ) = char ( ilett - idiff ) end do utility_lowercase = trim ( adjustl ( utility_lowercase )) return end function utility_lowercase","tags":"","loc":"proc/utility_lowercase.html"},{"title":"algor_dist_array – OptaDOS","text":"public  subroutine algor_dist_array(num_elements, elements_per_node) Uses od_comms od_io proc~~algor_dist_array~~UsesGraph proc~algor_dist_array algor_dist_array module~od_comms od_comms proc~algor_dist_array->module~od_comms module~od_io od_io proc~algor_dist_array->module~od_io module~od_constants od_constants module~od_comms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_elements integer, intent(out), allocatable :: elements_per_node (:) Calls proc~~algor_dist_array~~CallsGraph proc~algor_dist_array algor_dist_array proc~io_error io_error proc~algor_dist_array->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~algor_dist_array~~CalledByGraph proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->proc~algor_dist_array proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->proc~algor_dist_array proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->proc~algor_dist_array proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->proc~algor_dist_array proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_set_efermi dos_utils_set_efermi proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~read_ome_bin read_ome_bin proc~read_ome_bin->proc~elec_read_optical_mat proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_dome_bin read_dome_bin proc~read_dome_bin->proc~elec_read_band_gradient proc~optics_calculate optics_calculate proc~optics_calculate->proc~elec_read_optical_mat proc~optics_calculate->proc~jdos_utils_calculate proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_set_efermi proc~get_band_energy get_band_energy proc~get_band_energy->proc~elec_read_band_energy program~optados optados program~optados->proc~elec_read_band_energy program~optados->proc~elec_read_band_energy_ordered program~optados->proc~optics_calculate proc~pdos_calculate pdos_calculate program~optados->proc~pdos_calculate proc~core_calculate core_calculate program~optados->proc~core_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~read_fem_bin read_fem_bin proc~read_fem_bin->proc~elec_read_foptical_mat proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi program~od2od od2od program~od2od->proc~read_ome_bin program~od2od->proc~read_dome_bin program~od2od->proc~get_band_energy program~od2od->proc~read_fem_bin proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code algor_dist_array Source Code subroutine algor_dist_array ( num_elements , elements_per_node ) ! Takes the number of elements in an array, num_elements ! Returns an array 0,num_nodes-1 which contains the number of ! elements that should be on each node. ! AJM based on an idea from JRY !====================================================== use od_comms , only : num_nodes use od_io , only : io_error implicit none integer , intent ( in ) :: num_elements integer , allocatable , intent ( out ) :: elements_per_node (:) integer :: loop , ierr allocate ( elements_per_node ( 0 : num_nodes - 1 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating elements_per_node in algor_dist_array' ) elements_per_node (:) = num_elements / num_nodes if ( num_elements < num_nodes ) then call io_error ( 'Fewer kpoints than nodes. Reduce the number of nodes used!' ) end if ! Distribute the remainder if ( elements_per_node ( 0 ) * num_nodes . ne . num_elements ) then do loop = 0 , num_elements - elements_per_node ( 0 ) * num_nodes - 1 elements_per_node ( loop ) = elements_per_node ( loop ) + 1 end do end if end subroutine algor_dist_array","tags":"","loc":"proc/algor_dist_array.html"},{"title":"heap_sort – OptaDOS","text":"public  subroutine heap_sort(num_items, weight) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_items real(kind=dp), intent(inout), dimension(num_items) :: weight Called by proc~~heap_sort~~CalledByGraph proc~heap_sort heap_sort proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~doslin_sub_cell_corners->proc~heap_sort proc~calculate_jdos calculate_jdos proc~calculate_jdos->proc~doslin_sub_cell_corners proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code heap_sort Source Code subroutine heap_sort ( num_items , weight ) !=========================================================================! ! This subroutine sorts the list of weights into descending order.        ! ! On exit, if present, the array of indexes contains the original index   ! ! of each item.                                                           ! !                                                                         ! ! This is a heap sort                                                     ! !-------------------------------------------------------------------------! ! Arguments:                                                              ! !   num_items (input) :: The number of items to sort                      ! !   weight (in/out) :: The weights of each item. On exit these are        ! !                      sorted into descending order.                      ! !-------------------------------------------------------------------------! ! Parent module variables used:                                           ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Modules used:                                                           ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Necessary conditions:                                                   ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Written by Chris Pickard 22nd May 2009                                  ! !=========================================================================! implicit none ! Arguments integer , intent ( in ) :: num_items real ( kind = dp ), dimension ( num_items ), intent ( inout ) :: weight ! Local variables integer :: i , ir , j , l ! Loop counters real ( kind = dp ) :: wta if ( num_items . lt . 2 ) return l = num_items / 2 + 1 ir = num_items do if ( l . gt . 1 ) then l = l - 1 wta = weight ( l ) else wta = weight ( ir ) weight ( ir ) = weight ( 1 ) ir = ir - 1 if ( ir . eq . 1 ) then weight ( 1 ) = wta return end if end if i = l j = l + l 20 if ( j . le . ir ) then if ( j . lt . ir ) then if ( weight ( j ) . lt . weight ( j + 1 )) j = j + 1 end if if ( wta . lt . weight ( j )) then weight ( i ) = weight ( j ) i = j j = j + j else j = ir + 1 end if goto 20 end if weight ( i ) = wta end do end subroutine heap_sort","tags":"","loc":"proc/heap_sort.html"},{"title":"utility_cart_to_frac – OptaDOS","text":"public  subroutine utility_cart_to_frac(cart, frac, recip_lat) Uses od_constants proc~~utility_cart_to_frac~~UsesGraph proc~utility_cart_to_frac utility_cart_to_frac module~od_constants od_constants proc~utility_cart_to_frac->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: cart (3) real(kind=dp), intent(out) :: frac (3) real(kind=dp), intent(in) :: recip_lat (3,3) Called by proc~~utility_cart_to_frac~~CalledByGraph proc~utility_cart_to_frac utility_cart_to_frac proc~cell_read_cell cell_read_cell proc~cell_read_cell->proc~utility_cart_to_frac proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->proc~utility_cart_to_frac proc~param_read param_read proc~param_read->proc~cell_read_cell program~optados optados program~optados->proc~param_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code utility_cart_to_frac Source Code subroutine utility_cart_to_frac ( cart , frac , recip_lat ) !==================================================================! !                                                                  ! !  Convert from fractional to Cartesian coordinates                ! !                                                                  ! !=================================================================== use od_constants , only : twopi implicit none real ( kind = dp ), intent ( in ) :: recip_lat ( 3 , 3 ) real ( kind = dp ), intent ( out ) :: frac ( 3 ) real ( kind = dp ), intent ( in ) :: cart ( 3 ) integer :: i do i = 1 , 3 frac ( i ) = recip_lat ( i , 1 ) * cart ( 1 ) + recip_lat ( i , 2 ) * cart ( 2 ) + recip_lat ( i , 3 ) * cart ( 3 ) end do frac = frac / twopi return end subroutine utility_cart_to_frac","tags":"","loc":"proc/utility_cart_to_frac.html"},{"title":"utility_frac_to_cart – OptaDOS","text":"public  subroutine utility_frac_to_cart(frac, cart, real_lat) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frac (3) real(kind=dp), intent(out) :: cart (3) real(kind=dp), intent(in) :: real_lat (3,3) Called by proc~~utility_frac_to_cart~~CalledByGraph proc~utility_frac_to_cart utility_frac_to_cart proc~cell_read_cell cell_read_cell proc~cell_read_cell->proc~utility_frac_to_cart proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->proc~utility_frac_to_cart proc~param_read param_read proc~param_read->proc~cell_read_cell program~optados optados program~optados->proc~param_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code utility_frac_to_cart Source Code subroutine utility_frac_to_cart ( frac , cart , real_lat ) !==================================================================! !                                                                  ! !  Convert from fractional to Cartesian coordinates                ! !                                                                  ! !=================================================================== implicit none real ( kind = dp ), intent ( in ) :: real_lat ( 3 , 3 ) real ( kind = dp ), intent ( in ) :: frac ( 3 ) real ( kind = dp ), intent ( out ) :: cart ( 3 ) integer :: i do i = 1 , 3 cart ( i ) = real_lat ( 1 , i ) * frac ( 1 ) + real_lat ( 2 , i ) * frac ( 2 ) + real_lat ( 3 , i ) * frac ( 3 ) end do return end subroutine utility_frac_to_cart","tags":"","loc":"proc/utility_frac_to_cart.html"},{"title":"utility_reciprocal_cart_to_frac – OptaDOS","text":"public  subroutine utility_reciprocal_cart_to_frac(cart, frac, real_lattice) Uses od_constants proc~~utility_reciprocal_cart_to_frac~~UsesGraph proc~utility_reciprocal_cart_to_frac utility_reciprocal_cart_to_frac module~od_constants od_constants proc~utility_reciprocal_cart_to_frac->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: cart (3) real(kind=dp), intent(out) :: frac (3) real(kind=dp), intent(in) :: real_lattice (3,3) Contents Source Code utility_reciprocal_cart_to_frac Source Code subroutine utility_reciprocal_cart_to_frac ( cart , frac , real_lattice ) !==================================================================! !                                                                  ! !  Convert from fractional to Cartesian coordinates in reicprocal  ! !                                                                  ! !=================================================================== use od_constants , only : twopi implicit none real ( kind = dp ), intent ( in ) :: real_lattice ( 3 , 3 ) real ( kind = dp ), intent ( out ) :: frac ( 3 ) real ( kind = dp ), intent ( in ) :: cart ( 3 ) integer :: i do i = 1 , 3 frac ( i ) = real_lattice ( 1 , i ) * cart ( 1 ) + real_lattice ( 2 , i ) * cart ( 2 ) + real_lattice ( 3 , i ) * cart ( 3 ) end do frac = frac / twopi return end subroutine utility_reciprocal_cart_to_frac","tags":"","loc":"proc/utility_reciprocal_cart_to_frac.html"},{"title":"utility_reciprocal_frac_to_cart – OptaDOS","text":"public  subroutine utility_reciprocal_frac_to_cart(frac_rec, cart_rec, recip_lattice) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frac_rec (3) real(kind=dp), intent(out) :: cart_rec (3) real(kind=dp), intent(in) :: recip_lattice (3,3) Called by proc~~utility_reciprocal_frac_to_cart~~CalledByGraph proc~utility_reciprocal_frac_to_cart utility_reciprocal_frac_to_cart proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->proc~utility_reciprocal_frac_to_cart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code utility_reciprocal_frac_to_cart Source Code subroutine utility_reciprocal_frac_to_cart ( frac_rec , cart_rec , recip_lattice ) !==================================================================! !                                                                  ! !  Convert k points from fractional to Cartesian coordinates       ! !                                                                  ! !=================================================================== implicit none real ( kind = dp ), intent ( in ) :: recip_lattice ( 3 , 3 ) real ( kind = dp ), intent ( in ) :: frac_rec ( 3 ) real ( kind = dp ), intent ( out ) :: cart_rec ( 3 ) integer :: i do i = 1 , 3 cart_rec ( i ) = recip_lattice ( 1 , i ) * frac_rec ( 1 ) + recip_lattice ( 2 , i ) * frac_rec ( 2 ) + recip_lattice ( 3 , i ) * frac_rec ( 3 ) end do return end subroutine utility_reciprocal_frac_to_cart","tags":"","loc":"proc/utility_reciprocal_frac_to_cart.html"},{"title":"help_output – OptaDOS","text":"subroutine help_output() Uses od_constants proc~~help_output~~UsesGraph proc~help_output help_output module~od_constants od_constants proc~help_output->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~help_output~~CalledByGraph proc~help_output help_output program~optados optados program~optados->proc~help_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code help_output Source Code subroutine help_output use od_constants , only : optados_version , copyright implicit none write ( * , * ) write ( * , * ) \" OptaDOS version \" , trim ( build_info % build ) write ( * , * ) write ( * , * ) \" Andrew J. Morris, R. J. Nicholls, C. J. Pickard and J. R. Yates\" , trim ( copyright ) write ( * , * ) \" Usage: optados <seedname>\" write ( * , * ) stop end subroutine help_output","tags":"","loc":"proc/help_output.html"},{"title":"version_output – OptaDOS","text":"subroutine version_output() Uses od_build od_constants proc~~version_output~~UsesGraph proc~version_output version_output module~od_build od_build proc~version_output->module~od_build module~od_constants od_constants proc~version_output->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~version_output~~CalledByGraph proc~version_output version_output program~optados optados program~optados->proc~version_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code version_output Source Code subroutine version_output use od_build , only : build_info use od_constants , only : optados_version , copyright implicit none write ( * , * ) write ( * , * ) \" OptaDOS version \" , trim ( build_info % build ) write ( * , * ) write ( * , * ) \" Andrew J. Morris, R. J. Nicholls, C. J. Pickard and J. R. Yates\" , trim ( copyright ) write ( * , * ) \" Compiled with \" // trim ( build_info % compiler ) // \" on \" // trim ( build_info % compile_date )& & // \" at \" // trim ( build_info % compile_time ) // \".\" write ( * , * ) \" Compile type: \" // trim ( build_info % build_type ) // \", \" // trim ( build_info % comms_arch ) write ( * , * ) \" From source \" // trim ( build_info % build ) // \" submitted on \" // trim ( build_info % source_date )& & // \" at \" // trim ( build_info % source_time ) // \".\" stop end subroutine version_output","tags":"","loc":"proc/version_output.html"},{"title":"jdos_calculate – OptaDOS","text":"public  subroutine jdos_calculate() Uses od_io od_comms od_parameters od_jdos_utils proc~~jdos_calculate~~UsesGraph proc~jdos_calculate jdos_calculate module~od_io od_io proc~jdos_calculate->module~od_io module~od_comms od_comms proc~jdos_calculate->module~od_comms module~od_jdos_utils od_jdos_utils proc~jdos_calculate->module~od_jdos_utils module~od_parameters od_parameters proc~jdos_calculate->module~od_parameters module~od_constants od_constants module~od_io->module~od_constants module~od_comms->module~od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~jdos_calculate~~CallsGraph proc~jdos_calculate jdos_calculate proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~write_jdos write_jdos proc~jdos_calculate->proc~write_jdos proc~io_time io_time proc~jdos_calculate->proc~io_time proc~jdos_utils_calculate->proc~io_time proc~elec_read_band_gradient elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_calculate->proc~jdos_utils_merge proc~dos_utils_set_efermi dos_utils_set_efermi proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~setup_energy_scale setup_energy_scale proc~jdos_utils_calculate->proc~setup_energy_scale proc~calculate_jdos calculate_jdos proc~jdos_utils_calculate->proc~calculate_jdos proc~io_error io_error proc~jdos_utils_calculate->proc~io_error proc~write_jdos->proc~io_error proc~io_file_unit io_file_unit proc~write_jdos->proc~io_file_unit proc~io_date io_date proc~write_jdos->proc~io_date proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos->proc~write_jdos_xmgrace proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send interface~comms_bcast comms_bcast proc~elec_read_band_gradient->interface~comms_bcast proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical interface~comms_reduce comms_reduce proc~jdos_utils_merge->interface~comms_reduce proc~dos_utils_set_efermi->proc~io_error proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~setup_energy_scale->proc~io_error proc~setup_energy_scale->interface~comms_bcast proc~setup_energy_scale->interface~comms_reduce proc~calculate_jdos->proc~io_error proc~doslin doslin proc~calculate_jdos->proc~doslin proc~allocate_jdos allocate_jdos proc~calculate_jdos->proc~allocate_jdos proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~calculate_jdos->proc~doslin_sub_cell_corners proc~gaussian gaussian proc~calculate_jdos->proc~gaussian proc~write_jdos_xmgrace->proc~io_error proc~write_jdos_xmgrace->proc~io_file_unit proc~xmgu_legend xmgu_legend proc~write_jdos_xmgrace->proc~xmgu_legend proc~xmgu_subtitle xmgu_subtitle proc~write_jdos_xmgrace->proc~xmgu_subtitle proc~xmgu_axis xmgu_axis proc~write_jdos_xmgrace->proc~xmgu_axis proc~xmgu_data xmgu_data proc~write_jdos_xmgrace->proc~xmgu_data proc~xmgu_setup xmgu_setup proc~write_jdos_xmgrace->proc~xmgu_setup proc~xmgu_data_header xmgu_data_header proc~write_jdos_xmgrace->proc~xmgu_data_header proc~xmgu_title xmgu_title proc~write_jdos_xmgrace->proc~xmgu_title proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~algor_dist_array->proc~io_error proc~xmgu_data->proc~io_error proc~allocate_jdos->proc~io_error proc~xmgu_setup->proc~io_date proc~heap_sort heap_sort proc~doslin_sub_cell_corners->proc~heap_sort proc~elec_dealloc_optical->proc~io_error proc~dos_utils_calculate->proc~io_time proc~dos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_calculate->proc~io_error proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~dos_utils_merge->interface~comms_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~jdos_calculate~~CalledByGraph proc~jdos_calculate jdos_calculate program~optados optados program~optados->proc~jdos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code jdos_calculate Source Code subroutine jdos_calculate !=============================================================================== use od_jdos_utils , only : jdos_utils_calculate , E , jdos_fixed & &, jdos_adaptive , jdos_linear use od_parameters , only : fixed , adaptive , linear use od_io , only : io_time , stdout use od_comms , only : on_root implicit none real ( kind = dp ) :: time0 , time1 if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                           Joint Density of States                          +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if call jdos_utils_calculate !------------------------------------------------------------------------------- ! W R I T E   O U T   J D O S time0 = io_time () ! Otherwise we have written to wdos and dos, so they can be called ! by whatever. if ( on_root ) then if ( fixed ) call write_jdos ( E , jdos_fixed , \"fixed\" ) if ( adaptive ) call write_jdos ( E , jdos_adaptive , \"adaptive\" ) if ( linear ) call write_jdos ( E , jdos_linear , \"linear\" ) !if(quad)    call write_jdos(E, dos_quad, intdos_quad, \"quad\") end if time1 = io_time () !------------------------------------------------------------------------------- end subroutine jdos_calculate","tags":"","loc":"proc/jdos_calculate.html"},{"title":"write_jdos – OptaDOS","text":"public  subroutine write_jdos(E, dos, dos_name) Uses od_electronic od_jdos_utils od_io od_parameters proc~~write_jdos~~UsesGraph proc~write_jdos write_jdos module~od_electronic od_electronic proc~write_jdos->module~od_electronic module~od_parameters od_parameters proc~write_jdos->module~od_parameters module~od_jdos_utils od_jdos_utils proc~write_jdos->module~od_jdos_utils module~od_io od_io proc~write_jdos->module~od_io module~od_constants od_constants module~od_electronic->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_jdos_utils->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: E (jdos_nbins) real(kind=dp), intent(in) :: dos (jdos_nbins,nspins) character(len=*), intent(in) :: dos_name Calls proc~~write_jdos~~CallsGraph proc~write_jdos write_jdos proc~io_file_unit io_file_unit proc~write_jdos->proc~io_file_unit proc~io_date io_date proc~write_jdos->proc~io_date proc~io_error io_error proc~write_jdos->proc~io_error proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos->proc~write_jdos_xmgrace proc~write_jdos_xmgrace->proc~io_file_unit proc~write_jdos_xmgrace->proc~io_error proc~xmgu_legend xmgu_legend proc~write_jdos_xmgrace->proc~xmgu_legend proc~xmgu_subtitle xmgu_subtitle proc~write_jdos_xmgrace->proc~xmgu_subtitle proc~xmgu_title xmgu_title proc~write_jdos_xmgrace->proc~xmgu_title proc~xmgu_axis xmgu_axis proc~write_jdos_xmgrace->proc~xmgu_axis proc~xmgu_setup xmgu_setup proc~write_jdos_xmgrace->proc~xmgu_setup proc~xmgu_data_header xmgu_data_header proc~write_jdos_xmgrace->proc~xmgu_data_header proc~xmgu_data xmgu_data proc~write_jdos_xmgrace->proc~xmgu_data proc~xmgu_setup->proc~io_date proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_jdos~~CalledByGraph proc~write_jdos write_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos program~optados optados program~optados->proc~jdos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_jdos Source Code subroutine write_jdos ( E , dos , dos_name ) use od_parameters , only : dos_per_volume , output_format use od_jdos_utils , only : jdos_nbins use od_electronic , only : nspins use od_io , only : io_file_unit , seedname , stdout , io_error , io_date !=============================================================================== ! This routine receives an energy scale, a density of states and a file name ! and writes out the DOS to disk !=============================================================================== implicit none real ( kind = dp ), intent ( in ) :: E ( jdos_nbins ) real ( kind = dp ), intent ( in ) :: dos ( jdos_nbins , nspins ) character ( len =* ), intent ( in ) :: dos_name integer :: i , dos_file , ierr character ( len = 11 ) :: cdate character ( len = 9 ) :: ctime character ( len = 22 ) :: dos_units , intdos_units dos_file = io_file_unit () open ( unit = dos_file , file = trim ( seedname ) // '.j' // trim ( dos_name ) // '.dat' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open output file in dos: write_dos\" ) dos_units = \"(electrons per eV)\" ; intdos_units = \"(electrons)\" if ( dos_per_volume ) then dos_units = \"(electrons per eV/A&#94;3)\" intdos_units = \"(electrons per A&#94;3)\" end if write ( dos_file , * ) \"##############################################################################\" write ( dos_file , * ) \"#\" write ( dos_file , * ) \"#                  O p t a D O S   o u t p u t   f i l e \" write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , * ) \"#    Density of States using \" , trim ( dos_name ), \" broadening\" call io_date ( cdate , ctime ) write ( dos_file , * ) '#  Generated on ' , cdate , ' at ' , ctime write ( dos_file , * ) \"# Column        Data\" write ( dos_file , * ) \"#    1        Energy (eV)\" if ( nspins > 1 ) then write ( dos_file , * ) \"#    2        Up-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Down-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    4        Up-spin Integrated DOS \" , trim ( intdos_units ) write ( dos_file , * ) \"#    5        Down-spin Integrated DOS \" , trim ( intdos_units ) else write ( dos_file , * ) \"#    2        DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Integrated DOS \" , trim ( intdos_units ) end if write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , '(1x,a78)' ) \"##############################################################################\" if ( nspins > 1 ) then do i = 1 , jdos_nbins write ( dos_file , '(3(E21.13,2x))' ) E ( i ), dos ( i , 1 ), - dos ( i , 2 ) end do else do i = 1 , jdos_nbins write ( dos_file , '(2(E21.13,2x))' ) E ( i ), dos ( i , 1 ) end do end if close ( dos_file ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_jdos_xmgrace ( dos_name , E , dos ) elseif ( trim ( output_format ) == \"gnuplot\" ) then write ( stdout , * ) \" WARNING: GNUPLOT output not yet available, calling xmgrace\" call write_jdos_xmgrace ( dos_name , E , dos ) !     call write_dos_gnuplot(dos_name,E,dos) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_jdos","tags":"","loc":"proc/write_jdos.html"},{"title":"write_jdos_xmgrace – OptaDOS","text":"public  subroutine write_jdos_xmgrace(dos_name, E, dos) Uses od_electronic od_jdos_utils od_io xmgrace_utils proc~~write_jdos_xmgrace~~UsesGraph proc~write_jdos_xmgrace write_jdos_xmgrace module~od_electronic od_electronic proc~write_jdos_xmgrace->module~od_electronic module~od_jdos_utils od_jdos_utils proc~write_jdos_xmgrace->module~od_jdos_utils module~xmgrace_utils xmgrace_utils proc~write_jdos_xmgrace->module~xmgrace_utils module~od_io od_io proc~write_jdos_xmgrace->module~od_io module~od_constants od_constants module~od_electronic->module~od_constants module~od_jdos_utils->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dos_name real(kind=dp), intent(in) :: E (jdos_nbins) real(kind=dp), intent(in) :: dos (jdos_nbins,nspins) Calls proc~~write_jdos_xmgrace~~CallsGraph proc~write_jdos_xmgrace write_jdos_xmgrace proc~io_file_unit io_file_unit proc~write_jdos_xmgrace->proc~io_file_unit proc~xmgu_legend xmgu_legend proc~write_jdos_xmgrace->proc~xmgu_legend proc~io_error io_error proc~write_jdos_xmgrace->proc~io_error proc~xmgu_title xmgu_title proc~write_jdos_xmgrace->proc~xmgu_title proc~xmgu_setup xmgu_setup proc~write_jdos_xmgrace->proc~xmgu_setup proc~xmgu_subtitle xmgu_subtitle proc~write_jdos_xmgrace->proc~xmgu_subtitle proc~xmgu_axis xmgu_axis proc~write_jdos_xmgrace->proc~xmgu_axis proc~xmgu_data_header xmgu_data_header proc~write_jdos_xmgrace->proc~xmgu_data_header proc~xmgu_data xmgu_data proc~write_jdos_xmgrace->proc~xmgu_data proc~io_date io_date proc~xmgu_setup->proc~io_date proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_jdos_xmgrace~~CalledByGraph proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos program~optados optados program~optados->proc~jdos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_jdos_xmgrace Source Code subroutine write_jdos_xmgrace ( dos_name , E , dos ) !=============================================================================== use xmgrace_utils use od_jdos_utils , only : jdos_nbins use od_electronic , only : nspins use od_io , only : io_file_unit , io_error , seedname implicit none real ( kind = dp ), intent ( in ) :: E ( jdos_nbins ) real ( kind = dp ), intent ( in ) :: dos ( jdos_nbins , nspins ) real ( kind = dp ) :: min_x , max_x , min_y , max_y integer :: batch_file , ierr character ( len =* ), intent ( in ) :: dos_name batch_file = io_file_unit () open ( unit = batch_file , file = trim ( seedname ) // '.j' // trim ( dos_name ) // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in dos: write_jdos_xmgrace\" ) min_x = minval ( E ) max_x = maxval ( E ) min_y = 0 max_y = maxval ( dos ) if ( nspins > 1 ) then min_y = - max_y end if call xmgu_setup ( batch_file ) call xmgu_legend ( batch_file ) call xmgu_title ( batch_file , min_x , max_x , min_y , max_y , \"Joint Electronic Density of States\" ) call xmgu_subtitle ( batch_file , \"Generated by OptaDOS\" ) call xmgu_axis ( batch_file , \"x\" , \"Energy eV\" ) call xmgu_axis ( batch_file , \"y\" , \"JDOS\" ) if ( nspins > 1 ) then call xmgu_data_header ( batch_file , 0 , 1 , \"up-spin channel\" ) call xmgu_data_header ( batch_file , 1 , 2 , \"down-spin channel\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) call xmgu_data ( batch_file , 1 , E (:), - dos (:, 2 )) else call xmgu_data_header ( batch_file , 0 , 1 , \"Total JDOS\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) end if close ( batch_file ) end subroutine write_jdos_xmgrace","tags":"","loc":"proc/write_jdos_xmgrace.html"},{"title":"doslin – OptaDOS","text":"public  function doslin(e0, e1, e2, e3, e4, e, int) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e0 real(kind=dp), intent(in) :: e1 real(kind=dp), intent(in) :: e2 real(kind=dp), intent(in) :: e3 real(kind=dp), intent(in) :: e4 real(kind=dp), intent(in) :: e real(kind=dp), intent(out) :: int Return Value real(kind=dp) Called by proc~~doslin~~CalledByGraph proc~doslin doslin proc~calculate_jdos calculate_jdos proc~calculate_jdos->proc~doslin proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code doslin Source Code function doslin ( e0 , e1 , e2 , e3 , e4 , e , int ) !=============================================================================== ! Return the DoS contribution for a linear band portion and a cubic cell !------------------------------------------------------------------------------- ! Arguments: e0 (in) : Energy at centre of sub cell !   e1,e2,e3,e4 (in) : Energies of the four lowest corners of the sub cell !            e  (in) : Energy at which DOS is evaluated !          int  (out): Integrated DOS contribution for energy, E) ! (The function itself returns the DOS couribution for energy, E) !------------------------------------------------------------------------------- ! Parent Module Varables Used: None !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : C J Pickard. From LinDOS. Extra Comments A J Morris Sept 2010 !=============================================================================== implicit none ! - E X T R A   C O M M E N T S   B Y   A J M real ( kind = dp ), intent ( in ) :: e0 , e1 , e2 , e3 , e4 real ( kind = dp ), intent ( in ) :: e real ( kind = dp ), intent ( out ) :: int real ( kind = dp ) :: doslin real ( kind = dp ) :: alpha , e_use logical :: shift ! ** Check the input arguments ! The inputs must be in ascending order. These are the four lowest corners of the ! cube (sub cell) around the k-point. E_0 is the energy of the k-point which would ! in a Gaussian smearing scheme, be the only info we have about this cube of recip ! space. if (. not . (( e4 . le . e3 ) . and . ( e3 . le . e2 ) . and . ( e2 . le . e1 ) . and . ( e1 . le . e0 ))) then stop 'doslin: input arguments incorrect' end if ! ** Return if outside the range ! If the energy is below the smallest corner, then return. The CES doesn't cut this ! sub cell if ( e . le . e4 ) then doslin = 0.0_dp ! TRUE int = 0.0_dp ! TRUE return end if ! Since the energy in the sub cell is linearly extrapolated, if the energy is twice as ! big as the energy difference between the smallest corner and the middle, then this ! energy is outdside the top of the cell, and whilst this cell doesn't contribute to the ! CES, it does to the occupation. if ( e . ge . ( 2.0_dp * e0 - e4 )) then doslin = 0.0_dp ! TRUE int = 1.0_dp ! TRUE return end if ! ** Special treatment if all vertices at the same energy ! If the CES is perfectly flat in the cell, then we don't want to be dividing by zero. ! the below just catches this case and forces alpha to be 1. This is fine as the else ! block below looks for the same problem and the answer comes out correctly to if (( e1 == e2 ) . and . ( e1 == e3 ) . and . ( e3 == e4 )) then alpha = 1.0_dp else alpha = 1.0_dp / (( e1 - e3 ) * ( e1 - e4 ) + ( e3 - e4 ) ** 2 / 3.0_dp - ( e1 - e2 ) ** 2 / 3.0_dp + ( e1 + e2 - e3 - e4 ) * ( e0 - e1 )) ! TRUE end if ! ** Flip if above e0 ! If e is greater than the energy of the k-point, then we're going to subtract the ! contribution from a full cell, rather than add it to an empty one. The extrapolation ! is linear, so we can do this fine. if ( e . gt . e0 ) then e_use = 2.0_dp * e0 - e ! TRUE shift = . true . else e_use = e ! TRUE shift = . false . end if ! ** The analytic constributions to the DOS and integrated DOS if ( e_use . le . e4 ) then ! P O S S I B L E   S P E E D   U P ! If we ended up in here, something went wrong as this should already have been trapped. doslin = 0.0_dp ! TRUE int = 0.0_dp ! TRUE else if ( e_use . lt . e3 ) then ! There isn't a problem with divide by zero here. Since if e3=e4 and e_use < e3 ! we would have been caugh in the above if. doslin = ( e_use - e4 ) ** 2 / ( e3 - e4 ) / 2.0_dp ! TRUE int = ( e_use - e4 ) ** 3 / ( e3 - e4 ) / 6.0_dp ! TRUE else if ( e_use . lt . e2 ) then doslin = ( e_use - ( e3 + e4 ) / 2.0_dp ) ! TRUE int = (( e3 - e4 ) ** 2 / 3.0_dp + ( e_use - e3 ) * ( e_use - e4 )) / 2.0_dp ! TRUE else if ( e_use . lt . e1 ) then doslin = ( e1 + e2 - e3 - e4 ) / 2.0_dp ! TRUE ! Ok, so the IF costs more than the maths. But this way also catches the ! divide by zero. Clever! if ( e1 . ne . e2 ) doslin = doslin - ( e1 - e_use ) ** 2 / ( e1 - e2 ) / 2.0_dp ! TRUE int = (( e2 - e4 ) * ( e_use - e3 ) + ( e1 - e3 ) * ( e_use - e2 ) + ( e3 - e4 ) ** 2 / 3.0_dp + & (( e1 - e_use ) ** 3 - ( e1 - e2 ) ** 3 ) / ( e1 - e2 ) / 3.0_dp ) / 2.0_dp ! TRUE else if ( e_use . le . e0 ) then ! Check to see if the band is flat. if (( e1 + e2 - e3 - e4 ) . gt . 0.0_dp ) then doslin = ( e1 + e2 - e3 - e4 ) / 2.0_dp ! TRUE int = (( e1 - e3 ) * ( e1 - e4 ) + ( e3 - e4 ) ** 2 / 3.0_dp - ( e1 - e2 ) ** 2 / 3.0_dp + & ( e1 + e2 - e3 - e4 ) * ( e_use - e1 )) / 2.0_dp ! TRUE else ! This can only happen if e1=e2=e3=e4, ! in this case we stop doing what we were doing and calculate the contirbution from the ! gradient simplistically. grad E = e0-e4. doslin = 1.0_dp / ( e0 - e4 ) / 2.0_dp ! TRUE int = ( e_use - e4 ) / ( e0 - e4 ) / 2.0_dp ! SO YES, THIS DOES INTEGRATE FROM THE LINE ABOVE end if else write ( * , * ) e_use , e write ( * , * ) e0 , e1 , e2 , e3 , e4 stop 'Got here, but not supposed to!' end if ! ** Normalise doslin = doslin * alpha if ( shift ) then int = 1.0_dp - int * alpha ! TRUE else int = int * alpha ! TRUE end if return end function doslin","tags":"","loc":"proc/doslin.html"},{"title":"dos_utils_calculate – OptaDOS","text":"public  subroutine dos_utils_calculate(matrix_weights, weighted_dos) Uses od_parameters od_comms od_cell od_electronic od_io proc~~dos_utils_calculate~~UsesGraph proc~dos_utils_calculate dos_utils_calculate module~od_parameters od_parameters proc~dos_utils_calculate->module~od_parameters module~od_comms od_comms proc~dos_utils_calculate->module~od_comms module~od_io od_io proc~dos_utils_calculate->module~od_io module~od_cell od_cell proc~dos_utils_calculate->module~od_cell module~od_electronic od_electronic proc~dos_utils_calculate->module~od_electronic module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional, allocatable :: matrix_weights (:,:,:,:) real(kind=dp), intent(out), optional, allocatable :: weighted_dos (:,:,:) Calls proc~~dos_utils_calculate~~CallsGraph proc~dos_utils_calculate dos_utils_calculate proc~io_error io_error proc~dos_utils_calculate->proc~io_error proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge interface~comms_bcast comms_bcast proc~dos_utils_calculate->interface~comms_bcast proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate->proc~elec_read_band_gradient proc~io_time io_time proc~dos_utils_calculate->proc~io_time interface~comms_reduce comms_reduce proc~dos_utils_merge->interface~comms_reduce proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->proc~io_time interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_file_unit proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_calculate~~CalledByGraph proc~dos_utils_calculate dos_utils_calculate proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~dos_utils_calculate proc~dos_utils_set_efermi dos_utils_set_efermi proc~pdos_calculate->proc~dos_utils_set_efermi proc~core_calculate core_calculate proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi program~optados optados program~optados->proc~pdos_calculate program~optados->proc~core_calculate program~optados->proc~dos_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~jdos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_calculate Source Code subroutine dos_utils_calculate ( matrix_weights , weighted_dos ) !=============================================================================== ! Main routine in dos module, drives the calculation of density of states for ! both task : dos and also if it is required elsewhere. !------------------------------------------------------------------------------- ! Arguments: matrix_weigths (in) (opt) : LCAO or other weightings for DOS !            weighted_dos   (out)(opt) : Output DOS weigthed by matrix_weights !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw, E, dos_adaptive, dos_fixed, dos_linear ! intdos_adaptive, intdos_fixed, intdos_linear, efermi_fixed, efermi_adaptive ! efermi_linear, delta_bins, calc_weighted_dos !------------------------------------------------------------------------------- ! Modules Used: see below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: One of linear, adaptive or fixed must be .true. !------------------------------------------------------------------------------- ! Known Worries: (1) If more than one of linear, adaptive or fixed are set it ! uses the most complicated method. ! (2) It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_io , only : stdout , io_time , io_error use od_comms , only : on_root , my_node_id , comms_bcast use od_electronic , only : band_gradient , band_energy , efermi , efermi_castep , nspins , & & elec_read_band_gradient , unshifted_efermi use od_parameters , only : linear , adaptive , fixed , quad , & & dos_per_volume , iprint , set_efermi_zero , efermi_choice , iprint , photo use od_cell , only : cell_volume , num_kpoints_on_node implicit none !------------------------------------------------------------------------------- ! I N T E R N A L   V A R I A B L E S real ( kind = dp ) :: time0 , time1 real ( kind = dp ), intent ( in ), allocatable , optional :: matrix_weights (:, :, :, :) real ( kind = dp ), intent ( out ), allocatable , optional :: weighted_dos (:, :, :) ! bins.spins, orbitals !------------------------------------------------------------------------------- if (. not . ( linear . or . adaptive . or . fixed . or . quad )) call io_error ( \" DOS: No Broadening Set\" ) calc_weighted_dos = . false . if ( present ( matrix_weights )) calc_weighted_dos = . true . if ( calc_weighted_dos . eqv . . false .) then ! We are called just to provide dos. if ( allocated ( E )) then if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a78)' ) \"| Already calculated dos, so returning... & &                                   |\" return ! The dos has already been calculated previously so just return. end if end if if ( calc_weighted_dos ) then mw % norbitals = size ( matrix_weights , 1 ) mw % nbands = size ( matrix_weights , 2 ) mw % nkpoints = size ( matrix_weights , 3 ) mw % nspins = size ( matrix_weights , 4 ) end if if ( calc_weighted_dos ) then !       print*,'mw%nkpoints.ne.num_nkpoints_on_node(my_node_id))',mw%nkpoints,nunum_nkpoints_on_node(my_node_id) if ( mw % nspins . ne . nspins ) call io_error ( \"ERROR : DOS :  mw%nspins not equal to nspins.\" ) if ( mw % nkpoints . ne . num_kpoints_on_node ( my_node_id )) & call io_error ( \"ERROR : DOS : mw%nkpoints not equal to nkpoints.\" ) end if !------------------------------------------------------------------------------- ! R E A D   B A N D   G R A D I E N T S ! If we're using one of the more accurate roadening schemes we also need to read in the ! band gradients too if ( quad . or . linear . or . adaptive ) then if (. not . allocated ( band_gradient )) call elec_read_band_gradient end if !------------------------------------------------------------------------------- ! C A L C U L A T E   D O S ! Now everything is set up, we can perform the dos accumulation in parallel time0 = io_time () call setup_energy_scale if ( on_root . and . ( iprint > 1 )) write ( stdout , * ) if ( fixed ) then if ( calc_weighted_dos . and . (. not . adaptive ) . and . (. not . linear )) then call calculate_dos ( \"f\" , dos_fixed , intdos_fixed , matrix_weights = matrix_weights , weighted_dos = weighted_dos ) call dos_utils_merge ( dos_fixed , weighted_dos = weighted_dos ) else call calculate_dos ( \"f\" , dos_fixed , intdos_fixed ) call dos_utils_merge ( dos_fixed ) end if call dos_utils_merge ( intdos_fixed ) end if if ( adaptive ) then if ( calc_weighted_dos . and . (. not . linear )) then call calculate_dos ( \"a\" , dos_adaptive , intdos_adaptive , matrix_weights = matrix_weights , weighted_dos = weighted_dos ) call dos_utils_merge ( dos_adaptive , weighted_dos = weighted_dos ) else call calculate_dos ( \"a\" , dos_adaptive , intdos_adaptive ) call dos_utils_merge ( dos_adaptive ) end if call dos_utils_merge ( intdos_adaptive ) end if if ( linear ) then if ( calc_weighted_dos ) then call calculate_dos ( \"l\" , dos_linear , intdos_linear , matrix_weights = matrix_weights , weighted_dos = weighted_dos ) call dos_utils_merge ( dos_linear , weighted_dos = weighted_dos ) else call calculate_dos ( \"l\" , dos_linear , intdos_linear ) call dos_utils_merge ( dos_linear ) end if call dos_utils_merge ( intdos_linear ) end if if ( quad ) then call io_error ( \"quadratic broadening not implemented\" ) !if(quad)    call merge_dos(dos_quad) !if(quad)    call merge_dos(intdos_quad) end if !    if(.not.on_root) then !       if(allocated(E)) deallocate(E, stat=ierr) !       if (ierr/=0) call io_error (\"cannot deallocate  E\") !    endif time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) '+ Time to calculate DOS                                     ' , & & time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) end if !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! F E R M I   E N E R G Y   A N A L Y S I S if ( efermi_choice == \"optados\" ) then if ( on_root ) then time0 = io_time () write ( stdout , '(1x,a78)' ) '+----------------------------- Fermi Energy Analysis ------------------------+' !    write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)') \"|\",\" Fermi energy from CASTEP : \",efermi_castep,\" eV\",\"<- EfC |\" !    write(stdout,'(1x,a71)')  '+---------------------------------------------------------------------+' if ( fixed ) then write ( stdout , '(1x,a23,54x,a1)' ) \"| From Fixed broadening\" , \"|\" efermi_fixed = calc_efermi_from_intdos ( intdos_fixed ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy (Fixed broadening) : \" , & & efermi_fixed , \"eV\" , \"<- EfF |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( adaptive ) then write ( stdout , '(1x,a26,51x,a1)' ) \"| From Adaptive broadening\" , \"|\" efermi_adaptive = calc_efermi_from_intdos ( intdos_adaptive ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy (Adaptive broadening) : \" & , efermi_adaptive , \"eV\" , \"<- EfA |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( linear ) then write ( stdout , '(1x,a24,53x,a1)' ) \"| From Linear broadening\" , \"|\" efermi_linear = calc_efermi_from_intdos ( intdos_linear ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy (Linear broadening) : \" , & efermi_linear , \" eV\" , \"<- EfL |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if end if end if call comms_bcast ( efermi_fixed , 1 ) call comms_bcast ( efermi_linear , 1 ) call comms_bcast ( efermi_adaptive , 1 ) if ( on_root ) then if ( dos_per_volume ) then if ( fixed ) then dos_fixed = dos_fixed / cell_volume intdos_fixed = intdos_fixed / cell_volume end if if ( adaptive ) then dos_adaptive = dos_adaptive / cell_volume intdos_adaptive = intdos_adaptive / cell_volume end if if ( linear ) then dos_linear = dos_linear / cell_volume intdos_linear = intdos_linear / cell_volume end if if ( calc_weighted_dos ) then if ( photo ) then weighted_dos = weighted_dos else weighted_dos = weighted_dos / cell_volume end if end if ! if(quad) then !    dos_quad=dos_quad/cell_volume !    intdos_quad=intdos_quad/cell_volume ! endif end if end if end subroutine dos_utils_calculate","tags":"","loc":"proc/dos_utils_calculate.html"},{"title":"dos_utils_calculate_at_e – OptaDOS","text":"public  subroutine dos_utils_calculate_at_e(energy, dos_at_e, matrix_weights, weighted_dos_at_e) Uses od_parameters od_comms od_cell od_electronic od_io proc~~dos_utils_calculate_at_e~~UsesGraph proc~dos_utils_calculate_at_e dos_utils_calculate_at_e module~od_parameters od_parameters proc~dos_utils_calculate_at_e->module~od_parameters module~od_comms od_comms proc~dos_utils_calculate_at_e->module~od_comms module~od_io od_io proc~dos_utils_calculate_at_e->module~od_io module~od_cell od_cell proc~dos_utils_calculate_at_e->module~od_cell module~od_electronic od_electronic proc~dos_utils_calculate_at_e->module~od_electronic module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy real(kind=dp), intent(out) :: dos_at_e (1:3,nspins) real(kind=dp), intent(in), optional, allocatable :: matrix_weights (:,:,:,:) real(kind=dp), intent(out), optional :: weighted_dos_at_e (:,:) Calls proc~~dos_utils_calculate_at_e~~CallsGraph proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~io_error io_error proc~dos_utils_calculate_at_e->proc~io_error proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~io_time io_time proc~dos_utils_calculate_at_e->proc~io_time proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~io_time interface~comms_bcast comms_bcast proc~elec_read_band_gradient->interface~comms_bcast interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_file_unit proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_calculate_at_e~~CalledByGraph proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~optics_calculate optics_calculate proc~optics_calculate->proc~dos_utils_calculate_at_e proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi program~optados optados program~optados->proc~optics_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_calculate_at_e Source Code subroutine dos_utils_calculate_at_e ( energy , dos_at_e , matrix_weights , weighted_dos_at_e ) !=============================================================================== ! Main routine in dos module, drives the calculation of density of states for ! both task : dos and also if it is required elsewhere. !------------------------------------------------------------------------------- ! Arguments: matrix_weigths (in) (opt) : LCAO or other weightings for DOS !            weighted_dos   (out)(opt) : Output DOS weigthed by matrix_weights !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw, E, dos_adaptive, dos_fixed, dos_linear ! intdos_adaptive, intdos_fixed, intdos_linear, efermi_fixed, efermi_adaptive ! efermi_linear, delta_bins, calc_weighted_dos !------------------------------------------------------------------------------- ! Modules Used: see below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: One of linear, adaptive or fixed must be .true. !------------------------------------------------------------------------------- ! Known Worries: (1) If more than one of linear, adaptive or fixed are set it ! uses the most complicated method. ! (2) It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_io , only : stdout , io_time , io_error use od_comms , only : on_root , my_node_id use od_electronic , only : band_gradient , nspins , elec_read_band_gradient use od_parameters , only : linear , adaptive , fixed , quad , iprint use od_cell , only : nkpoints , num_kpoints_on_node implicit none !------------------------------------------------------------------------------- ! I N T E R N A L   V A R I A B L E S real ( kind = dp ) :: time0 , time1 real ( kind = dp ), intent ( in ), allocatable , optional :: matrix_weights (:, :, :, :) real ( kind = dp ), intent ( out ), optional :: weighted_dos_at_e (:, :) ! spins, orbitals RJN3Jun changed real ( kind = dp ), intent ( in ) :: energy real ( kind = dp ), intent ( out ) :: dos_at_e ( 1 : 3 , nspins ) ! fixed, adaptive, linear : spins !------------------------------------------------------------------------------- if (. not . ( linear . or . adaptive . or . fixed . or . quad )) call io_error ( \" DOS: No Broadening Set\" ) calc_weighted_dos = . false . if ( present ( matrix_weights )) calc_weighted_dos = . true . if ( calc_weighted_dos ) then mw % norbitals = size ( matrix_weights , 1 ) mw % nbands = size ( matrix_weights , 2 ) mw % nkpoints = size ( matrix_weights , 3 ) mw % nspins = size ( matrix_weights , 4 ) end if if ( calc_weighted_dos ) then if ( mw % nspins . ne . nspins ) call io_error ( \"ERROR : DOS :  mw%nspins not equal to nspins.\" ) if ( mw % nkpoints . ne . num_kpoints_on_node ( my_node_id )) & & call io_error ( \"ERROR : DOS : mw%nkpoints not equal to nkpoints.\" ) end if !------------------------------------------------------------------------------- ! R E A D   B A N D   G R A D I E N T S ! If we're using one of the more accurate roadening schemes we also need to read in the ! band gradients too if ( quad . or . linear . or . adaptive ) then if (. not . allocated ( band_gradient )) call elec_read_band_gradient end if !------------------------------------------------------------------------------- ! C A L C U L A T E   D O S ! Now everything is set up, we can perform the dos accumulation in parellel time0 = io_time () if ( fixed ) then if ( calc_weighted_dos . and . (. not . adaptive ) . and . (. not . linear )) then call calculate_dos_at_e ( \"f\" , energy , dos_at_e ( 1 , :), matrix_weights = matrix_weights , & & weighted_dos_at_e = weighted_dos_at_e ) call dos_utils_merge_at_e ( dos_at_e ( 1 , :), weighted_dos_at_e = weighted_dos_at_e ) else call calculate_dos_at_e ( \"f\" , energy , dos_at_e ( 1 , :)) call dos_utils_merge_at_e ( dos_at_e ( 1 , :)) end if end if if ( adaptive ) then if ( calc_weighted_dos . and . (. not . linear )) then call calculate_dos_at_e ( \"a\" , energy , dos_at_e ( 2 , :), matrix_weights = matrix_weights , & & weighted_dos_at_e = weighted_dos_at_e ) call dos_utils_merge_at_e ( dos_at_e ( 2 , :), weighted_dos_at_e = weighted_dos_at_e ) else call calculate_dos_at_e ( \"a\" , energy , dos_at_e ( 2 , :)) call dos_utils_merge_at_e ( dos_at_e ( 2 , :)) end if end if if ( linear ) then if ( calc_weighted_dos ) then call calculate_dos_at_e ( \"l\" , energy , dos_at_e ( 3 , :), matrix_weights = matrix_weights , & & weighted_dos_at_e = weighted_dos_at_e ) call dos_utils_merge_at_e ( dos_at_e ( 3 , :), weighted_dos_at_e = weighted_dos_at_e ) else call calculate_dos_at_e ( \"l\" , energy , dos_at_e ( 3 , :)) call dos_utils_merge_at_e ( dos_at_e ( 3 , :)) end if end if ! if(quad) then ! ! endif time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate DOS at certain energy                & &      ' , time1 - time0 , ' (sec) +' end if !------------------------------------------------------------------------------- end subroutine dos_utils_calculate_at_e","tags":"","loc":"proc/dos_utils_calculate_at_e.html"},{"title":"dos_utils_compute_band_energies – OptaDOS","text":"public  subroutine dos_utils_compute_band_energies() Uses od_parameters od_comms od_cell od_electronic od_io proc~~dos_utils_compute_band_energies~~UsesGraph proc~dos_utils_compute_band_energies dos_utils_compute_band_energies module~od_parameters od_parameters proc~dos_utils_compute_band_energies->module~od_parameters module~od_comms od_comms proc~dos_utils_compute_band_energies->module~od_comms module~od_io od_io proc~dos_utils_compute_band_energies->module~od_io module~od_cell od_cell proc~dos_utils_compute_band_energies->module~od_cell module~od_electronic od_electronic proc~dos_utils_compute_band_energies->module~od_electronic module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~dos_utils_compute_band_energies~~CallsGraph proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~io_time io_time proc~dos_utils_compute_band_energies->proc~io_time interface~comms_reduce comms_reduce proc~dos_utils_compute_band_energies->interface~comms_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_compute_band_energies~~CalledByGraph proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_compute_band_energies program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_compute_band_energies Source Code subroutine dos_utils_compute_band_energies !=============================================================================== ! High-level subroutine to compute band energies of the DOS calculated. ! Calculates using the band_energies directly and compares with the ! function calc_band_energies which does the low level computation on the DOS. !------------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------------- ! Parent Module Varables Used: E,dos_fixed,dos_adaptive,dos_linear !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: E must be set !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_parameters , only : adaptive , linear , fixed , iprint use od_electronic , only : electrons_per_state , efermi , nbands , nspins , band_energy use od_cell , only : kpoint_weight , num_kpoints_on_node use od_comms , only : comms_reduce , my_node_id , on_root use od_io , only : stdout , io_time implicit none real ( kind = dp ) :: eband real ( kind = dp ) :: time0 , time1 integer :: ik , is , ib time0 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '+--------------------------- Band Energy Analysis ---------------------------+' if ( fixed ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , & \" Band energy (Fixed broadening)  : \" , calc_band_energies ( dos_fixed ), \"eV\" , \"<- BEF |\" end if if ( adaptive ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , & \" Band energy (Adaptive broadening) : \" , calc_band_energies ( dos_adaptive ), \"eV\" , \"<- BEA |\" end if if ( linear ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , & \" Band energy (Linear broadening) : \" , calc_band_energies ( dos_linear ), \"eV\" , \"<- BEL |\" end if end if eband = 0.0_dp do ik = 1 , num_kpoints_on_node ( my_node_id ) do is = 1 , nspins do ib = 1 , nbands if ( band_energy ( ib , is , ik ) . le . efermi ) eband = eband + band_energy ( ib , is , ik ) * electrons_per_state & & * kpoint_weight ( ik ) end do end do end do call comms_reduce ( eband , 1 , 'SUM' ) if ( on_root ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , \" Band energy (From CASTEP) : \" , eband , \"eV\" , \"<- BEC |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' time1 = io_time () if ( iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Band Energies                        & &      ' , time1 - time0 , ' (sec) +' end if write ( stdout , '(1x,a78)' ) end if end subroutine dos_utils_compute_band_energies","tags":"","loc":"proc/dos_utils_compute_band_energies.html"},{"title":"dos_utils_compute_bandgap – OptaDOS","text":"public  subroutine dos_utils_compute_bandgap() Uses od_parameters od_comms od_cell od_electronic od_io proc~~dos_utils_compute_bandgap~~UsesGraph proc~dos_utils_compute_bandgap dos_utils_compute_bandgap module~od_parameters od_parameters proc~dos_utils_compute_bandgap->module~od_parameters module~od_comms od_comms proc~dos_utils_compute_bandgap->module~od_comms module~od_io od_io proc~dos_utils_compute_bandgap->module~od_io module~od_cell od_cell proc~dos_utils_compute_bandgap->module~od_cell module~od_electronic od_electronic proc~dos_utils_compute_bandgap->module~od_electronic module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~dos_utils_compute_bandgap~~CallsGraph proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~io_time io_time proc~dos_utils_compute_bandgap->proc~io_time interface~comms_recv comms_recv proc~dos_utils_compute_bandgap->interface~comms_recv interface~comms_send comms_send proc~dos_utils_compute_bandgap->interface~comms_send proc~io_error io_error proc~dos_utils_compute_bandgap->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_compute_bandgap~~CalledByGraph proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_compute_bandgap program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_compute_bandgap Source Code subroutine dos_utils_compute_bandgap !=============================================================================== ! Modified from LINDOS -- AJM 3rd June 2011 ! Rewritten 31/1/12 AJM use od_electronic , only : nspins , nbands , efermi , band_energy , num_electrons , & & all_kpoints use od_cell , only : nkpoints , num_kpoints_on_node use od_io , only : stdout , io_time , io_error use od_parameters , only : iprint use od_comms , only : comms_send , comms_recv , on_root , my_node_id , & & num_nodes , root_id implicit none ! Local array containing vbm and cbm at each kpoint and spin. real ( dp ), allocatable :: bandgap (:, :, :) !nbands=1,2,nspins,nkpoints ! Same as bandgap only merged over all nodes to the root-node real ( dp ), allocatable :: global_bandgap (:, :, :) ! Avergae bandgap for up and down spins (summed over all kpoints and divided ! by num_kpoints) real ( dp ), allocatable :: average_bandgap (:) ! Optical bandgap. Smallest vertical distance between two kpoints real ( dp ), allocatable :: optical_bandgap (:) ! The number of kpoints that have the vbm and cbm integer , allocatable :: thermal_vbm_multiplicity (:), thermal_cbm_multiplicity (:) ! The number of kpoints that have the optical gap integer , allocatable :: optical_multiplicity (:) ! Timing variables real ( dp ) :: time0 , time1 ! Loop counters integer :: ik , is , ib , ierr , inode , kpoints_before_this_node ! Temporary variables real ( dp ), allocatable :: kpoint_bandgap (:) real ( dp ) :: thermal_cbm , thermal_vbm , thermal_bandgap , weighted_average integer :: thermal_vbm_k , thermal_cbm_k logical :: thermal_multiplicity time0 = io_time () ! Preamble if ( on_root ) then if ( iprint > 2 ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) \"| Finding an estimate of the maximum bandgap...                              |\" end if write ( stdout , '(1x,a78)' ) '+----------------------------- Bandgap Analysis -----------------------------+' end if if (. not . allocated ( all_kpoints )) call io_error ( 'Error all_kpoints not allocated in dos_utils: compute_bandgap' ) allocate ( bandgap ( 1 : 2 , 1 : nspins , 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating bandgap in dos_utils: compute_bandgap' ) bandgap = - 20 0.00_dp ! Write the VBM and CBM into a slice of an band_energy array ! It is easier to merge these slices onto the root node rather than try ! the horrendous book-keeping of which kpoint on which node has which ! gap do is = 1 , nspins do ik = 1 , num_kpoints_on_node ( my_node_id ) bands_loop : do ib = 1 , nbands ! If this eignevalue is greater than efermi, then this is the CBM ! and the one below it is the VBM if ( band_energy ( ib , is , ik ) . gt . efermi ) then bandgap ( 1 , is , ik ) = band_energy ( ib - 1 , is , ik ) bandgap ( 2 , is , ik ) = band_energy ( ib , is , ik ) exit bands_loop end if end do bands_loop end do !ik end do !is ! Create a global kpoint array,and set it to something silly in case we need to debug whether ! data was actually written to it. if ( on_root ) then allocate ( global_bandgap ( 1 : 2 , 1 : nspins , 1 : nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating global_bandgap in dos_utils: compute_bandgap' ) global_bandgap = - 10 0.00_dp end if ! Pass all the slices around Efermi to the head node, making sure whe get the global ! kpoint number. *And* crucially the same kpoint numbers as in the bands file. ! Otherwise the kpoint numbers of the VBM and CBM change as different numbers of nodes ! are used. kpoints_before_this_node = 0 do inode = 1 , ( num_nodes - 1 ) if ( my_node_id == inode ) call comms_send ( bandgap ( 1 , 1 , 1 ), 2 * is * num_kpoints_on_node ( inode ), root_id ) if ( on_root ) call comms_recv ( global_bandgap ( 1 , 1 , & & kpoints_before_this_node + 1 ), 2 * is * num_kpoints_on_node ( inode ), inode ) kpoints_before_this_node = kpoints_before_this_node + num_kpoints_on_node ( inode ) end do ! Copy the root node's slice to the global array. if ( on_root ) & & global_bandgap ( 1 : 2 , 1 : nspins , kpoints_before_this_node & & + 1 : kpoints_before_this_node + num_kpoints_on_node ( root_id )) & & = bandgap ( 1 : 2 , 1 : nspins , 1 : num_kpoints_on_node ( root_id )) ! We now have an array with the VBM and CBM of all kpoints, so we can deallocate the local ones. deallocate ( bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating bandgap in dos_utils: compute_bandgap' ) ! We've freed up a bit of memory, so now we can allocate all of the output data arrays on the ! headnode if ( on_root ) then allocate ( average_bandgap ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating average_bandgap in dos_utils: compute_bandgap' ) allocate ( optical_bandgap ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating optical_bandgap in dos_utils: compute_bandgap' ) allocate ( kpoint_bandgap ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating kpoint_bandgap in dos_utils: compute_bandgap' ) allocate ( thermal_vbm_multiplicity ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating thermal_vbm_multiplicity in dos_utils: compute_bandgap' ) allocate ( thermal_cbm_multiplicity ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocatingthermal_cbm_multiplicity in dos_utils: compute_bandgap' ) allocate ( optical_multiplicity ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating optical_multiplicity in dos_utils: compute_bandgap' ) end if ! Now lets look for the various bandgaps by cycling through the global_bandgap array if ( on_root ) then ! COMMENTED OUT: This writes out the complete global_bandgap array to fort.7 if you'd like ! to take a look !  do ik=1,nkpoints !     do is=1,nspins !        write(7,*) ik,is, global_bandgap(1,is,ik),global_bandgap(2,is,ik) !     enddo ! enddo average_bandgap = 0.0_dp thermal_cbm = huge ( 1.0_dp ) thermal_vbm = - huge ( 1.0_dp ) thermal_vbm_multiplicity = 1 thermal_cbm_multiplicity = 1 thermal_vbm_k = - 1 thermal_cbm_k = - 1 optical_multiplicity = 1 optical_bandgap = huge ( 1.0_dp ) do is = 1 , nspins do ik = 1 , nkpoints ! Look for the thermal vbm. This is done for both spin components although ! ws care about the individual spin multiplicity if ( global_bandgap ( 1 , is , ik ) . ge . thermal_vbm ) then if ( abs ( global_bandgap ( 1 , is , ik ) - thermal_vbm ) < epsilon ( thermal_vbm )) then ! If this is the same value of vbm as we had before, then ! we have multiple maxima, and we need to know that we might not ! get the direct/indirect gap right thermal_vbm_multiplicity ( is ) = thermal_vbm_multiplicity ( is ) + 1 else ! If we haven't had this high a vbm value before, then we take it ! and set the multiplicty back to zero thermal_vbm = global_bandgap ( 1 , is , ik ) thermal_vbm_multiplicity ( is ) = 1 thermal_vbm_k = ik end if end if ! We search for the CBM in the same way as the VBM above. if ( global_bandgap ( 2 , is , ik ) . le . thermal_cbm ) then if ( abs ( global_bandgap ( 2 , is , ik ) - thermal_cbm ) < epsilon ( thermal_cbm )) then thermal_cbm_multiplicity ( is ) = thermal_cbm_multiplicity ( is ) + 1 else thermal_cbm = global_bandgap ( 2 , is , ik ) thermal_cbm_multiplicity ( is ) = 1 thermal_cbm_k = ik end if end if ! Work out the bandgap for this particular kpoint and spin kpoint_bandgap ( is ) = global_bandgap ( 2 , is , ik ) - global_bandgap ( 1 , is , ik ) ! If this is smaller than the optical gap. Then this is our next iteration ! of the optical gap. Worry about mutiplicties in the same way. Although this ! is just for into, since we can't have direct/indirect optical gaps. if ( kpoint_bandgap ( is ) . le . optical_bandgap ( is )) then if ( abs ( kpoint_bandgap ( is ) - optical_bandgap ( is )) < epsilon ( optical_bandgap ( is ))) then optical_multiplicity ( is ) = optical_multiplicity ( is ) + 1 else optical_bandgap ( is ) = kpoint_bandgap ( is ) optical_multiplicity ( is ) = 1 end if end if average_bandgap ( is ) = average_bandgap ( is ) + ( global_bandgap ( 2 , is , ik ) - global_bandgap ( 1 , is , ik )) end do ! nkpoints end do ! nspins ! We now have enough info to calculate the average bandgap and the thermal bandgap average_bandgap = average_bandgap / nkpoints vbm_energy = thermal_vbm cbm_energy = thermal_cbm thermal_bandgap = thermal_cbm - thermal_vbm ! Don't want this array hanging around a moment longer than we need it. deallocate ( global_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating global_bandgap in dos_utils: compute_bandgap' ) ! If there is more than one VBM and CBM let's flag it up. ! We wouldn't like to comment on the nature of the gap at this point ! Unless we did some more work. (Which should have been done before we deallocated ! global_bandgap!) thermal_multiplicity = . false . do is = 1 , nspins if (( thermal_vbm_multiplicity ( is ) . ne . 1 ) . or . ( thermal_cbm_multiplicity ( is ) . ne . 1 )) thermal_multiplicity = . true . end do ! Report the thermal gap multiplicity write ( stdout , '(1x,1a,a50, 19x, a8)' ) \"|\" , \"Number of kpoints at       VBM       CBM\" , \"       |\" do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,1x,i5,5x,i5,20x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , & & thermal_vbm_multiplicity ( is ), thermal_cbm_multiplicity ( is ), \"       |\" end do ! Write out the thermal gap info write ( stdout , '(1x,a1,a32,f15.10,1x,a3,18x,a8)' ) \"|\" , \"Thermal Bandgap :\" , thermal_bandgap , \"eV\" , \"<- TBg |\" if (. not . thermal_multiplicity ) then if ( thermal_vbm_k == thermal_cbm_k ) then write ( stdout , '(1x,a1,a32,1x,f10.5,1x,f10.5,1x,f10.5,4x,a8)' ) \"|\" , \"At kpoint :\" , & all_kpoints ( 1 : 3 , thermal_vbm_k ), \"       |\" write ( stdout , '(1x,a78)' ) '|             ==> Direct Gap                                                  |' else write ( stdout , '(1x,a1,a32,1x,f10.5,1x,f10.5,1x,f10.5,4x,a8)' ) \"|\" , \"Between VBM kpoint :\" , & all_kpoints ( 1 : 3 , thermal_vbm_k ), \"       |\" write ( stdout , '(1x,a1,a32,1x,f10.5,1x,f10.5,1x,f10.5,4x,a8)' ) \"|\" , \"and CBM kpoint:\" , & all_kpoints ( 1 : 3 , thermal_cbm_k ), \"       |\" write ( stdout , '(1x,a78)' ) '|             ==> Indirect Gap                                               |' end if else ! thermal_mutiplicty=.true. write ( stdout , '(1x,a78)' ) '|          ==> Multiple Band Minima and Maxima -- Gap unknown                |' end if ! We allocated this in elec_read_band_energy but kept it if compute_band_gap=T deallocate ( all_kpoints , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoints in read_band_energy' ) ! Write out the Optical gap indo write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a1,a45,a32)' ) \"|\" , \"Optical Bandgap  \" , \"|\" do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,1x,f15.10,1x,a3,16x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , optical_bandgap ( is ),& & \"eV\" , \"<- OBg |\" end do write ( stdout , '(1x,1a,a50, 19x, a8)' ) \"|\" , \"Number of kpoints with this gap         \" , \"       |\" ! The multiplicity info here is just for reference. do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,6x,i5,25x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , optical_multiplicity ( is ), \"       |\" end do ! Write out the average bandgap write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a1,a45,a32)' ) \"|\" , \"Average Bandgap  \" , \"|\" do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,1x,f15.10,1x,a3,16x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , & & average_bandgap ( is ), \"eV\" , \"<- ABg |\" end do ! If we have more then one spin, then we need some way to combine the up and down spin bandgaps ! At Richard Needs' suggestion we use the weighted sum. if ( nspins > 1 ) then weighted_average = ( average_bandgap ( 1 ) * num_electrons ( 1 ) + average_bandgap ( 2 ) * num_electrons ( 2 )) & & / ( num_electrons ( 1 ) + num_electrons ( 2 )) write ( stdout , '(1x,a1,a33,1x,f15.10,1x,a3,16x,a8)' ) \"|\" , \" Weighted Average : \" , weighted_average , \"eV\" , \"<- wAB |\" end if end if ! Let not have these other arrays hanging around a moment longer than we need them if ( on_root ) then deallocate ( average_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating average_bandgap in dos_utils: compute_bandgap' ) deallocate ( optical_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating optical_bandgap in dos_utils: compute_bandgap' ) deallocate ( kpoint_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating kpoint_bandgap in dos_utils: compute_bandgap' ) deallocate ( thermal_vbm_multiplicity , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating thermal_vbm_multiplicity in dos_utils: compute_bandgap' ) deallocate ( thermal_cbm_multiplicity , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocatingthermal_cbm_multiplicity in dos_utils: compute_bandgap' ) deallocate ( optical_multiplicity , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating optical_multiplicity in dos_utils: compute_bandgap' ) end if if ( on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to calculate Bandgap ' , time1 - time0 , ' (sec)' end subroutine dos_utils_compute_bandgap","tags":"","loc":"proc/dos_utils_compute_bandgap.html"},{"title":"dos_utils_compute_dos_at_efermi – OptaDOS","text":"public  subroutine dos_utils_compute_dos_at_efermi() Uses od_comms od_electronic od_parameters od_io proc~~dos_utils_compute_dos_at_efermi~~UsesGraph proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi module~od_comms od_comms proc~dos_utils_compute_dos_at_efermi->module~od_comms module~od_parameters od_parameters proc~dos_utils_compute_dos_at_efermi->module~od_parameters module~od_io od_io proc~dos_utils_compute_dos_at_efermi->module~od_io module~od_electronic od_electronic proc~dos_utils_compute_dos_at_efermi->module~od_electronic module~od_constants od_constants module~od_comms->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_io->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~dos_utils_compute_dos_at_efermi~~CallsGraph proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~io_time io_time proc~dos_utils_compute_dos_at_efermi->proc~io_time proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e interface~comms_bcast comms_bcast proc~dos_utils_compute_dos_at_efermi->interface~comms_bcast proc~dos_utils_calculate_at_e->proc~io_time proc~io_error io_error proc~dos_utils_calculate_at_e->proc~io_error proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->proc~io_error proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~algor_dist_array->proc~io_error proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_compute_dos_at_efermi~~CalledByGraph proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_compute_dos_at_efermi Source Code subroutine dos_utils_compute_dos_at_efermi !=============================================================================== use od_io , only : stdout , io_time use od_comms , only : on_root , comms_bcast use od_electronic , only : efermi , nspins use od_parameters , only : fixed , linear , adaptive , iprint , compute_band_gap implicit none real ( dp ) :: time0 , time1 real ( dp ) :: dos_at_efermi ( 1 : 3 , 1 : nspins ) ! Fix,Adapt,Linear integer :: is time0 = io_time () call dos_utils_calculate_at_e ( efermi , dos_at_e = dos_at_efermi ) if (( iprint > 1 ) . and . on_root ) then write ( stdout , * ) end if if ( on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------- DOS at Fermi Energy Analysis -----------------------+' write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy used : \" , efermi , \"eV\" , \"       |\" if ( fixed ) then write ( stdout , '(1x,a78)' ) \"| From Fixed broadening                                                      |\" do is = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a25,f8.4,a9,6x,a8)' ) \"|\" , \"Spin Component : \" , is ,& & \"  DOS at Fermi Energy : \" , dos_at_efermi ( 1 , is ), \" eln/cell\" , \"<- DEF |\" end do write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( adaptive ) then write ( stdout , '(1x,a78)' ) \"| From Adaptive broadening                                                   |\" do is = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a25,f8.4,a9,6x,a8)' ) \"|\" , \"Spin Component : \" , is ,& & \"  DOS at Fermi Energy : \" , dos_at_efermi ( 2 , is ), \" eln/cell\" , \"<- DEA |\" end do write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( linear ) then write ( stdout , '(1x,a78)' ) \"| From Linear broadening                                                     |\" do is = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a25,f8.4,a9,6x,a8)' ) \"|\" , \"Spin Component : \" , is ,& & \"  DOS at Fermi Energy : \" , dos_at_efermi ( 3 , is ), \" eln/cell\" , \"<- DEL |\" end do write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if time1 = io_time () if ( iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate DOS at Fermi Energy                  & &      ' , time1 - time0 , ' (sec) +' end if write ( stdout , '(1x,a78)' ) !------------------------------------------------------------------------------- end if call comms_bcast ( compute_band_gap , 1 ) end subroutine dos_utils_compute_dos_at_efermi","tags":"","loc":"proc/dos_utils_compute_dos_at_efermi.html"},{"title":"dos_utils_deallocate – OptaDOS","text":"public  subroutine dos_utils_deallocate() Uses od_io proc~~dos_utils_deallocate~~UsesGraph proc~dos_utils_deallocate dos_utils_deallocate module~od_io od_io proc~dos_utils_deallocate->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~dos_utils_deallocate~~CallsGraph proc~dos_utils_deallocate dos_utils_deallocate proc~io_error io_error proc~dos_utils_deallocate->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_deallocate Source Code subroutine dos_utils_deallocate use od_io , only : io_error implicit none integer :: ierr if ( allocated ( dos_adaptive )) then deallocate ( dos_adaptive , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate dos_adaptive' ) end if if ( allocated ( dos_fixed )) then deallocate ( dos_fixed , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate dos_fixed' ) end if if ( allocated ( dos_linear )) then deallocate ( dos_linear , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate dos_linear' ) end if if ( allocated ( intdos_adaptive )) then deallocate ( intdos_adaptive , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate intdos_adaptive' ) end if if ( allocated ( intdos_fixed )) then deallocate ( intdos_fixed , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate intdos_fixed' ) end if if ( allocated ( intdos_linear )) then deallocate ( intdos_linear , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate intdos_fixed' ) end if if ( allocated ( E )) then deallocate ( E , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate E' ) end if end subroutine dos_utils_deallocate","tags":"","loc":"proc/dos_utils_deallocate.html"},{"title":"dos_utils_merge – OptaDOS","text":"public  subroutine dos_utils_merge(dos, weighted_dos) Uses od_comms od_electronic od_parameters proc~~dos_utils_merge~~UsesGraph proc~dos_utils_merge dos_utils_merge module~od_comms od_comms proc~dos_utils_merge->module~od_comms module~od_parameters od_parameters proc~dos_utils_merge->module~od_parameters module~od_electronic od_electronic proc~dos_utils_merge->module~od_electronic module~od_constants od_constants module~od_comms->module~od_constants module~od_parameters->module~od_constants module~od_io od_io module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: dos (:,:) real(kind=dp), intent(inout), optional, allocatable :: weighted_dos (:,:,:) Calls proc~~dos_utils_merge~~CallsGraph proc~dos_utils_merge dos_utils_merge interface~comms_reduce comms_reduce proc~dos_utils_merge->interface~comms_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_merge~~CalledByGraph proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~dos_utils_merge proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~dos_utils_calculate proc~dos_utils_set_efermi dos_utils_set_efermi proc~pdos_calculate->proc~dos_utils_set_efermi proc~core_calculate core_calculate proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi program~optados optados program~optados->proc~pdos_calculate program~optados->proc~core_calculate program~optados->proc~dos_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~jdos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_merge Source Code subroutine dos_utils_merge ( dos , weighted_dos ) !=============================================================================== ! The DOS was calculated accross nodes. Now give them all back to root ! and free up the memeory on the slaves !------------------------------------------------------------------------------- ! Arguments: dos          (in - slaves) (inout -  root)       : The DOS !            weighted_dos (in - slaves) (inout -  root) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_comms , only : comms_reduce use od_electronic , only : nspins use od_parameters , only : dos_nbins implicit none real ( kind = dp ), intent ( inout ), allocatable , optional :: weighted_dos (:, :, :) ! bins.spins, orbitals real ( kind = dp ), allocatable , intent ( inout ) :: dos (:, :) call comms_reduce ( dos ( 1 , 1 ), nspins * dos_nbins , \"SUM\" ) if ( present ( weighted_dos )) call comms_reduce ( weighted_dos ( 1 , 1 , 1 ), mw % nspins * dos_nbins * mw % norbitals , \"SUM\" ) !    if(.not.on_root) then !       if(allocated(dos)) deallocate(dos,stat=ierr) !       if (ierr/=0) call io_error (\" ERROR : dos : merge_dos : cannot deallocate dos\") !       if(present(weighted_dos))  then !          if(allocated(weighted_dos)) deallocate(weighted_dos,stat=ierr) !          if (ierr/=0) call io_error (\" ERROR : dos : merge_dos : cannot deallocate weighted_dos\") !       end if !    endif end subroutine dos_utils_merge","tags":"","loc":"proc/dos_utils_merge.html"},{"title":"dos_utils_set_efermi – OptaDOS","text":"public  subroutine dos_utils_set_efermi() Uses od_parameters od_comms od_cell od_electronic od_io proc~~dos_utils_set_efermi~~UsesGraph proc~dos_utils_set_efermi dos_utils_set_efermi module~od_parameters od_parameters proc~dos_utils_set_efermi->module~od_parameters module~od_comms od_comms proc~dos_utils_set_efermi->module~od_comms module~od_io od_io proc~dos_utils_set_efermi->module~od_io module~od_cell od_cell proc~dos_utils_set_efermi->module~od_cell module~od_electronic od_electronic proc~dos_utils_set_efermi->module~od_electronic module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~dos_utils_set_efermi~~CallsGraph proc~dos_utils_set_efermi dos_utils_set_efermi interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce interface~comms_bcast comms_bcast proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~io_error io_error proc~dos_utils_set_efermi->proc~io_error proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_calculate->proc~io_error proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate->proc~elec_read_band_gradient proc~io_time io_time proc~dos_utils_calculate->proc~io_time proc~dos_utils_merge->interface~comms_reduce proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~algor_dist_array->proc~io_error proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_utils_set_efermi~~CalledByGraph proc~dos_utils_set_efermi dos_utils_set_efermi proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~core_calculate core_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~optics_calculate optics_calculate proc~optics_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~pdos_calculate program~optados->proc~core_calculate program~optados->proc~dos_calculate program~optados->proc~optics_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_utils_set_efermi Source Code subroutine dos_utils_set_efermi !=============================================================================== use od_parameters , only : efermi_choice , efermi_user , fixed ,& & linear , adaptive , iprint use od_electronic , only : efermi_castep , num_electrons , nspins , efermi , & & electrons_per_state , band_energy , nbands , efermi_set use od_io , only : io_error , stdout use od_comms , only : on_root , my_node_id , comms_reduce , comms_bcast use od_cell , only : num_kpoints_on_node implicit none integer :: is , ik , top_occ_band real ( kind = dp ) :: vbm , cbm if ( on_root ) then write ( stdout , '(1x,a78)' ) '+--------------------------- Setting Fermi Energy  --------------------------+' end if !    if(on_root) write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)') \"|\",& !         &\" Fermi energy from file : \",efermi_castep,\" eV\",\"| <- EfC\" select case ( efermi_choice ) case ( \"file\" ) if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Set fermi energy from file : \" , efermi_castep , \" eV\" , \"  <- EfC\" efermi = efermi_castep case ( \"user\" ) if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Fermi energy from user : \" , efermi_user , \" eV\" , \"  <- EfU\" efermi = efermi_user case ( \"insulator\" ) ! Same fermi level for up and down spins. Different number ! of electrons for up and down spins. ! For an insulator. Hence same number of electrons at each kpoint. ! band_energy(ib,is,ik) vbm = - huge ( vbm ) cbm = huge ( cbm ) if ( on_root . and . iprint > 3 ) write ( stdout , * ) vbm , \" =vbm : cbm= \" , cbm ! Go between global VBM and CBM band_energy(ib,is,ik) do ik = 1 , num_kpoints_on_node ( my_node_id ) do is = 1 , nspins ! Which is the band below the fermi energy at this spin and kpoint top_occ_band = ceiling ( num_electrons ( is ) / electrons_per_state ) if ( band_energy ( top_occ_band , is , ik ) > vbm ) & & vbm = band_energy ( top_occ_band , is , ik ) ! If the band_energy array is big enough then there will be occupied states. if ( num_electrons ( is ) + 1 . le . nbands ) then if ( band_energy ( top_occ_band + 1 , is , ik ) < cbm ) & & cbm = band_energy ( top_occ_band + 1 , is , ik ) end if end do if ( on_root . and . iprint > 3 ) write ( stdout , * ) vbm , \" =vbm : cbm= \" , cbm end do ! Find the globals call comms_reduce ( cbm , 1 , 'MIN' ) call comms_bcast ( cbm , 1 ) call comms_reduce ( vbm , 1 , 'MAX' ) call comms_bcast ( vbm , 1 ) ! If we have a CBM then set the efermi halfway between VBM and CBM ! If we don't have a CBM then set it 0.5 eV above VBM and hope for ! the best. if ( cbm == huge ( cbm )) then efermi = vbm + 0.5_dp else efermi = vbm + 0.5_dp * ( cbm - vbm ) end if if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Fermi energy assuming insulator : \" , efermi , \" eV\" , \"  <- EfI\" case ( \"optados\" ) ! So in the case of compare_jdos we pick efermi_adaptive. call dos_utils_calculate ! This will return if we already have. if ( fixed ) efermi = efermi_fixed if ( linear ) efermi = efermi_linear if ( adaptive ) efermi = efermi_adaptive if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Fermi energy from DOS : \" , efermi , \" eV\" , \"<- EfD |\" case default call io_error ( 'Error in dos_utils_set_efermi: unknown efermi choice this is a bug' ) end select if ( on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a78)' ) end if efermi_set = . true . end subroutine dos_utils_set_efermi","tags":"","loc":"proc/dos_utils_set_efermi.html"},{"title":"doslin_sub_cell_corners – OptaDOS","text":"public  subroutine doslin_sub_cell_corners(grad, step, energy, EigenV) Uses od_cell od_algorithms proc~~doslin_sub_cell_corners~~UsesGraph proc~doslin_sub_cell_corners doslin_sub_cell_corners module~od_cell od_cell proc~doslin_sub_cell_corners->module~od_cell module~od_algorithms od_algorithms proc~doslin_sub_cell_corners->module~od_algorithms module~od_io od_io module~od_cell->module~od_io module~od_constants od_constants module~od_cell->module~od_constants module~od_algorithms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: grad (1:3) real(kind=dp), intent(in) :: step (1:3) real(kind=dp), intent(in) :: energy real(kind=dp), intent(out) :: EigenV (0:4) Calls proc~~doslin_sub_cell_corners~~CallsGraph proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~heap_sort heap_sort proc~doslin_sub_cell_corners->proc~heap_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~doslin_sub_cell_corners~~CalledByGraph proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~calculate_jdos calculate_jdos proc~calculate_jdos->proc~doslin_sub_cell_corners proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code doslin_sub_cell_corners Source Code subroutine doslin_sub_cell_corners ( grad , step , energy , EigenV ) !=============================================================================== ! A helper subroutine for calculated_dos, which is used for the linear ! broadening method. This routine extrapolates the energies at the corner of the ! sub cells by using the gradient at the centre of the cell !------------------------------------------------------------------------------- ! Arguments: grad   (in) : The Gradient of the band at the centre of a sub-cell !            step   (in) : The directions to the edge of the sub_cell !            energy (in) : The Band energy at the centre of the sub cell !            EigenV (out): The Energies at the corners of the sub-cell !------------------------------------------------------------------------------- ! Parent Module Varables Used: None !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 Heavliy modified from LinDOS !=============================================================================== use od_algorithms , only : heap_sort use od_cell , only : recip_lattice implicit none real ( kind = dp ), intent ( in ) :: grad ( 1 : 3 ), step ( 1 : 3 ) real ( kind = dp ), intent ( out ) :: EigenV ( 0 : 4 ) real ( kind = dp ), intent ( in ) :: energy integer :: m , n , o , nn , i real ( kind = dp ) :: stepp ( 1 : 3 ), DE ( 1 : 8 ) nn = 0 do m = - 1 , 1 , 2 do n = - 1 , 1 , 2 do o = - 1 , 1 , 2 nn = nn + 1 stepp ( 1 ) = step ( 1 ) * m stepp ( 2 ) = step ( 2 ) * n stepp ( 3 ) = step ( 3 ) * o ! Reciprocal lattice in inverse Ang stepp = matmul ( recip_lattice , stepp ) ! DE in eV DE ( nn ) = dot_product ( grad , stepp ) end do end do end do ! Yes this is a hack to the sorter to work the right way around. DE = - DE call heap_sort ( 8 , DE ) DE = - DE ! WHY ARE WE STORING ALL THIS? !EV(0,ib,is,ik) = band_energy(ib,is,ik) !EV(1,ib,is,ik) = EV(0,ib,is,ik) + DE(5) !EV(2,ib,is,ik) = EV(0,ib,is,ik) + DE(6) !EV(3,ib,is,ik) = EV(0,ib,is,ik) + DE(7) !EV(4,ib,is,ik) = EV(0,ib,is,ik) + DE(8) EigenV ( 0 ) = Energy do i = 1 , 4 EigenV ( i ) = EigenV ( 0 ) + DE ( 4 + i ) end do end subroutine doslin_sub_cell_corners","tags":"","loc":"proc/doslin_sub_cell_corners.html"},{"title":"param_dealloc – OptaDOS","text":"public  subroutine param_dealloc() Arguments None Called by proc~~param_dealloc~~CalledByGraph proc~param_dealloc param_dealloc program~optados optados program~optados->proc~param_dealloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code param_dealloc Source Code subroutine param_dealloc !==================================================================! !                                                                  ! ! release memory from allocated parameters                         ! !                                                                  ! !=================================================================== implicit none !    if ( allocated ( ndimwin ) ) then !       ieallocate (  ndimwin, stat=ierr  ) !       if (ierr/=0) call io_error('Error in deallocating ndimwin in param_dealloc') !    end if return end subroutine param_dealloc","tags":"","loc":"proc/param_dealloc.html"},{"title":"param_dist – OptaDOS","text":"public  subroutine param_dist() Uses od_comms od_io proc~~param_dist~~UsesGraph proc~param_dist param_dist module~od_comms od_comms proc~param_dist->module~od_comms module~od_io od_io proc~param_dist->module~od_io module~od_constants od_constants module~od_comms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~param_dist~~CallsGraph proc~param_dist param_dist interface~comms_bcast comms_bcast proc~param_dist->interface~comms_bcast proc~io_error io_error proc~param_dist->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~param_dist~~CalledByGraph proc~param_dist param_dist program~optados optados program~optados->proc~param_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code param_dist Source Code subroutine param_dist !----------------------------------------------------- ! Send the parameters from the root node to all others !----------------------------------------------------- use od_comms , only : comms_bcast , on_root use od_io , only : io_error implicit none integer :: ierr call comms_bcast ( output_format , len ( output_format )) call comms_bcast ( devel_flag , len ( devel_flag )) call comms_bcast ( iprint , 1 ) call comms_bcast ( energy_unit , len ( energy_unit )) call comms_bcast ( length_unit , len ( length_unit )) call comms_bcast ( dos , 1 ) call comms_bcast ( pdos , 1 ) call comms_bcast ( jdos , 1 ) call comms_bcast ( optics , 1 ) call comms_bcast ( photo , 1 ) call comms_bcast ( photo_photon_sweep , 1 ) call comms_bcast ( core , 1 ) call comms_bcast ( compare_dos , 1 ) call comms_bcast ( compare_jdos , 1 ) call comms_bcast ( fixed , 1 ) call comms_bcast ( adaptive , 1 ) call comms_bcast ( linear , 1 ) call comms_bcast ( quad , 1 ) call comms_bcast ( dos_nbins , 1 ) call comms_bcast ( compute_band_energy , 1 ) call comms_bcast ( compute_band_gap , 1 ) call comms_bcast ( adaptive_smearing , 1 ) call comms_bcast ( fixed_smearing , 1 ) call comms_bcast ( linear_smearing , 1 ) call comms_bcast ( hybrid_linear , 1 ) call comms_bcast ( hybrid_linear_grad_tol , 1 ) call comms_bcast ( dos_per_volume , 1 ) call comms_bcast ( efermi_user , 1 ) call comms_bcast ( efermi_choice , len ( efermi_choice )) call comms_bcast ( finite_bin_correction , 1 ) call comms_bcast ( numerical_intdos , 1 ) call comms_bcast ( jdos_max_energy , 1 ) call comms_bcast ( jdos_spacing , 1 ) call comms_bcast ( scissor_op , 1 ) call comms_bcast ( optics_geom , len ( optics_geom )) call comms_bcast ( optics_qdir ( 1 ), 3 ) call comms_bcast ( optics_intraband , 1 ) call comms_bcast ( optics_drude_broadening , 1 ) call comms_bcast ( core_chemical_shift , 1 ) call comms_bcast ( core_geom , len ( core_geom )) call comms_bcast ( core_type , len ( core_type )) call comms_bcast ( core_qdir ( 1 ), 3 ) call comms_bcast ( core_LAI_broadening , 1 ) call comms_bcast ( LAI_gaussian_width , 1 ) call comms_bcast ( LAI_gaussian , 1 ) call comms_bcast ( LAI_lorentzian_width , 1 ) call comms_bcast ( LAI_lorentzian_scale , 1 ) call comms_bcast ( LAI_lorentzian_offset , 1 ) call comms_bcast ( LAI_lorentzian , 1 ) call comms_bcast ( dos_per_volume , 1 ) call comms_bcast ( dos_min_energy , 1 ) call comms_bcast ( dos_max_energy , 1 ) call comms_bcast ( dos_spacing , 1 ) call comms_bcast ( legacy_file_format , 1 ) call comms_bcast ( projectors_string , len ( projectors_string )) call comms_bcast ( set_efermi_zero , 1 ) ! ! Photoemission ! TODO: Broadcast the rest of the photoemission parameters!! call comms_bcast ( photo_model , len ( photo_model )) call comms_bcast ( photo_momentum , len ( photo_momentum )) call comms_bcast ( photo_photon_energy , 1 ) if ( photo_photon_sweep ) then call comms_bcast ( photo_photon_min , 1 ) call comms_bcast ( photo_photon_max , 1 ) end if call comms_bcast ( photo_work_function , 1 ) ! call comms_bcast(photo_surface_area, 1) ! call comms_bcast(photo_slab_volume, 1) call comms_bcast ( photo_slab_max , 1 ) call comms_bcast ( photo_slab_min , 1 ) call comms_bcast ( photo_layer_choice , len ( photo_layer_choice )) call comms_bcast ( photo_max_layer , 1 ) call comms_bcast ( photo_elec_field , 1 ) call comms_bcast ( photo_remove_box_states , 1 ) call comms_bcast ( photo_len_imfp_const , 1 ) if (. not . on_root ) then allocate ( photo_imfp_const ( photo_len_imfp_const ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_dist - allocation failed for photo_imfp_const' ) end if call comms_bcast ( photo_imfp_const ( 1 ), photo_len_imfp_const ) call comms_bcast ( photo_bulk_cutoff , 1 ) call comms_bcast ( photo_temperature , 1 ) call comms_bcast ( write_photo_output , len ( write_photo_output )) call comms_bcast ( photo_theta_lower , 1 ) call comms_bcast ( photo_theta_upper , 1 ) call comms_bcast ( photo_phi_lower , 1 ) call comms_bcast ( photo_phi_upper , 1 ) call comms_bcast ( num_exclude_bands , 1 ) if ( num_exclude_bands > 1 ) then if (. not . on_root ) then allocate ( exclude_bands ( num_exclude_bands ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating exclude_bands in param_read' ) end if call comms_bcast ( exclude_bands ( 1 ), num_exclude_bands ) end if end subroutine param_dist","tags":"","loc":"proc/param_dist.html"},{"title":"param_read – OptaDOS","text":"public  subroutine param_read() Uses od_cell od_io od_constants proc~~param_read~~UsesGraph proc~param_read param_read module~od_cell od_cell proc~param_read->module~od_cell module~od_io od_io proc~param_read->module~od_io module~od_constants od_constants proc~param_read->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. change\nchange\nchange Arguments None Calls proc~~param_read~~CallsGraph proc~param_read param_read proc~io_error io_error proc~param_read->proc~io_error proc~cell_read_cell cell_read_cell proc~param_read->proc~cell_read_cell proc~cell_read_cell->proc~io_error proc~io_file_unit io_file_unit proc~cell_read_cell->proc~io_file_unit proc~utility_cart_to_frac utility_cart_to_frac proc~cell_read_cell->proc~utility_cart_to_frac proc~cell_get_real_lattice cell_get_real_lattice proc~cell_read_cell->proc~cell_get_real_lattice proc~utility_frac_to_cart utility_frac_to_cart proc~cell_read_cell->proc~utility_frac_to_cart proc~utility_lowercase utility_lowercase proc~cell_read_cell->proc~utility_lowercase proc~cell_get_real_lattice->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~param_read~~CalledByGraph proc~param_read param_read program~optados optados program~optados->proc~param_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code param_read Source Code subroutine param_read () !==================================================================! !                                                                  ! ! Read parameters and calculate derived values                     ! !                                                                  ! !=================================================================== use od_constants , only : bohr2ang use od_io , only : io_error , seedname , stderr use od_cell , only : cell_get_atoms , cell_read_cell implicit none !local variables integer :: i_temp , loop , ierr logical :: found character ( len = 20 ), allocatable :: task_string (:) character ( len = 20 ) :: c_string call param_in_file iprint = 1 ! Verbosity call param_get_keyword ( 'iprint' , found , i_value = iprint ) legacy_file_format = . false . call param_get_keyword ( 'legacy_file_format' , found , l_value = legacy_file_format ) energy_unit = 'ev' ! call param_get_keyword ( 'energy_unit' , found , c_value = energy_unit ) if ( index ( energy_unit , 'ev' ) == 0 . and . index ( energy_unit , 'ry' ) == 0 . and . index ( energy_unit , 'ha' ) == 0 ) & call io_error ( 'Error: value of energy_unit not recognised in param_read' ) dos = . false .; pdos = . false .; pdis = . false .; jdos = . false .; optics = . false . core = . false .; compare_dos = . false .; compare_jdos = . false .; photo = . false .; photo_photon_sweep = . false . call param_get_vector_length ( 'task' , found , i_temp ) if ( found . and . i_temp > 0 ) then allocate ( task_string ( i_temp ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - allocation failed for task_string' ) call param_get_keyword_vector ( 'task' , found , i_temp , c_value = task_string ) do loop = 1 , i_temp if ( index ( task_string ( loop ), 'optics' ) > 0 ) then optics = . true . elseif ( index ( task_string ( loop ), 'core' ) > 0 ) then core = . true . elseif ( index ( task_string ( loop ), 'compare_jdos' ) > 0 ) then jdos = . true .; compare_jdos = . true . elseif ( index ( task_string ( loop ), 'jdos' ) > 0 ) then jdos = . true . elseif ( index ( task_string ( loop ), 'pdos' ) > 0 ) then pdos = . true . elseif ( index ( task_string ( loop ), 'pdispersion' ) > 0 ) then pdis = . true . elseif ( index ( task_string ( loop ), 'compare_dos' ) > 0 ) then dos = . true .; compare_dos = . true . elseif ( index ( task_string ( loop ), 'dos' ) > 0 ) then dos = . true . elseif ( index ( task_string ( loop ), 'photoemission' ) > 0 ) then photo = . true . elseif ( index ( task_string ( loop ), 'photon_sweep' ) > 0 ) then photo = . true .; photo_photon_sweep = . true . elseif ( index ( task_string ( loop ), 'none' ) > 0 ) then dos = . false .; pdos = . false .; jdos = . false .; optics = . false .; core = . false . elseif ( index ( task_string ( loop ), 'all' ) > 0 ) then dos = . true .; pdos = . true .; jdos = . true .; optics = . true .; core = . true . else call io_error ( 'Error: value of task unrecognised in param_read' ) end if end do deallocate ( task_string , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - deallocation failed for task_string' ) end if if (( compare_dos . or . compare_jdos ) . and . ( pdos . or . core . or . optics . or . photo )) & call io_error ( 'Error: compare_dos/compare_jdos are not comptable with pdos, core, optics or photoemission tasks' ) if ( pdis . and . ( optics . or . core . or . jdos . or . pdos . or . dos . or . compare_dos . or . compare_jdos . or . photo )) & call io_error ( 'Error: projected bandstructure not compatible with any other tasks' ) i_temp = 0 fixed = . false .; adaptive = . false .; linear = . false .; quad = . false . call param_get_keyword ( 'broadening' , found , c_value = c_string ) if ( found ) then if ( index ( c_string , 'fixed' ) > 0 ) then fixed = . true . elseif ( index ( c_string , 'adaptive' ) > 0 ) then adaptive = . true . elseif ( index ( c_string , 'linear' ) > 0 ) then linear = . true . elseif ( index ( c_string , 'quad' ) > 0 ) then quad = . true . !          fixed=.true.;adaptive=.true.;linear=.true. else call io_error ( 'Error: value of broadening unrecognised in param_read' ) end if end if if ( compare_dos . or . compare_jdos ) then fixed = . true .; adaptive = . true .; linear = . true . end if if (. not . pdis . and . . not . ( fixed . or . adaptive . or . linear . or . quad )) then ! Pick a default adaptive = . true . end if kpoint_mp_grid = - 999 call param_get_keyword_vector ( 'kpoint_mp_grid' , found , 3 , i_value = kpoint_mp_grid ) length_unit = 'ang' ! lenconfac = 1.0_dp call param_get_keyword ( 'length_unit' , found , c_value = length_unit ) if ( length_unit . ne . 'ang' . and . length_unit . ne . 'bohr' ) & call io_error ( 'Error: value of length_unit not recognised in param_read' ) if ( length_unit . eq . 'bohr' ) lenconfac = 1.0_dp / bohr2ang adaptive_smearing = 0.4_dp ! LinDOS default call param_get_keyword ( 'adaptive_smearing' , found , r_value = adaptive_smearing ) fixed_smearing = 0.3_dp ! LinDOS default call param_get_keyword ( 'fixed_smearing' , found , r_value = fixed_smearing ) linear_smearing = 0.0_dp call param_get_keyword ( 'linear_smearing' , found , r_value = linear_smearing ) efermi_user = - 99 9.0_dp if (. not . pdis ) then efermi_choice = \"optados\" else efermi_choice = \"file\" end if call param_get_efermi ( 'efermi' , found , efermi_choice , efermi_user ) compute_band_energy = . true . call param_get_keyword ( 'compute_band_energy' , found , l_value = compute_band_energy ) ! Here we apply a chemical shift to the core energy if supplied by the user core_chemical_shift = - 1.0_dp ! Mizoguchi chemical shift is always +ve call param_get_keyword ( 'core_chemical_shift' , found , r_value = core_chemical_shift ) if ( core_chemical_shift > 0.0_dp ) compute_band_gap = . true . ! Force all Gaussians to be greater than the width of a bin. When using numerical_indos ! this is critical for counting all of the Gaussian DOS peaks. ! When using semi-analytic integration it is desirable to show up very sharp peaks in the ! DOS. However, the intDOS will not be affected. finite_bin_correction = . true . call param_get_keyword ( 'finite_bin_correction' , found , l_value = finite_bin_correction ) ! Perform fixed and adaptive smearing summing the contribution of each Gaussian ! instead of the new and better way of taking the erf. Left in for comparison to LinDOS numerical_intdos = . false . call param_get_keyword ( 'numerical_intdos' , found , l_value = numerical_intdos ) ! Whenever very flat features are found when performing linear broadening, revert to adaptive. ! The tolerance is the gradient of the band at the kpoint. ! N.B. Finite_bin_correction may also be set, to further improve the spectra. hybrid_linear = . false . call param_get_keyword ( 'hybrid_linear' , found , l_value = hybrid_linear ) hybrid_linear_grad_tol = 0.01_dp ! Seems about right for getting semi-core states correctly integrated. call param_get_keyword ( 'hybrid_linear_grad_tol' , found , r_value = hybrid_linear_grad_tol ) set_efermi_zero = . false . if ( pdis ) set_efermi_zero = . true . call param_get_keyword ( 'set_efermi_zero' , found , l_value = set_efermi_zero ) dos_per_volume = . false . call param_get_keyword ( 'dos_per_volume' , found , l_value = dos_per_volume ) dos_min_energy = - huge ( dos_min_energy ) call param_get_keyword ( 'dos_min_energy' , found , r_value = dos_min_energy ) dos_max_energy = huge ( dos_max_energy ) call param_get_keyword ( 'dos_max_energy' , found , r_value = dos_max_energy ) dos_spacing = - 1.0_dp call param_get_keyword ( 'dos_spacing' , found , r_value = dos_spacing ) dos_nbins = - 1 ! 10001 LinDOS default call param_get_keyword ( 'dos_nbins' , found , i_value = dos_nbins ) projectors_string = '' if ( pdos ) call param_get_keyword ( 'pdos' , found , c_value = projectors_string ) if ( pdos . and . ( len_trim ( projectors_string ) == 0 )) call io_error ( 'pdos requested but pdos is not specified' ) if ( pdis ) call param_get_keyword ( 'pdispersion' , found , c_value = projectors_string ) if ( pdis . and . ( len_trim ( projectors_string ) == 0 )) & & call io_error ( 'pdispersion requested but pdispersion keyword is not specified' ) jdos_max_energy = - 1.0_dp !! change call param_get_keyword ( 'jdos_max_energy' , found , r_value = jdos_max_energy ) jdos_spacing = 0.01_dp !! change call param_get_keyword ( 'jdos_spacing' , found , r_value = jdos_spacing ) num_exclude_bands = 0 call param_get_range_vector ( 'exclude_bands' , found , num_exclude_bands , lcount = . true .) if ( found ) then if ( num_exclude_bands < 1 ) call io_error ( 'Error: problem reading exclude_bands' ) allocate ( exclude_bands ( num_exclude_bands ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating exclude_bands in param_read' ) call param_get_range_vector ( 'exclude_bands' , found , num_exclude_bands , . false ., exclude_bands ) if ( any ( exclude_bands < 1 )) & call io_error ( 'Error: exclude_bands must contain positive numbers' ) end if compute_band_gap = . true . call param_get_keyword ( 'compute_band_gap' , found , l_value = compute_band_gap ) devel_flag = ' ' call param_get_keyword ( 'devel_flag' , found , c_value = devel_flag ) output_format = 'xmgrace' call param_get_keyword ( 'output_format' , found , c_value = output_format ) if ( index ( output_format , 'xmgrace' ) == 0 . and . index ( output_format , 'gnuplot' ) == 0 ) & call io_error ( 'Error: value of output_format not recognised in param_read' ) optics_geom = 'polycrys' call param_get_keyword ( 'optics_geom' , found , c_value = optics_geom ) if ( index ( optics_geom , 'polar' ) == 0 . and . index ( optics_geom , 'polycrys' ) == 0 . and . index ( optics_geom , 'tensor' ) == 0 ) & call io_error ( 'Error: value of optics_geom not recognised in param_read' ) scissor_op = 0.0_dp !! change call param_get_keyword ( 'scissor_op' , found , r_value = scissor_op ) optics_qdir = 0.0_dp call param_get_keyword_vector ( 'optics_qdir' , found , 3 , r_value = optics_qdir ) if ( index ( optics_geom , 'polar' ) > 0 . and . . not . found ) & call io_error ( 'Error: polarised or unpolarised optics geometry requested but optics_qdir is not set' ) if (( index ( optics_geom , 'polycrys' ) > 0 . or . index ( optics_geom , 'tensor' ) > 0 ) . and . found ) & call io_error ( 'Error: polycrystalline optics geometry or full dielectric tensor requested but optics_qdir is set' ) optics_intraband = . false . call param_get_keyword ( 'optics_intraband' , found , l_value = optics_intraband ) optics_drude_broadening = 1.0e14_dp call param_get_keyword ( 'optics_drude_broadening' , found , r_value = optics_drude_broadening ) optics_lossfn_broadening = . false . optics_lossfn_gaussian = 0.0_dp call param_get_keyword ( 'optics_lossfn_broadening' , optics_lossfn_broadening , r_value = optics_lossfn_gaussian ) if ( optics_lossfn_gaussian < 0.0_dp ) call io_error ( 'Error: optics_lossfn_broadening must be positive' ) if ( abs ( optics_lossfn_gaussian ) < 1.0e-6_dp ) optics_lossfn_broadening = . false . ! trap too small values core_geom = 'polycrys' call param_get_keyword ( 'core_geom' , found , c_value = core_geom ) if (( index ( core_geom , 'polycrys' ) == 0 ) . and . ( index ( core_geom , 'polar' ) == 0 )) & call io_error ( 'Error: value of core_geom not recognised in param_read' ) core_type = 'absorption' call param_get_keyword ( 'core_type' , found , c_value = core_type ) if ( core_type . ne . 'absorption' . and . core_type . ne . 'emission' . and . core_type . ne . 'all' ) & call io_error ( 'Error: value of core_type not recognised in param_read' ) core_qdir = 0.0_dp call param_get_keyword_vector ( 'core_qdir' , found , 3 , r_value = core_qdir ) if ( index ( core_geom , 'polar' ) > 0 . and . . not . found ) & call io_error ( 'Error: polarised core geometry requested but core_qdir is not set' ) if ( index ( core_geom , 'polycrys' ) > 0 . and . found ) & call io_error ( 'Error: polycrystalline core geometry requested but core_qdir is set' ) core_LAI_broadening = . false . call param_get_keyword ( 'core_lai_broadening' , found , l_value = core_LAI_broadening ) LAI_gaussian_width = 0.0_dp LAI_gaussian = . false . call param_get_keyword ( 'lai_gaussian_width' , found , r_value = LAI_gaussian_width ) if ( LAI_gaussian_width . gt . 1E-14 ) LAI_gaussian = . true . if ( LAI_gaussian_width . lt . 0.0_dp ) call io_error ( 'Error: LAI_gaussian_width must be positive' ) LAI_lorentzian_width = 0.0_dp LAI_lorentzian = . false . call param_get_keyword ( 'lai_lorentzian_width' , found , r_value = LAI_lorentzian_width ) if ( LAI_lorentzian_width . gt . 1E-14 ) LAI_lorentzian = . true . if ( LAI_lorentzian_width . lt . 0.0_dp ) call io_error ( 'Error: LAI_lorentzian_width must be positive' ) LAI_lorentzian_scale = 0.1_dp call param_get_keyword ( 'lai_lorentzian_scale' , found , r_value = LAI_lorentzian_scale ) !    if (LAI_lorentzian_scale.gt.1E-14) LAI_lorentzian=.true. if ( LAI_lorentzian_scale . lt . 0.0_dp ) call io_error ( 'Error: LAI_lorentzian_scale must be positive' ) LAI_lorentzian_offset = 0.0_dp call param_get_keyword ( 'lai_lorentzian_offset' , found , r_value = LAI_lorentzian_offset ) if ( LAI_lorentzian_offset . lt . 0.0_dp ) call io_error ( 'Error: LAI_lorentzian_offset must be positive' ) ! Photoemission parameters - V.Chang Nov-2020 photo_momentum = 'crystal' call param_get_keyword ( 'photo_momentum' , found , c_value = photo_momentum ) if ( index ( photo_momentum , 'kp' ) == 0 . and . index ( photo_momentum , 'crystal' ) == 0 . and . index ( photo_momentum , 'operator' ) == 0 ) & call io_error ( 'Error: value of momentum not recognised in param_read' ) write_photo_output = 'off' call param_get_keyword ( 'write_photo_output' , found , c_value = write_photo_output ) if ( index ( write_photo_output , 'qe_matrix' ) == 0 . and . index ( write_photo_output , 'e_bind' ) == 0 . and . & & index ( write_photo_output , 'off' ) == 0 ) then call io_error ( 'Error: value of write_photo_output output not recognised in param_read' ) end if photo_model = '1step' call param_get_keyword ( 'photo_model' , found , c_value = photo_model ) if ( index ( photo_model , '3step' ) > 0 . and . index ( photo_model , '1step' ) > 0 . or . & index ( photo_model , '3step' ) > 0 . and . index ( photo_model , 'ds_like_pe' ) > 0 . or . & index ( photo_model , '1step' ) > 0 . and . index ( photo_model , 'ds_like_pe' ) > 0 ) then call io_error ( 'Error: value of photoemission model not recognised in param_read' ) end if call param_get_keyword ( 'photo_work_function' , found , r_value = photo_work_function ) if ( photo . and . . not . found ) & call io_error ( 'Error: please set workfunction for photoemission calculation' ) photo_theta_lower = 0.0_dp call param_get_keyword ( 'photo_theta_lower' , found , r_value = photo_theta_lower ) photo_theta_upper = 9 0.0_dp call param_get_keyword ( 'photo_theta_upper' , found , r_value = photo_theta_upper ) photo_phi_lower = 0.0_dp call param_get_keyword ( 'photo_phi_lower' , found , r_value = photo_phi_lower ) photo_phi_upper = 9 0.0_dp call param_get_keyword ( 'photo_phi_upper' , found , r_value = photo_phi_upper ) photo_photon_min = 3.0_dp call param_get_keyword ( 'photo_photon_min' , found , r_value = photo_photon_min ) photo_photon_max = 2.0_dp call param_get_keyword ( 'photo_photon_max' , found , r_value = photo_photon_max ) if ( photo_photon_min . gt . photo_photon_max . and . photo_photon_sweep ) & call io_error ( 'Error: max photon value is lower than min photon value or they have not been set' ) call param_get_keyword ( 'photo_photon_energy' , found , r_value = photo_photon_energy ) if ( found . and . photo_photon_sweep ) call io_error ( 'Error: cannot set photon energy for photon energy sweep calculation' ) if ( photo . and . . not . found . and . . not . photo_photon_sweep ) & call io_error ( 'Error: please set photon energy for photoemission calculation' ) photo_bulk_cutoff = 1 0.0_dp call param_get_keyword ( 'photo_bulk_cutoff' , found , r_value = photo_bulk_cutoff ) if ( found ) photo_bulk_cutoff = - 1 * log ( photo_bulk_cutoff ) photo_temperature = 29 8.0_dp call param_get_keyword ( 'photo_temperature' , found , r_value = photo_temperature ) ! call param_get_keyword('photo_surface_area', found, r_value=photo_surface_area) ! if (photo .and. .not. found) & ! call io_error('Error: please set surface area for photoemission calculation') ! call param_get_keyword('photo_slab_volume', found, r_value=photo_slab_volume) ! if (photo .and. .not. found) & !   call io_error('Error: please set volume of the slab for photoemission calculation') photo_slab_min = 0.0_dp call param_get_keyword ( 'photo_slab_min' , found , r_value = photo_slab_min ) ! if(photo .and. .not. found) & !     call io_error('Error: please set volume of the slab for photoemission calculation') photo_slab_max = 0.0_dp call param_get_keyword ( 'photo_slab_max' , found , r_value = photo_slab_max ) if ( photo_slab_max . lt . 0.0_dp . or . photo_slab_min . lt . 0.0_dp ) then call io_error ( 'Error: the supplied min or max values are negative, which causes faulty calculations!' ) end if if ( photo_slab_max . lt . photo_slab_min ) then call io_error ( 'Error: the supplied slab_max value is less than the slab_min value!' ) end if photo_remove_box_states = . False . call param_get_keyword ( 'photo_remove_box_states' , found , l_value = photo_remove_box_states ) photo_layer_choice = 'optados' call param_get_keyword ( 'photo_layer_choice' , found , c_value = photo_layer_choice ) photo_max_layer = - 1 call param_get_keyword ( 'photo_max_layer' , found , i_value = photo_max_layer ) if ( photo . and . index ( photo_layer_choice , 'user' ) . gt . 0 . and . . not . found ) & call io_error ( 'Error: max # of layers was set to be supplied by user, but does not exist in input' ) photo_elec_field = 0.00_dp call param_get_keyword ( 'photo_elec_field' , found , r_value = photo_elec_field ) call param_get_vector_length ( 'photo_imfp_const' , found , i_temp ) if ( found ) then photo_len_imfp_const = i_temp allocate ( photo_imfp_const ( i_temp ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - allocation failed for photo_imfp_const' ) call param_get_keyword_vector ( 'photo_imfp_const' , found , i_temp , r_value = photo_imfp_const ) else photo_len_imfp_const = 1 allocate ( photo_imfp_const ( 1 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - allocation failed for photo_imfp_const' ) photo_imfp_const = 0.0_dp end if if ( photo . and . . not . found ) & call io_error ( 'Error: constant imfp, but photo_imfp_const is not set' ) num_atoms = 0 num_species = 0 num_crystal_symmetry_operations = 0 if ( pdos . or . pdis . or . core . or . optics . or . photo . or . jdos ) then ! try to read in the atoms from the cell file. ! We don't need them otherwise, so let's not bother !  if(index(devel_flag,'old_filename')>0) then ! No longer need to call get_atoms as we're forcing people who use the legacy code to make an -out.cell !     call cell_get_atoms !  else call cell_read_cell !  end if end if ! check to see that there are no unrecognised keywords if ( any ( len_trim ( in_data (:)) > 0 )) then write ( stderr , '(1x,a)' ) 'The following section of file ' // trim ( seedname ) // '.odi contained unrecognised keywords' write ( stderr , * ) do loop = 1 , num_lines if ( len_trim ( in_data ( loop )) > 0 ) then write ( stderr , '(1x,a)' ) trim ( in_data ( loop )) end if end do write ( stderr , * ) call io_error ( 'Unrecognised keyword(s) in input file' ) end if call param_uppercase () deallocate ( in_data , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating in_data in param_read' ) ! =============================== ! ! Some checks and initialisations ! ! =============================== ! if ( dos_min_energy . ge . dos_max_energy ) then call io_error ( 'Error: must have dos_min_energy < dos_max_energy' ) end if if (( dos_nbins > 0 ) . and . ( dos_spacing > 0.0_dp )) then call io_error ( 'Error: only one of dos_nbins and dos_spacing may be set' ) end if if (( dos_nbins < 0 ) . and . ( dos_spacing < 0.0_dp )) then dos_spacing = 0.005 ! Roughly similar to LinDOS end if return end subroutine param_read","tags":"","loc":"proc/param_read.html"},{"title":"param_write – OptaDOS","text":"public  subroutine param_write() Arguments None Called by proc~~param_write~~CalledByGraph proc~param_write param_write program~optados optados program~optados->proc~param_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code param_write Source Code subroutine param_write !==================================================================! !                                                                  ! ! write parameters to stdout                                       ! !                                                                  ! !=================================================================== implicit none integer :: nat , nsp ! System ! if(num_atoms>0) then !    write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' !    if (lenconfac.eq.1.0_dp) then !       write(stdout,'(1x,a)') '|   Site       Fractional Coordinate          Cartesian Coordinate (Ang)     |' !    else !       write(stdout,'(1x,a)') '|   Site       Fractional Coordinate          Cartesian Coordinate (Bohr)    |' !    endif !    write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' !    do nsp=1,num_species !       do nat=1,atoms_species_num(nsp) !          write(stdout,'(1x,a1,1x,a2,1x,i3,3F10.5,3x,a1,1x,3F10.5,4x,a1)') '|',atoms_symbol(nsp),nat,& !               atoms_pos_frac(:,nat,nsp),'|',atoms_pos_cart(:,nat,nsp)*lenconfac,'|' !       end do !    end do !    write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' ! else !    if(iprint>1)  write(stdout,'(25x,a)') 'No atom positions read' ! end if !  write(stdout,*) ' ' !!$ !!$    write(stdout,*) ' ' !!$    if(iprint>1) then !!$       write(stdout,'(1x,a)') '*----------------------------------------------------------------------------*' !!$       if (lenconfac.eq.1.0_dp) then !!$          write(stdout,'(1x,a)') '| k-point      Fractional Coordinate        Cartesian Coordinate (Ang&#94;-1)    |' !!$       else !!$          write(stdout,'(1x,a)') '| k-point      Fractional Coordinate        Cartesian Coordinate (Bohr&#94;-1)   |' !!$       endif !!$       write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' !!$       !       do nkp=1,nkpoints !!$       !          write(stdout,'(1x,a1,i6,1x,3F10.5,3x,a1,1x,3F10.5,4x,a1)') '|',& !!$       ! nkp,kpoint_r(:,nkp),'|',kpoint_r_cart(:,nkp)/lenconfac,'|' !!$       !       end do !!$       write(stdout,'(1x,a)') '*----------------------------------------------------------------------------*' !!$       write(stdout,*) ' ' !!$    end if !!$    ! Main ! write ( stdout , '(1x,a78)' ) '+------------------------------ JOB CONTROL ---------------------------------+' ! if ( dos ) then write ( stdout , '(1x,a78)' ) '|  Output Density of States                  :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Density of States                  :  False                        |' end if if ( pdos ) then write ( stdout , '(1x,a78)' ) '|  Output Partial Density of States          :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Partial Density of States          :  False                        |' end if if ( pdis ) then write ( stdout , '(1x,a78)' ) '|  Output Projected Bandstructure            :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Projected Bandstructure            :  False                        |' end if if ( jdos ) then write ( stdout , '(1x,a78)' ) '|  Output Joint Density of States            :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Joint Density of States            :  False                        |' end if if ( optics ) then write ( stdout , '(1x,a78)' ) '|  Output Optical Response                   :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Optical Response                   :  False                        |' end if if ( core ) then write ( stdout , '(1x,a78)' ) '|  Output Core-level Spectra                 :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Core-level Spectra                 :  False                        |' end if !Photoemission if ( photo ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Calculation                 :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Photoemission Calculation                 :  False                        |' end if write ( stdout , '(1x,a46,2x,i3,26x,a1)' ) '|  iprint level                              :' , iprint , '|' if ( legacy_file_format ) then write ( stdout , '(1x,a78)' ) '|  Use CASTEP < 6.0 file format              :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Use CASTEP < 6.0 file format              :  False                        |' end if write ( stdout , '(1x,a78)' ) '+-------------------------------- UNITS -------------------------------------+' write ( stdout , '(1x,a46,2x,a4,25x,a1)' ) '|  Length Unit                               :' , trim ( length_unit ), '|' if ( dos . or . pdos ) then if ( dos_per_volume ) then write ( stdout , '(1x,a78)' ) '|  J/P/DOS units                             :  electrons eV&#94;-1 Ang&#94;-3       |' else write ( stdout , '(1x,a78)' ) '|  J/P/DOS units                             :  electrons eV&#94;-1              |' end if end if write ( stdout , '(1x,a78)' ) '+-------------------------- SPECTRAL PARAMETERS -----------------------------+' if ( fixed ) then write ( stdout , '(1x,a78)' ) '|  Fixed Width Smearing                      :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Smearing Width                            :' , fixed_smearing , '|' end if if ( adaptive ) then write ( stdout , '(1x,a78)' ) '|  Adaptive Width Smearing                   :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Adaptive Smearing ratio                   :' , adaptive_smearing , '|' end if if ( linear ) then write ( stdout , '(1x,a78)' ) '|  Linear Extrapolation                      :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Smearing Width                            :' , linear_smearing , '|' end if if ( quad ) & write ( stdout , '(1x,a78)' ) '|  Quadratic Extrapolation                   :  True                         |' if ( finite_bin_correction ) & write ( stdout , '(1x,a78)' ) '|  Finite Bin Correction                     :  True                         |' if ( hybrid_linear ) then write ( stdout , '(1x,a78)' ) '|  Hybrid Linear Correction                  :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Hybrid Linear Gradient Tolerance          :' , hybrid_linear_grad_tol , '|' end if if ( numerical_intdos ) & write ( stdout , '(1x,a78)' ) '|  Numerical Integration of P/DOS            :  True                         |' if ( dos_per_volume ) & write ( stdout , '(1x,a78)' ) '|  Present DOS per simulation cell volume    :  True                         |' if ( set_efermi_zero ) then write ( stdout , '(1x,a78)' ) '|  Shift energy scale so fermi_energy=0      :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Shift energy scale so fermi_energy=0      :  False                        |' end if if ( efermi_user == - 99 9.0_dp ) then ! efermi_user not set if ( index ( efermi_choice , 'optados' ) . gt . 0 ) then write ( stdout , '(1x,a78)' ) '|  Fermi energy                              :  Calculated by OptaDOS        |' elseif ( index ( efermi_choice , 'file' ) . gt . 0 ) then write ( stdout , '(1x,a78)' ) '|  Fermi energy                              :  Read from file               |' elseif ( index ( efermi_choice , 'insulator' ) . gt . 0 ) then write ( stdout , '(1x,a78)' ) '|  Fermi energy                              :  Assume insulator (n_elec/2)  |' end if else ! It is set write ( stdout , '(1x,a46,1x,1F10.5,20x,a1)' ) '|  Fermi energy                              :' , efermi_user , '|' end if if ( compute_band_energy ) then write ( stdout , '(1x,a78)' ) '|  Compute the band energy                   :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Compute the band energy                   :  False                        |' end if if ( compute_band_gap ) then write ( stdout , '(1x,a78)' ) '|  Compute the band gap                      :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Compute the band gap                      :  False                        |' end if if ( photo ) then write ( stdout , '(1x,a19,26x,a2,f7.4,3x,21a)' ) '|  JDOS bin spacing' , ': ' , jdos_spacing , 'eV                  |' write ( stdout , '(1x,a22,23x,a2,f7.4,3x,21a)' ) '|  JDOS max energy bin' , ': ' , jdos_max_energy , 'eV                  |' end if if ( optics . or . photo ) then write ( stdout , '(1x,a78)' ) '+-------------------------------- OPTICS ------------------------------------+' if ( index ( optics_geom , 'polycrys' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Polycrystalline              |' elseif ( index ( optics_geom , 'unpolar' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Unpolarised                  |' write ( stdout , '(1x,a47,2x,f6.2,2x,f6.2,2x,f6.2,3x,a4)' ) '|  Direction of q-vector (un-normalised)     : ' & , optics_qdir ( 1 : 3 ), '   |' elseif ( index ( optics_geom , 'polar' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Polarised                    |' write ( stdout , '(1x,a47,2x,f6.2,2x,f6.2,2x,f6.2,3x,a4)' ) '|  Direction of q-vector (un-normalised)     : ' & , optics_qdir ( 1 : 3 ), '   |' elseif ( index ( optics_geom , 'tensor' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Full dielectric tensor       |' end if if ( optics_intraband ) then write ( stdout , '(1x,a78)' ) '|  Include Intraband Contribution            :  True                         |' write ( stdout , '(1x,a46,1x,1E10.3,20x,a1)' ) '|  Drude Broadening                          :' ,& & optics_drude_broadening , '|' else write ( stdout , '(1x,a78)' ) '|  Include Intraband Contribution            :  False                        |' end if if ( optics_lossfn_broadening ) then write ( stdout , '(1x,a78)' ) '|  Include Loss Function Broadening          :  True                         |' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Gaussian Width                            :' , & & optics_lossfn_gaussian , '|' else write ( stdout , '(1x,a78)' ) '|  Include Loss Function Broadening          :  False                        |' end if if ( scissor_op > 1.0e-10_dp ) & write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Scissor Operator (eV)                     :' , scissor_op , '|' end if if ( core ) then write ( stdout , '(1x,a78)' ) '+--------------------------------- CORE -------------------------------------+' if ( index ( core_geom , 'polycrys' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Core Calculation             :  Polycrystalline              |' elseif ( index ( core_geom , 'polar' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Core Calculation             :  Polarised                    |' write ( stdout , '(1x,a47,2x,f6.2,2x,f6.2,2x,f6.2,3x,a4)' ) '|  Direction of q-vector (un-normalised)     : ' & , core_qdir ( 1 : 3 ), '   |' end if if ( index ( core_type , 'absorption' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Absorption or Emission Spectrum           :  Absorption                   |' elseif ( index ( core_type , 'emission' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Absorption or Emission Spectrum           :  Emission                     |' else write ( stdout , '(1x,a78)' ) '|  Absorption or Emission Spectrum           :  Both                         |' end if ! Write out if mizoguchi shift is applied if ( core_chemical_shift == - 1.0_dp ) then ! mizoguchi shift not set write ( stdout , '(1x,a78)' ) '|  Core chemical shift                       :  None                         |' else ! It is set write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Core chemical shift                       :' , core_chemical_shift , '|' end if if ( core_LAI_broadening ) then write ( stdout , '(1x,a78)' ) '|  Include lifetime and Instrument Broadening:  True                         |' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Gaussian Width                            :' , LAI_gaussian_width , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Lorentzian Width                          :' , LAI_lorentzian_width , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Lorentzian Scale                          :' , LAI_lorentzian_scale , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Lorentzian Offset                         :' , LAI_lorentzian_offset , '|' else write ( stdout , '(1x,a78)' ) '|  Include lifetime and Instrument Broadening:  False                        |' end if end if ! Added for Photoemission output - F. Mildner, 12/2022 if ( photo ) then write ( stdout , '(1x,a78)' ) '+----------------------- PHOTOEMISSION PARAMETERS ---------------------------+' if ( index ( photo_model , '1step' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Model                       :     1-Step Model              |' write ( stdout , '(1x,a78)' ) '|  Photoemission Final State                 :     Free Electron State       |' elseif ( index ( photo_model , '3step' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Model                       :     3-Step Model              |' write ( stdout , '(1x,a78)' ) '|  Photoemission Final State                 :     Bloch State               |' elseif ( index ( photo_model , 'ds_like_pe' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Model                       :     Simplified PE Model       |' end if if ( photo_photon_sweep ) then write ( stdout , '(1x,a46,1x,1f10.4,a4,1f7.4,a10)' ) '|  Photon Energy Sweep                       :' , photo_photon_min ,& & ' -> ' , photo_photon_max , ' eV      |' else write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Photon Energy              (eV)           :' , photo_photon_energy , '|' end if write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Work Function              (eV)           :' , photo_work_function , '|' ! write (stdout, '(1x,a46,1x,1f10.4,20x,a1)') '|  Surface Area               (Ang**2)       :', photo_surface_area, '|' ! write (stdout, '(1x,a46,1x,1f10.4,20x,a1)') '|  Slab Volume                (Ang**3)       :', photo_slab_volume, '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Slab Max Z-Coord.          (Ang)          :' , photo_slab_max , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Slab Min Z-Coord.          (Ang)          :' , photo_slab_min , '|' if ( index ( photo_layer_choice , 'user' ) > 0 ) then write ( stdout , '(1x,a46,2x,I4,25x,a1)' ) '|  User set maximal # of layers for calc.    :' , photo_max_layer , '|' end if if ( size ( photo_imfp_const , 1 ) . eq . 1 ) then write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  IMFP Constant              (Ang)          :' , photo_imfp_const ( 1 ), '|' else write ( stdout , '(1x,a78)' ) '|  IMFP Constant              (Ang)          : Layer values provided by user |' write ( stdout , '(1x,a78)' ) '|                                              values will be printed later  |' end if write ( stdout , '(1x,a46,4x,E11.4,16x,a1)' ) '|  Approx. Bulk P_escape Cutoff              :' , exp ( - 1 * photo_bulk_cutoff ), '|' if (( photo_elec_field . gt . 1.0E-4_dp ) . or . ( photo_elec_field . lt . 1.0E-25_dp )) then write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Electric Field Strength    (V/Ang)        :' , photo_elec_field , '|' else write ( stdout , '(1x,a46,1x,E17.9,13x,a1)' ) '|  Electric Field Strength    (V/Ang)        :' , photo_elec_field , '|' end if write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Smearing Temperature       (K)            :' , photo_temperature , '|' write ( stdout , '(1x,a46,5x,a9,17x,a1)' ) '|  Transverse Momentum Scheme                :' , photo_momentum , '|' if ( photo_remove_box_states ) then write ( stdout , '(1x,a78)' ) '|  Identify and remove box states            :     True                      |' end if ! TODO: Edit the output to reflect the changes made to the printing subroutines if ( index ( write_photo_output , 'slab' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Writing Photoemission Matrix Elements     :     Atom Sites                |' write ( stdout , '(1x,a78)' ) '|          to *SEED*_matrix.dat ---------------------------------------------|' elseif ( index ( write_photo_output , 'all' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Writing Photoemission Matrix Elements     :     All Elements              |' write ( stdout , '(1x,a78)' ) '|          to *SEED*_matrix.dat ---------------------------------------------|' end if write ( stdout , '(1x,a78)' ) '|  Emission Angle Bounds for writing to *SEED*_binding_energy.dat -----------|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Theta    -lower -          (deg)          :' , photo_theta_lower , '|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Theta    -upper -          (deg)          :' , photo_theta_upper , '|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Phi      -lower -          (deg)          :' , photo_phi_lower , '|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Phi      -upper -          (deg)          :' , photo_phi_upper , '|' end if write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' if ( num_exclude_bands > 0 ) write ( stdout , '(1x,a16,1x,999(1x,I3))' ) 'excluded_bands :' , exclude_bands (:) if ( scan ( devel_flag , \"AEIOUaeiou\" ) > 0 ) write ( stdout , '(1x,a12,1x,a100)' ) 'devel_flag :' , devel_flag write ( stdout , * ) ' ' end subroutine param_write","tags":"","loc":"proc/param_write.html"},{"title":"param_write_atomic_coord – OptaDOS","text":"public  subroutine param_write_atomic_coord() Arguments None Called by proc~~param_write_atomic_coord~~CalledByGraph proc~param_write_atomic_coord param_write_atomic_coord program~optados optados program~optados->proc~param_write_atomic_coord Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code param_write_atomic_coord Source Code subroutine param_write_atomic_coord !==================================================================! !                                                                  ! ! write atomic coodes to stdout                                       ! !                                                                  ! !=================================================================== implicit none integer :: nat , nsp , atom_counter ! System if ( num_atoms > 0 ) then write ( stdout , * ) ' ' ! IT DOESN'T SEEM HELPFUL TO WRITE OUT TO MULTIPLY THE INITAL ATOMIC POSITIONS WITH THE FINAL LATTICE... if ( iprint > 2 ) then write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' if ( lenconfac . eq . 1.0_dp ) then write ( stdout , '(1x,a)' ) '|   Site       Fractional Coordinate          Cartesian Coordinate (Ang)     |' else write ( stdout , '(1x,a)' ) '|   Site       Fractional Coordinate          Cartesian Coordinate (Bohr)    |' end if write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' do nsp = 1 , num_species do nat = 1 , atoms_species_num ( nsp ) write ( stdout , '(1x,a1,1x,a2,1x,i3,3F10.5,3x,a1,1x,3F10.5,4x,a1)' ) '|' , atoms_symbol ( nsp ), nat , & atoms_pos_frac (:, nat , nsp ), '|' , atoms_pos_cart (:, nat , nsp ) * lenconfac , '|' end do end do write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a)' ) '  WARNING: These are the CASTEP input coordinates not the output -- here to   ' write ( stdout , '(1x,a)' ) '            aid advanced debugging only.' else atom_counter = 1 write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a)' ) '|             Species                  Sites                  Total Atoms    |' write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' do nsp = 1 , num_species write ( stdout , '(1x,a1,16x,a2,16x,i4,a3,i4,16x,i4,11x,a)' ) '|' , atoms_symbol ( nsp ), & & atom_counter , \"to\" , atom_counter + atoms_species_num ( nsp ) - 1 , atoms_species_num ( nsp ), \"|\" atom_counter = atom_counter + atoms_species_num ( nsp ) end do write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' end if else if ( iprint > 1 ) write ( stdout , '(25x,a)' ) 'No atom positions read' end if write ( stdout , * ) ' ' end subroutine param_write_atomic_coord","tags":"","loc":"proc/param_write_atomic_coord.html"},{"title":"param_write_header – OptaDOS","text":"public  subroutine param_write_header() Uses od_constants proc~~param_write_header~~UsesGraph proc~param_write_header param_write_header module~od_constants od_constants proc~param_write_header->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~param_write_header~~CalledByGraph proc~param_write_header param_write_header program~optados optados program~optados->proc~param_write_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code param_write_header Source Code subroutine param_write_header use od_constants , only : optados_version , copyright implicit none write ( stdout , * ) write ( stdout , '(a78)' ) \" +===========================================================================+\" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |                OOO   PPPP  TTTTT  AA   DDD    OOO    SSS                  | \" write ( stdout , '(a78)' ) \" |               O   O  P   P   T   A  A  D  D  O   O  S                     | \" write ( stdout , '(a78)' ) \" |               O   O  PPPP    T   AAAA  D  D  O   O   SS                   | \" write ( stdout , '(a78)' ) \" |               O   O  P       T   A  A  D  D  O   O     S                  | \" write ( stdout , '(a78)' ) \" |                OOO   P       T   A  A  DDD    OOO   SSS                   | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" +---------------------------------------------------------------------------+ \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a46,a5,a28)' ) \" |                 Welcome to OptaDOS version \" , optados_version , \"   & &                     | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |         Andrew J. Morris, Rebecca Nicholls, Chris J. Pickard              | \" write ( stdout , '(a78)' ) \" |                       and Jonathan R. Yates                               | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a34,a14,a30)' ) \" |                       Copyright\" , trim ( copyright ),& & \"                             | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |  Please cite:                                                             | \" write ( stdout , '(a78)' ) \" |  Andrew J. Morris, Rebecca Nicholls, Chris J. Pickard and Jonathan Yates  | \" write ( stdout , '(a78)' ) \" |              Comp. Phys. Comm. 185, 5, 1477 (2014)                        | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |  Additionally when using the linear broadening:                           | \" write ( stdout , '(a78)' ) \" | C.J. Pickard and M.C. Payne, Phys. Rev. B, 59, 7, 4685 (1999)             | \" write ( stdout , '(a78)' ) \" | C.J. Pickard and M.C. Payne, Phys. Rev. B, 62, 7, 4383 (2000)             | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |  Additionally when using the adaptive broadening:                         | \" write ( stdout , '(a78)' ) \" | J.Yates, X.Wang, D.Vanderbilt and I.Souza, Phys. Rev. B, 75, 195121 (2007)| \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |      in all your publications arising from your use of OptaDOS            | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" +===========================================================================+ \" write ( stdout , * ) end subroutine param_write_header","tags":"","loc":"proc/param_write_header.html"},{"title":"conv_get_seedname – OptaDOS","text":"public  subroutine conv_get_seedname() Uses od_io proc~~conv_get_seedname~~UsesGraph proc~conv_get_seedname conv_get_seedname module~od_io od_io proc~conv_get_seedname->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Set the seedname from the command line\nset to optados until proven otherwise\nEnd of flags\nWe've already set the seedname so it can't be that again! Arguments None Calls proc~~conv_get_seedname~~CallsGraph proc~conv_get_seedname conv_get_seedname proc~print_usage print_usage proc~conv_get_seedname->proc~print_usage proc~io_error io_error proc~conv_get_seedname->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~conv_get_seedname~~CalledByGraph proc~conv_get_seedname conv_get_seedname program~od2od od2od program~od2od->proc~conv_get_seedname Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code conv_get_seedname Source Code subroutine conv_get_seedname !! Set the seedname from the command line use od_io , only : seedname implicit none integer :: num_arg integer :: i !! Temporary variable character ( len = 50 ) :: ctemp num_arg = command_argument_count () outseedname = 'optados' seedname = 'optados' !! set to optados until proven otherwise i = 1 do while ( i . le . num_arg ) call get_command_argument ( i , ctemp ) select case ( trim ( ctemp )) case ( \"-i\" , \"--in_file\" ) i = i + 1 call get_command_argument ( i , infile ) case ( \"-o\" , \"--out_file\" ) i = i + 1 call get_command_argument ( i , outfile ) case ( \"-w\" , \"--out_seedname\" ) i = i + 1 call get_command_argument ( i , outseedname ) case ( \"--\" ) !! End of flags i = i + 1 call get_command_argument ( i , seedname ) case default if ( seedname == 'optados' ) then seedname = trim ( ctemp ) i = i + 1 else !! We've already set the seedname so it can't be that again! call print_usage call io_error ( 'Wrong command line arguments, see logfile for usage' ) end if end select i = i + 1 end do if ( outseedname == 'optados' ) then outseedname = seedname end if end subroutine conv_get_seedname","tags":"","loc":"proc/conv_get_seedname.html"},{"title":"get_band_energy – OptaDOS","text":"public  subroutine get_band_energy() Read the band file info which is prerequisite to know about k-points\nbands etc.\nIt would be nice for od2od to work this out for itself. But at least this\nway it is consistent.  The problem is that to convert, say a ome to a ome\none also requires a .bands file. Arguments None Calls proc~~get_band_energy~~CallsGraph proc~get_band_energy get_band_energy proc~elec_read_band_energy elec_read_band_energy proc~get_band_energy->proc~elec_read_band_energy proc~report_arraysize report_arraysize proc~get_band_energy->proc~report_arraysize proc~io_time io_time proc~elec_read_band_energy->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_band_energy->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_read_band_energy->interface~comms_bcast proc~algor_dist_array algor_dist_array proc~elec_read_band_energy->proc~algor_dist_array proc~io_error io_error proc~elec_read_band_energy->proc~io_error interface~comms_send comms_send proc~elec_read_band_energy->interface~comms_send proc~cell_find_mp_grid cell_find_MP_grid proc~elec_read_band_energy->proc~cell_find_mp_grid interface~comms_recv comms_recv proc~elec_read_band_energy->interface~comms_recv proc~algor_dist_array->proc~io_error proc~cell_find_mp_grid->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_band_energy~~CalledByGraph proc~get_band_energy get_band_energy program~od2od od2od program~od2od->proc~get_band_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_band_energy Source Code subroutine get_band_energy () !! Read the band file info which is prerequisite to know about k-points !! bands etc. !! It would be nice for od2od to work this out for itself. But at least this !! way it is consistent.  The problem is that to convert, say a ome to a ome !! one also requires a .bands file. implicit none write ( stdout , * ) write ( stdout , * ) \"+----------------------------- K-point information --------------------------+\" call elec_read_band_energy () call report_arraysize () write ( stdout , * ) \"+----------------------------------------------------------------------------+\" end subroutine get_band_energy","tags":"","loc":"proc/get_band_energy.html"},{"title":"pad_an_ome – OptaDOS","text":"public  subroutine pad_an_ome() Uses od_electronic od_cell od_io od_constants proc~~pad_an_ome~~UsesGraph proc~pad_an_ome pad_an_ome module~od_electronic od_electronic proc~pad_an_ome->module~od_electronic module~od_cell od_cell proc~pad_an_ome->module~od_cell module~od_io od_io proc~pad_an_ome->module~od_io module~od_constants od_constants proc~pad_an_ome->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This routine takes OptaDOS's internal representation of an dome file, and\nuses it to construct an ome file, where the off diagonal elements are\npadded with zeros.\nIt might be helpful if we're reading in other codes' input files.\nIt might also be useful for testing OptaDOS itself. Arguments None Called by proc~~pad_an_ome~~CalledByGraph proc~pad_an_ome pad_an_ome program~od2od od2od program~od2od->proc~pad_an_ome Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pad_an_ome Source Code subroutine pad_an_ome () !! This routine takes OptaDOS's internal representation of an dome file, and !! uses it to construct an ome file, where the off diagonal elements are !! padded with zeros. !! It might be helpful if we're reading in other codes' input files. !! It might also be useful for testing OptaDOS itself. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient , optical_mat implicit none integer :: loop !! Loop variable. write ( stdout , * ) \" Padding a dome into a ome.\" if (. not . allocated ( optical_mat )) then write ( stdout , * ) \" Allocating optical_mat\" allocate ( optical_mat ( nbands , nbands , 3 , nkpoints , nspins )) end if ! Pad with zeros. optical_mat = 0.0_dp do loop = 1 , nbands optical_mat ( loop , loop , :, :, :) = band_gradient ( loop , :, :, :) end do end subroutine pad_an_ome","tags":"","loc":"proc/pad_an_ome.html"},{"title":"print_usage – OptaDOS","text":"public  subroutine print_usage() Writes the usage of the program to stdout Arguments None Called by proc~~print_usage~~CalledByGraph proc~print_usage print_usage proc~conv_get_seedname conv_get_seedname proc~conv_get_seedname->proc~print_usage program~od2od od2od program~od2od->proc~conv_get_seedname Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code print_usage Source Code subroutine print_usage () !! Writes the usage of the program to stdout write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" OptaDOS od2od \" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" Usage: od2od -i/--in_file <in_type> -o/--out_file <out_type> -w/--out_seedname [seedout] [seedname] \" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" [seedname] and [seedout] are optional input and output seednames\" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" <in_type> and <out_type> is one of: \" write ( stdout , '(A)' ) \"       ome_fmt : a formatted optical matrix element file\" write ( stdout , '(A)' ) \"       ome_bin : an unformatted optical matrix element file\" ! Added by F. Mildner (04/2023) for photoemission write ( stdout , '(A)' ) \"       fem_fmt : a formatted free electron optical matrix element file\" write ( stdout , '(A)' ) \"       fem_bin : an unformatted free electron optical matrix element file\" write ( stdout , '(A)' ) \"      dome_fmt : a formatted diagonal optical matrix element file\" write ( stdout , '(A)' ) \"      dome_bin : an unformatted diagonal optical matrix element file\" write ( stdout , '(A)' ) \"      pdos_fmt : a formatted projected density of states file\" write ( stdout , '(A)' ) \"      pdos_bin : an unformatted projected density of states file\" write ( stdout , '(A)' ) \"     elnes_fmt : an formatted ELNES file\" write ( stdout , '(A)' ) \"     elnes_bin : an unformatted ELNES file\" write ( stdout , '(A)' ) \"         dummy : no input or output file (for testing)\" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" Known issues: (1) a seedname.bands file also needs to be present until\" write ( stdout , '(A)' ) \"    I've thought of a better way to do it.\" write ( stdout , '(A)' ) \"      (3) It only works in serial.\" write ( stdout , '(A)' ) \"      (4) It only decides if the output format is sane after it's\" write ( stdout , '(A)' ) \"     read the input.\" write ( stdout , '(A)' ) \"      (5) I need to think more about the amount of precision in in a formatted\" write ( stdout , '(A)' ) \"     out file.\" write ( stdout , '(A)' ) \"      (6) File versions and headers could be better stored and reproduced.\" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" Features: (1) Ability to convert a ome into a dome.\" write ( stdout , '(A)' ) end subroutine print_usage","tags":"","loc":"proc/print_usage.html"},{"title":"read_dome_bin – OptaDOS","text":"public  subroutine read_dome_bin() Read a diagonal ome file. Wrapper to keep the naming scheme tidy. Arguments None Calls proc~~read_dome_bin~~CallsGraph proc~read_dome_bin read_dome_bin proc~elec_read_band_gradient elec_read_band_gradient proc~read_dome_bin->proc~elec_read_band_gradient interface~comms_bcast comms_bcast proc~elec_read_band_gradient->interface~comms_bcast proc~io_time io_time proc~elec_read_band_gradient->proc~io_time proc~io_error io_error proc~elec_read_band_gradient->proc~io_error proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->interface~comms_recv proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_dome_bin~~CalledByGraph proc~read_dome_bin read_dome_bin program~od2od od2od program~od2od->proc~read_dome_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_dome_bin Source Code subroutine read_dome_bin () !! Read a diagonal ome file. Wrapper to keep the naming scheme tidy. implicit none write ( stdout , * ) \" Read a binary dome file.\" call elec_read_band_gradient () end subroutine read_dome_bin","tags":"","loc":"proc/read_dome_bin.html"},{"title":"read_dome_fmt – OptaDOS","text":"public  subroutine read_dome_fmt() Uses od_electronic od_cell od_io od_constants proc~~read_dome_fmt~~UsesGraph proc~read_dome_fmt read_dome_fmt module~od_electronic od_electronic proc~read_dome_fmt->module~od_electronic module~od_cell od_cell proc~read_dome_fmt->module~od_cell module~od_io od_io proc~read_dome_fmt->module~od_io module~od_constants od_constants proc~read_dome_fmt->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Read a diagonal ome formatted file. Arguments None Called by proc~~read_dome_fmt~~CalledByGraph proc~read_dome_fmt read_dome_fmt program~od2od od2od program~od2od->proc~read_dome_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_dome_fmt Source Code subroutine read_dome_fmt () !! Read a diagonal ome formatted file. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , dome_unit = 6 write ( stdout , * ) \" Read a formatted dome file. \" if (. not . allocated ( band_gradient )) then write ( stdout , * ) \" Allocating band_gradient\" allocate ( band_gradient ( nbands , 3 , nkpoints , nspins )) end if open ( unit = dome_unit , form = 'formatted' , file = trim ( seedname ) // \".dome_fmt\" ) write ( string , '(i0,\"(1x,\",a,\")\")' ) 3 * nbands , trim ( format_precision ) read ( dome_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( dome_unit , '(a80)' ) domefile_header do ik = 1 , nkpoints do is = 1 , nspins read ( dome_unit , '(' // trim ( string ) // ')' ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), & & i = 1 , 3 ) end do end do band_gradient = band_gradient * ( bohr2ang * H2eV ) close ( unit = dome_unit ) write ( stdout , * ) \" \" // trim ( seedname ) // \".dome_fmt\" // \"--> Formatted ome sucessfully read. \" end subroutine read_dome_fmt","tags":"","loc":"proc/read_dome_fmt.html"},{"title":"read_elnes_bin – OptaDOS","text":"public  subroutine read_elnes_bin() Wrapper to read a binary elnes file. The wrapping allows us to have\nconsistent names within the module, which makes life easier. Arguments None Calls proc~~read_elnes_bin~~CallsGraph proc~read_elnes_bin read_elnes_bin proc~elec_read_elnes_mat elec_read_elnes_mat proc~read_elnes_bin->proc~elec_read_elnes_mat proc~io_time io_time proc~elec_read_elnes_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_elnes_mat->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_read_elnes_mat->interface~comms_bcast interface~comms_send comms_send proc~elec_read_elnes_mat->interface~comms_send proc~io_error io_error proc~elec_read_elnes_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_elnes_mat->interface~comms_recv proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~elec_elnes_find_channel_names->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_elnes_bin~~CalledByGraph proc~read_elnes_bin read_elnes_bin program~od2od od2od program~od2od->proc~read_elnes_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_elnes_bin Source Code subroutine read_elnes_bin () !! Wrapper to read a binary elnes file. The wrapping allows us to have !! consistent names within the module, which makes life easier. implicit none write ( stdout , * ) \" Read a binary elnes file.\" call elec_read_elnes_mat () end subroutine read_elnes_bin","tags":"","loc":"proc/read_elnes_bin.html"},{"title":"read_elnes_fmt – OptaDOS","text":"public  subroutine read_elnes_fmt() Uses od_electronic od_cell od_io proc~~read_elnes_fmt~~UsesGraph proc~read_elnes_fmt read_elnes_fmt module~od_electronic od_electronic proc~read_elnes_fmt->module~od_electronic module~od_io od_io proc~read_elnes_fmt->module~od_io module~od_cell od_cell proc~read_elnes_fmt->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Read a formatted elnes file. Arguments None Calls proc~~read_elnes_fmt~~CallsGraph proc~read_elnes_fmt read_elnes_fmt proc~io_file_unit io_file_unit proc~read_elnes_fmt->proc~io_file_unit proc~io_error io_error proc~read_elnes_fmt->proc~io_error proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~read_elnes_fmt->proc~elec_elnes_find_channel_names proc~elec_elnes_find_channel_names->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_elnes_fmt~~CalledByGraph proc~read_elnes_fmt read_elnes_fmt program~od2od od2od program~od2od->proc~read_elnes_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_elnes_fmt Source Code subroutine read_elnes_fmt () !! Read a formatted elnes file. use od_electronic , only : elec_elnes_find_channel_names , elnes_orbital , & & elnes_mwab , elnes_mat use od_io , only : io_file_unit , seedname use od_cell , only : num_kpoints_on_node implicit none character ( len = 20 ) :: dummy20 , dummy10 real ( dp ) :: file_version !! The file verioson format to write. Currently we're on version 1. integer :: elnes_unit , ik , is , iorb , ib , indx , ierr !! Loop variable. character ( len = 80 ) :: string , string2 !! Tempory string manipulation variable. write ( stdout , * ) \" Read a formatted elnes file.\" elnes_unit = io_file_unit () open ( unit = elnes_unit , file = trim ( seedname ) // \".elnes_fmt\" , form = 'formatted' ) read ( elnes_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( elnes_unit , '(a80)' ) elnesfile_header read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % norbitals read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % nbands read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % nkpoints read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % nspins write ( string , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals * elnes_mwab % nbands * 3 , trim ( format_precision ) allocate ( elnes_orbital % ion_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%ion_no' ) allocate ( elnes_orbital % species_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%species_no' ) allocate ( elnes_orbital % rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbitall%rank_in_species' ) allocate ( elnes_orbital % shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbitall%shell' ) allocate ( elnes_orbital % am_channel ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%am_channel' ) allocate ( elnes_orbital % am_channel_name ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%am_channel_name' ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) allocate ( elnes_mat ( 1 : elnes_mwab % norbitals , 1 : elnes_mwab % nbands , 1 : 3 , & 1 : num_kpoints_on_node ( 0 ), 1 : elnes_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating elnes_mat in read_elnes_fmt' ) do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , elnes_mwab % nspins read ( elnes_unit , '(' // trim ( string2 ) // ')' ) ((( elnes_mat ( iorb , ib , indx , ik , is ), iorb = 1 , elnes_mwab % norbitals ), & ib = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do call elec_elnes_find_channel_names () write ( stdout , * ) \" \" // trim ( seedname ) // \".elnes_fmt\" // \"--> Formatted elnes sucessfully read. \" end subroutine read_elnes_fmt","tags":"","loc":"proc/read_elnes_fmt.html"},{"title":"read_fem_bin – OptaDOS","text":"public  subroutine read_fem_bin() Read a binary ome file. Wrapper to keep the naming tidy. Arguments None Calls proc~~read_fem_bin~~CallsGraph proc~read_fem_bin read_fem_bin proc~elec_read_foptical_mat elec_read_foptical_mat proc~read_fem_bin->proc~elec_read_foptical_mat proc~io_time io_time proc~elec_read_foptical_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_foptical_mat->proc~io_file_unit proc~algor_dist_array algor_dist_array proc~elec_read_foptical_mat->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_foptical_mat->interface~comms_send proc~io_error io_error proc~elec_read_foptical_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_foptical_mat->interface~comms_recv interface~comms_reduce comms_reduce proc~elec_read_foptical_mat->interface~comms_reduce proc~algor_dist_array->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_fem_bin~~CalledByGraph proc~read_fem_bin read_fem_bin program~od2od od2od program~od2od->proc~read_fem_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_fem_bin Source Code subroutine read_fem_bin () !! Read a binary ome file. Wrapper to keep the naming tidy. implicit none write ( stdout , * ) \" Read a formatted ome file. \" call elec_read_foptical_mat () write ( stdout , * ) \" \" // trim ( seedname ) // \".fem_bin\" // \"--> Unformatted ome sucessfully read. \" end subroutine read_fem_bin","tags":"","loc":"proc/read_fem_bin.html"},{"title":"read_fem_fmt – OptaDOS","text":"public  subroutine read_fem_fmt() Uses od_electronic od_cell od_io od_constants proc~~read_fem_fmt~~UsesGraph proc~read_fem_fmt read_fem_fmt module~od_electronic od_electronic proc~read_fem_fmt->module~od_electronic module~od_cell od_cell proc~read_fem_fmt->module~od_cell module~od_io od_io proc~read_fem_fmt->module~od_io module~od_constants od_constants proc~read_fem_fmt->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Read a formatted Optical Matrix Elements file. Arguments None Called by proc~~read_fem_fmt~~CalledByGraph proc~read_fem_fmt read_fem_fmt program~od2od od2od program~od2od->proc~read_fem_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_fem_fmt Source Code subroutine read_fem_fmt () !! Read a formatted Optical Matrix Elements file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , foptical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string , string2 integer :: ik , is , ib , i , jb , fem_unit = 6 write ( stdout , * ) \" Read a formatted .fem file. \" if (. not . allocated ( foptical_mat )) then write ( stdout , * ) \" Allocating foptical_mat.\" allocate ( foptical_mat ( nbands + 1 , nbands + 1 , 3 , nkpoints , nspins )) end if open ( unit = fem_unit , form = 'formatted' , recl = 1073741824 , file = trim ( seedname ) // \".fem_fmt\" ) ! Total number of elements of ome write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * ( nbands + 1 ) * ( nbands + 1 ), trim ( format_precision ) ! write(stdout,*) string ! write(string,'(a)') trim(format_precision) read ( fem_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( fem_unit , '(a80)' ) omefile_header ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins read ( fem_unit , '(' // trim ( string ) // ')' ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), & & jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do foptical_mat = foptical_mat * ( bohr2ang * H2eV ) close ( unit = fem_unit ) write ( stdout , * ) trim ( seedname ) // \".fem_fmt\" // \"--> Formatted fem sucessfully read. \" end subroutine read_fem_fmt","tags":"","loc":"proc/read_fem_fmt.html"},{"title":"read_ome_bin – OptaDOS","text":"public  subroutine read_ome_bin() Read a binary ome file. Wrapper to keep the naming tidy. Arguments None Calls proc~~read_ome_bin~~CallsGraph proc~read_ome_bin read_ome_bin proc~elec_read_optical_mat elec_read_optical_mat proc~read_ome_bin->proc~elec_read_optical_mat proc~io_time io_time proc~elec_read_optical_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_optical_mat->proc~io_file_unit proc~algor_dist_array algor_dist_array proc~elec_read_optical_mat->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_optical_mat->interface~comms_send proc~io_error io_error proc~elec_read_optical_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_optical_mat->interface~comms_recv proc~algor_dist_array->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_ome_bin~~CalledByGraph proc~read_ome_bin read_ome_bin program~od2od od2od program~od2od->proc~read_ome_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_ome_bin Source Code subroutine read_ome_bin () !! Read a binary ome file. Wrapper to keep the naming tidy. implicit none write ( stdout , * ) \" Read a formatted ome file. \" call elec_read_optical_mat () write ( stdout , * ) \" \" // trim ( seedname ) // \".ome_bin\" // \"--> Unformatted ome sucessfully read. \" end subroutine read_ome_bin","tags":"","loc":"proc/read_ome_bin.html"},{"title":"read_ome_fmt – OptaDOS","text":"public  subroutine read_ome_fmt() Uses od_electronic od_cell od_io od_constants proc~~read_ome_fmt~~UsesGraph proc~read_ome_fmt read_ome_fmt module~od_electronic od_electronic proc~read_ome_fmt->module~od_electronic module~od_cell od_cell proc~read_ome_fmt->module~od_cell module~od_io od_io proc~read_ome_fmt->module~od_io module~od_constants od_constants proc~read_ome_fmt->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Read a formatted Optical Matrix Elements file. Arguments None Called by proc~~read_ome_fmt~~CalledByGraph proc~read_ome_fmt read_ome_fmt program~od2od od2od program~od2od->proc~read_ome_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_ome_fmt Source Code subroutine read_ome_fmt () !! Read a formatted Optical Matrix Elements file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , optical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string , string2 integer :: ik , is , ib , i , jb , ome_unit = 6 write ( stdout , * ) \" Read a formatted ome file. \" if (. not . allocated ( optical_mat )) then write ( stdout , * ) \" Allocating optical_mat.\" allocate ( optical_mat ( nbands , nbands , 3 , nkpoints , nspins )) end if open ( unit = ome_unit , form = 'formatted' , recl = 1073741824 , file = trim ( seedname ) // \".ome_fmt\" ) ! Total number of elements of ome write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * nbands * nbands , trim ( format_precision ) ! write(stdout,*) string ! write(string,'(a)') trim(format_precision) read ( ome_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( ome_unit , '(a80)' ) omefile_header ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins read ( ome_unit , '(' // trim ( string ) // ')' ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), & & jb = 1 , nbands ), i = 1 , 3 ) end do end do optical_mat = optical_mat * ( bohr2ang * H2eV ) close ( unit = ome_unit ) write ( stdout , * ) trim ( seedname ) // \".ome_fmt\" // \"--> Formatted ome sucessfully read. \" end subroutine read_ome_fmt","tags":"","loc":"proc/read_ome_fmt.html"},{"title":"read_pdos_bin – OptaDOS","text":"public  subroutine read_pdos_bin() Wrapper to read a pdos binary file. Useful to keep the code tidy. Arguments None Calls proc~~read_pdos_bin~~CallsGraph proc~read_pdos_bin read_pdos_bin proc~elec_pdos_read elec_pdos_read proc~read_pdos_bin->proc~elec_pdos_read proc~io_file_unit io_file_unit proc~elec_pdos_read->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_pdos_read->interface~comms_bcast interface~comms_recv comms_recv proc~elec_pdos_read->interface~comms_recv interface~comms_send comms_send proc~elec_pdos_read->interface~comms_send proc~io_error io_error proc~elec_pdos_read->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_pdos_bin~~CalledByGraph proc~read_pdos_bin read_pdos_bin program~od2od od2od program~od2od->proc~read_pdos_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_pdos_bin Source Code subroutine read_pdos_bin () !! Wrapper to read a pdos binary file. Useful to keep the code tidy. implicit none write ( stdout , * ) \" Read a binary pdos file.\" call elec_pdos_read () end subroutine read_pdos_bin","tags":"","loc":"proc/read_pdos_bin.html"},{"title":"read_pdos_fmt – OptaDOS","text":"public  subroutine read_pdos_fmt() Uses od_electronic od_comms od_io od_cell proc~~read_pdos_fmt~~UsesGraph proc~read_pdos_fmt read_pdos_fmt module~od_electronic od_electronic proc~read_pdos_fmt->module~od_electronic module~od_comms od_comms proc~read_pdos_fmt->module~od_comms module~od_io od_io proc~read_pdos_fmt->module~od_io module~od_cell od_cell proc~read_pdos_fmt->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Read a formatted pdos file. Arguments None Calls proc~~read_pdos_fmt~~CallsGraph proc~read_pdos_fmt read_pdos_fmt proc~io_file_unit io_file_unit proc~read_pdos_fmt->proc~io_file_unit proc~io_error io_error proc~read_pdos_fmt->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_pdos_fmt~~CalledByGraph proc~read_pdos_fmt read_pdos_fmt program~od2od od2od program~od2od->proc~read_pdos_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_pdos_fmt Source Code subroutine read_pdos_fmt () !! Read a formatted pdos file. use od_electronic , only : pdos_mwab , nbands_occ , pdos_orbital , nspins , pdos_weights use od_cell , only : nkpoints , kpoint_r , num_kpoints_on_node use od_io , only : stdout , seedname , io_file_unit use od_comms , only : my_node_id implicit none integer :: ik , is , ib , idummy , ierr , io integer :: pdos_in_unit character ( len = 80 ) :: string , dummy , string2 real ( dp ) :: file_version write ( stdout , * ) \" Read a formatted pdos file.\" !-------------------------------------------------------------------------! ! R E A D   T H E   D A T A   H E A D E R file_version = 1.0_dp pdos_in_unit = io_file_unit () open ( unit = pdos_in_unit , file = trim ( seedname ) // \".pdos_fmt\" , form = 'formatted' ) read ( pdos_in_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( pdos_in_unit , '(a80)' ) pdosfile_header read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % nkpoints read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % nspins read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % norbitals read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % nbands !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%nkpoints= \",pdos_mwab%nkpoints !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%nspins= \",pdos_mwab%nspins !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%norbitals= \",pdos_mwab%norbitals !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%nbands= \",pdos_mwab%nbands write ( string , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , trim ( format_precision ) ! These should all be allocated! allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( nbands_occ ( 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate nbands_occ\" allocate ( pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate pdos_weights\" read ( pdos_in_unit , '(a60)' ) dummy read ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit , '(a60)' ) dummy read ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit , '(a60)' ) dummy read ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A ! These should already be alloacted ! allocate(nbands_occ(1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate nbands_occ\" ! allocate(pdos_weights(1:pdos_mwab%norbitals,1:pdos_mwab%nbands, & !     1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate pdos_weights\" do ik = 1 , nkpoints ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit , '(i6,3' // trim ( format_precision ) // ')' ) idummy , kpoint_r (:, ik ) do is = 1 , pdos_mwab % nspins read ( pdos_in_unit , '(i6)' ) idummy ! this is the spin number read ( pdos_in_unit , '(i6)' ) nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) !      write(stdout,*) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" !      write(stdout,*) \" DEBUG:\", ib, ik, is !      write(stdout,*) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" read ( pdos_in_unit , '(' // trim ( string2 ) // ')' ) ( pdos_weights ( io , ib , ik , is ), io = 1 , pdos_mwab % norbitals ) end do end do end do close ( pdos_in_unit ) write ( stdout , * ) \" \" // trim ( seedname ) // \".pdos_fmt\" // \"--> Formatted pdos sucessfully read. \" end subroutine read_pdos_fmt","tags":"","loc":"proc/read_pdos_fmt.html"},{"title":"report_arraysize – OptaDOS","text":"public  subroutine report_arraysize() Uses od_electronic od_io od_cell proc~~report_arraysize~~UsesGraph proc~report_arraysize report_arraysize module~od_electronic od_electronic proc~report_arraysize->module~od_electronic module~od_io od_io proc~report_arraysize->module~od_io module~od_cell od_cell proc~report_arraysize->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write to stdout some info on the size of the arrays we're using. These\nare normally found in the .bands file. Arguments None Called by proc~~report_arraysize~~CalledByGraph proc~report_arraysize report_arraysize proc~get_band_energy get_band_energy proc~get_band_energy->proc~report_arraysize program~od2od od2od program~od2od->proc~get_band_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code report_arraysize Source Code subroutine report_arraysize () !! Write to stdout some info on the size of the arrays we're using. These !! are normally found in the .bands file. use od_electronic , only : nspins , nbands use od_cell , only : nkpoints use od_io , only : stdout implicit none write ( stdout , '(a40,i5)' ) \" Number of kpoints : \" , nkpoints write ( stdout , '(a40,i5)' ) \" Number of bands : \" , nbands write ( stdout , '(a40,i5)' ) \" Number of spins : \" , nspins end subroutine report_arraysize","tags":"","loc":"proc/report_arraysize.html"},{"title":"slice_an_ome – OptaDOS","text":"public  subroutine slice_an_ome() Uses od_electronic od_cell od_io od_constants proc~~slice_an_ome~~UsesGraph proc~slice_an_ome slice_an_ome module~od_electronic od_electronic proc~slice_an_ome->module~od_electronic module~od_cell od_cell proc~slice_an_ome->module~od_cell module~od_io od_io proc~slice_an_ome->module~od_io module~od_constants od_constants proc~slice_an_ome->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This routine takes OptaDOS's internal representation of an ome and\nputs its diagonal into its internal representation of a dome.\nIt's useful for testing. Arguments None Called by proc~~slice_an_ome~~CalledByGraph proc~slice_an_ome slice_an_ome program~od2od od2od program~od2od->proc~slice_an_ome Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slice_an_ome Source Code subroutine slice_an_ome () !! This routine takes OptaDOS's internal representation of an ome and !! puts its diagonal into its internal representation of a dome. !! It's useful for testing. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient , optical_mat implicit none integer :: loop !! Loop variable write ( stdout , * ) \" Slicing an ome into a dome.\" if (. not . allocated ( band_gradient )) then write ( stdout , * ) \" Allocating band_gradient\" allocate ( band_gradient ( nbands , 3 , nkpoints , nspins )) end if do loop = 1 , nbands band_gradient ( loop , :, :, :) = real ( optical_mat ( loop , loop , :, :, :), dp ) end do end subroutine slice_an_ome","tags":"","loc":"proc/slice_an_ome.html"},{"title":"write_dome_bin – OptaDOS","text":"public  subroutine write_dome_bin() Uses od_electronic od_cell od_io od_constants proc~~write_dome_bin~~UsesGraph proc~write_dome_bin write_dome_bin module~od_electronic od_electronic proc~write_dome_bin->module~od_electronic module~od_cell od_cell proc~write_dome_bin->module~od_cell module~od_io od_io proc~write_dome_bin->module~od_io module~od_constants od_constants proc~write_dome_bin->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a diagonal ome file. Arguments None Called by proc~~write_dome_bin~~CalledByGraph proc~write_dome_bin write_dome_bin program~od2od od2od program~od2od->proc~write_dome_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_dome_bin Source Code subroutine write_dome_bin () !! Write a diagonal ome file. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version integer :: ik , is , ib , i , jb , dome_unit = 6 write ( stdout , * ) \" Write a binary dome file.\" open ( unit = dome_unit , form = 'unformatted' , file = trim ( outseedname ) // \".dome_bin\" ) band_gradient = band_gradient / ( bohr2ang * H2eV ) write ( dome_unit ) file_version write ( dome_unit ) adjustl ( domefile_header ) do ik = 1 , nkpoints do is = 1 , nspins write ( dome_unit ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), & & i = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written a binary dome file --> \" // trim ( outseedname ) // \".dome_bin\" end subroutine write_dome_bin","tags":"","loc":"proc/write_dome_bin.html"},{"title":"write_dome_fmt – OptaDOS","text":"public  subroutine write_dome_fmt() Uses od_electronic od_cell od_io od_constants proc~~write_dome_fmt~~UsesGraph proc~write_dome_fmt write_dome_fmt module~od_electronic od_electronic proc~write_dome_fmt->module~od_electronic module~od_cell od_cell proc~write_dome_fmt->module~od_cell module~od_io od_io proc~write_dome_fmt->module~od_io module~od_constants od_constants proc~write_dome_fmt->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a diagonal ome formatted file. Arguments None Called by proc~~write_dome_fmt~~CalledByGraph proc~write_dome_fmt write_dome_fmt program~od2od od2od program~od2od->proc~write_dome_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_dome_fmt Source Code subroutine write_dome_fmt () !! Write a diagonal ome formatted file. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , dome_unit = 6 write ( stdout , * ) \" Write a formatted ome file.\" open ( unit = dome_unit , form = 'formatted' , file = trim ( outseedname ) // \".dome_fmt\" ) write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * nbands , trim ( format_precision ) write ( dome_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( dome_unit , '(a80)' ) adjustl ( domefile_header ) band_gradient = band_gradient / ( bohr2ang * H2eV ) do ik = 1 , nkpoints do is = 1 , nspins write ( dome_unit , '(' // trim ( string ) // ')' ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), & i = 1 , 3 ) end do end do close ( unit = dome_unit ) write ( stdout , * ) \" Sucesfully written a formatted dome file --> \" // trim ( outseedname ) // \".dome_fmt\" end subroutine write_dome_fmt","tags":"","loc":"proc/write_dome_fmt.html"},{"title":"write_elnes_bin – OptaDOS","text":"public  subroutine write_elnes_bin() Uses od_electronic od_io od_cell proc~~write_elnes_bin~~UsesGraph proc~write_elnes_bin write_elnes_bin module~od_electronic od_electronic proc~write_elnes_bin->module~od_electronic module~od_io od_io proc~write_elnes_bin->module~od_io module~od_cell od_cell proc~write_elnes_bin->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Writes a binary elnes file. Arguments None Calls proc~~write_elnes_bin~~CallsGraph proc~write_elnes_bin write_elnes_bin proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~write_elnes_bin->proc~elec_elnes_find_channel_numbers proc~io_file_unit io_file_unit proc~write_elnes_bin->proc~io_file_unit selectcase selectcase proc~elec_elnes_find_channel_numbers->selectcase proc~io_error io_error proc~elec_elnes_find_channel_numbers->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_elnes_bin~~CalledByGraph proc~write_elnes_bin write_elnes_bin program~od2od od2od program~od2od->proc~write_elnes_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_elnes_bin Source Code subroutine write_elnes_bin () !! Writes a binary elnes file. use od_electronic , only : elec_elnes_find_channel_numbers , elnes_orbital ,& & elnes_mat , elnes_mwab use od_cell , only : num_kpoints_on_node use od_io , only : io_file_unit implicit none real ( dp ) :: file_version = 1.0_dp !! The file verioson format to write. Currently we're on version 1. integer :: ik , is , ib , iorb , indx !! Loop variables integer :: elnes_unit !! File unit number to write to. write ( stdout , * ) \" Write a binary elnes file.\" !write !! Some headers here? ! CASTEP (hence the bin file) and OptaDOS think about am_channel numbers ! differently. To keep consistent we convert to CASTEP's numbering scheme ! before we write out. call elec_elnes_find_channel_numbers () elnes_unit = io_file_unit () open ( unit = elnes_unit , file = trim ( outseedname ) // \".elnes_bin\" , form = 'unformatted' ) write ( elnes_unit ) file_version write ( elnes_unit ) adjustl ( elnesfile_header ) write ( elnes_unit ) elnes_mwab % norbitals write ( elnes_unit ) elnes_mwab % nbands write ( elnes_unit ) elnes_mwab % nkpoints write ( elnes_unit ) elnes_mwab % nspins ! write(string,'(i7,\"(1x,\",a,\")\")') elnes_mwab%norbitals,\"i5\" ! write(string2,'(i7,\"(1x,\",a,\")\")') elnes_mwab%norbitals*elnes_mwab%nbands*3, trim(format_precision) write ( elnes_unit ) elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) write ( elnes_unit ) elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) write ( elnes_unit ) elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) write ( elnes_unit ) elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , elnes_mwab % nspins write ( elnes_unit ) ((( elnes_mat ( iorb , ib , indx , ik , is ), iorb = 1 , elnes_mwab % norbitals ), & ib = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written a binary elnes file --> \" // trim ( outseedname ) // \".elnes_bin\" close ( elnes_unit ) end subroutine write_elnes_bin","tags":"","loc":"proc/write_elnes_bin.html"},{"title":"write_elnes_fmt – OptaDOS","text":"public  subroutine write_elnes_fmt() Uses od_electronic od_io od_cell proc~~write_elnes_fmt~~UsesGraph proc~write_elnes_fmt write_elnes_fmt module~od_electronic od_electronic proc~write_elnes_fmt->module~od_electronic module~od_io od_io proc~write_elnes_fmt->module~od_io module~od_cell od_cell proc~write_elnes_fmt->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Soubroute to write a formatted elnes file. Arguments None Calls proc~~write_elnes_fmt~~CallsGraph proc~write_elnes_fmt write_elnes_fmt proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~write_elnes_fmt->proc~elec_elnes_find_channel_numbers proc~io_file_unit io_file_unit proc~write_elnes_fmt->proc~io_file_unit selectcase selectcase proc~elec_elnes_find_channel_numbers->selectcase proc~io_error io_error proc~elec_elnes_find_channel_numbers->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_elnes_fmt~~CalledByGraph proc~write_elnes_fmt write_elnes_fmt program~od2od od2od program~od2od->proc~write_elnes_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_elnes_fmt Source Code subroutine write_elnes_fmt () !! Soubroute to write a formatted elnes file. use od_electronic , only : elnes_mwab , elnes_orbital , elnes_mat , & & elec_elnes_find_channel_numbers use od_cell , only : num_kpoints_on_node use od_io , only : io_file_unit implicit none real ( dp ) :: file_version = 1.0_dp !! The file verioson format to write. Currently we're on version 1. integer :: elnes_unit !! File unit number to write to. integer :: ik , is , iorb , ib , indx !! Loop variables. character ( len = 80 ) :: string , string2 !! Tempory string manipulation variables. write ( stdout , * ) \" Write a formatted elnes file.\" ! CASTEP (hence the bin file) and OptaDOS think about am_channel numbers ! differently. To keep consistent we convert to CASTEP's numbering scheme ! before we write out. call elec_elnes_find_channel_numbers () elnes_unit = io_file_unit () open ( unit = elnes_unit , file = trim ( outseedname ) // \".elnes_fmt\" , form = 'formatted' ) write ( elnes_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( elnes_unit , '(a80)' ) adjustl ( elnesfile_header ) write ( elnes_unit , '(a20,1x,i5)' ) \"Norbitals\" , elnes_mwab % norbitals write ( elnes_unit , '(a20,1x,i5)' ) \"Nbands\" , elnes_mwab % nbands write ( elnes_unit , '(a20,1x,i5)' ) \"Nkpoints\" , elnes_mwab % nkpoints write ( elnes_unit , '(a20,1x,i5)' ) \"Nspins\" , elnes_mwab % nspins write ( string , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals * elnes_mwab % nbands * 3 , trim ( format_precision ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Species_no\" , elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Rank\" , elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Shell\" , elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Am_channel\" , elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , elnes_mwab % nspins write ( elnes_unit , '(' // trim ( string2 ) // ')' ) ((( elnes_mat ( iorb , ib , indx , ik , is ), iorb = 1 , elnes_mwab % norbitals ), & ib = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do close ( elnes_unit ) write ( stdout , * ) \" Sucesfully written a formatted elnes file --> \" // trim ( outseedname ) // \".elnes_fmt\" end subroutine write_elnes_fmt","tags":"","loc":"proc/write_elnes_fmt.html"},{"title":"write_fem_bin – OptaDOS","text":"public  subroutine write_fem_bin() Uses od_electronic od_cell od_io od_constants proc~~write_fem_bin~~UsesGraph proc~write_fem_bin write_fem_bin module~od_electronic od_electronic proc~write_fem_bin->module~od_electronic module~od_cell od_cell proc~write_fem_bin->module~od_cell module~od_io od_io proc~write_fem_bin->module~od_io module~od_constants od_constants proc~write_fem_bin->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a binary ome file. Arguments None Called by proc~~write_fem_bin~~CalledByGraph proc~write_fem_bin write_fem_bin program~od2od od2od program~od2od->proc~write_fem_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_fem_bin Source Code subroutine write_fem_bin () !! Write a binary ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , foptical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , fem_unit = 6 write ( stdout , * ) \" Write a binary fem file.\" foptical_mat = foptical_mat / ( bohr2ang * H2eV ) open ( unit = fem_unit , form = 'unformatted' , file = trim ( outseedname ) // \".fem_bin\" ) write ( stdout , * ) \"-> Femfile_version \" , file_version write ( fem_unit ) file_version write ( stdout , * ) \"-> Femfile_header \" , trim ( femfile_header ) write ( fem_unit ) adjustl ( femfile_header ) ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins write ( fem_unit ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), & & jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written an unformatted fem file --> \" // trim ( outseedname ) // \".fem_bin\" end subroutine write_fem_bin","tags":"","loc":"proc/write_fem_bin.html"},{"title":"write_fem_fmt – OptaDOS","text":"public  subroutine write_fem_fmt() Uses od_electronic od_cell od_io od_constants proc~~write_fem_fmt~~UsesGraph proc~write_fem_fmt write_fem_fmt module~od_electronic od_electronic proc~write_fem_fmt->module~od_electronic module~od_cell od_cell proc~write_fem_fmt->module~od_cell module~od_io od_io proc~write_fem_fmt->module~od_io module~od_constants od_constants proc~write_fem_fmt->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a formatted ome file. Arguments None Called by proc~~write_fem_fmt~~CalledByGraph proc~write_fem_fmt write_fem_fmt program~od2od od2od program~od2od->proc~write_fem_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_fem_fmt Source Code subroutine write_fem_fmt () !! Write a formatted ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , foptical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , fem_unit = 6 write ( stdout , * ) \" Write a formatted .fem file. \" foptical_mat = foptical_mat / ( bohr2ang * H2eV ) open ( unit = fem_unit , form = 'formatted' , file = trim ( outseedname ) // \".fem_fmt\" ) write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * ( nbands + 1 ) * ( nbands + 1 ), trim ( format_precision ) !   write(stdout,*) string write ( stdout , '(a80)' ) femfile_header write ( stdout , '(a80)' ) adjustl ( femfile_header ) write ( fem_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( fem_unit , '(a80)' ) adjustl ( femfile_header ) do ik = 1 , nkpoints do is = 1 , nspins write ( fem_unit , '(' // trim ( string ) // ')' ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), & & jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do close ( unit = fem_unit ) write ( stdout , * ) \" Sucesfully written a formatted fem file --> \" // trim ( outseedname ) // \".fem_fmt\" end subroutine write_fem_fmt","tags":"","loc":"proc/write_fem_fmt.html"},{"title":"write_ome_bin – OptaDOS","text":"public  subroutine write_ome_bin() Uses od_electronic od_cell od_io od_constants proc~~write_ome_bin~~UsesGraph proc~write_ome_bin write_ome_bin module~od_electronic od_electronic proc~write_ome_bin->module~od_electronic module~od_cell od_cell proc~write_ome_bin->module~od_cell module~od_io od_io proc~write_ome_bin->module~od_io module~od_constants od_constants proc~write_ome_bin->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a binary ome file. Arguments None Called by proc~~write_ome_bin~~CalledByGraph proc~write_ome_bin write_ome_bin program~od2od od2od program~od2od->proc~write_ome_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_ome_bin Source Code subroutine write_ome_bin () !! Write a binary ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , optical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , ome_unit = 6 write ( stdout , * ) \" Write a binary ome file.\" optical_mat = optical_mat / ( bohr2ang * H2eV ) open ( unit = ome_unit , form = 'unformatted' , file = trim ( outseedname ) // \".ome_bin\" ) write ( stdout , * ) \"-> Omefile_version \" , file_version write ( ome_unit ) file_version write ( stdout , * ) \"-> Omefile_header \" , trim ( omefile_header ) write ( ome_unit ) adjustl ( omefile_header ) ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins write ( ome_unit ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), & & jb = 1 , nbands ), i = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written an unformatted ome file --> \" // trim ( outseedname ) // \".ome_bin\" end subroutine write_ome_bin","tags":"","loc":"proc/write_ome_bin.html"},{"title":"write_ome_fmt – OptaDOS","text":"public  subroutine write_ome_fmt() Uses od_electronic od_cell od_io od_constants proc~~write_ome_fmt~~UsesGraph proc~write_ome_fmt write_ome_fmt module~od_electronic od_electronic proc~write_ome_fmt->module~od_electronic module~od_cell od_cell proc~write_ome_fmt->module~od_cell module~od_io od_io proc~write_ome_fmt->module~od_io module~od_constants od_constants proc~write_ome_fmt->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a formatted ome file. Arguments None Called by proc~~write_ome_fmt~~CalledByGraph proc~write_ome_fmt write_ome_fmt program~od2od od2od program~od2od->proc~write_ome_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_ome_fmt Source Code subroutine write_ome_fmt () !! Write a formatted ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , optical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , ome_unit = 6 write ( stdout , * ) \" Write a formatted ome file. \" optical_mat = optical_mat / ( bohr2ang * H2eV ) open ( unit = ome_unit , form = 'formatted' , file = trim ( outseedname ) // \".ome_fmt\" ) write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * nbands * nbands , trim ( format_precision ) !   write(stdout,*) string write ( stdout , '(a80)' ) omefile_header write ( stdout , '(a80)' ) adjustl ( omefile_header ) write ( ome_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( ome_unit , '(a80)' ) adjustl ( omefile_header ) do ik = 1 , nkpoints do is = 1 , nspins write ( ome_unit , '(' // trim ( string ) // ')' ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), & & jb = 1 , nbands ), i = 1 , 3 ) end do end do close ( unit = ome_unit ) write ( stdout , * ) \" Sucesfully written a formatted ome file --> \" // trim ( outseedname ) // \".ome_fmt\" end subroutine write_ome_fmt","tags":"","loc":"proc/write_ome_fmt.html"},{"title":"write_pdos_bin – OptaDOS","text":"public  subroutine write_pdos_bin() Uses od_electronic od_cell od_io od_constants proc~~write_pdos_bin~~UsesGraph proc~write_pdos_bin write_pdos_bin module~od_electronic od_electronic proc~write_pdos_bin->module~od_electronic module~od_cell od_cell proc~write_pdos_bin->module~od_cell module~od_io od_io proc~write_pdos_bin->module~od_io module~od_constants od_constants proc~write_pdos_bin->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a binary pdos file Arguments None Calls proc~~write_pdos_bin~~CallsGraph proc~write_pdos_bin write_pdos_bin proc~io_file_unit io_file_unit proc~write_pdos_bin->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_pdos_bin~~CalledByGraph proc~write_pdos_bin write_pdos_bin program~od2od od2od program~od2od->proc~write_pdos_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_pdos_bin Source Code subroutine write_pdos_bin () !! Write a binary pdos file use od_constants , only : dp use od_electronic , only : pdos_mwab , nbands_occ , pdos_orbital , nspins , pdos_weights use od_cell , only : nkpoints , kpoint_r use od_io , only : io_file_unit implicit none !  integer,parameter:: num_popn_orb=1          ! Number of LCAO projectors ! integer,parameter:: max_eigenv=1       ! Number of bands included in matrix elements real ( dp ) :: file_version = 1.0_dp ! File version ! integer:: species(1:num_popn_orb)! Atomic species associated with each projector ! integer:: ion(1:num_popn_orb)    ! Ion associated with each projector ! integer:: am_channel(1:num_popn_orb)     ! Angular momentum channel ! integer:: num_eigenvalues(1:nspins)   ! Number of eigenvalues per spin channel ! real(dp):: kpoint_positions(1:nkpoints,1:3) ! k_x, k_y, k_z in fractions of BZ ! real(dp):: pdos_weights(1:num_popn_orb,max_eigenv,num_kpoints,num_spins)!Matrix elements !character(len=80):: file_header ! File header comment integer :: ik , is , ib , pdos_file , io , idex pdos_file = io_file_unit () open ( unit = pdos_file , file = trim ( outseedname ) // \".pdos_bin\" , form = 'unformatted' ) write ( stdout , * ) \" Write a binary pdos file.\" write ( pdos_file ) file_version write ( pdos_file ) adjustl ( pdosfile_header ) write ( pdos_file ) pdos_mwab % nkpoints write ( pdos_file ) pdos_mwab % nspins write ( pdos_file ) pdos_mwab % norbitals write ( pdos_file ) pdos_mwab % nbands write ( pdos_file ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) write ( pdos_file ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) write ( pdos_file ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) write ( stdout , * ) pdos_mwab % nkpoints write ( stdout , * ) pdos_mwab % nspins write ( stdout , * ) pdos_mwab % norbitals write ( stdout , * ) pdos_mwab % nbands write ( stdout , * ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) write ( stdout , * ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) write ( stdout , * ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) do ik = 1 , pdos_mwab % nkpoints write ( stdout , * ) \"loop\" , ik write ( pdos_file ) ik , ( kpoint_r ( idex , ik ), idex = 1 , 3 ) do is = 1 , pdos_mwab % nspins write ( pdos_file ) is write ( pdos_file ) nbands_occ ( ik , is ) write ( stdout , * ) is , nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) write ( pdos_file ) ( pdos_weights ( io , ib , ik , is ), io = 1 , pdos_mwab % norbitals ) end do end do end do write ( stdout , * ) \" Sucesfully written a binary pdos file --> \" // trim ( outseedname ) // \".pdos_bin\" end subroutine write_pdos_bin","tags":"","loc":"proc/write_pdos_bin.html"},{"title":"write_pdos_fmt – OptaDOS","text":"public  subroutine write_pdos_fmt() Uses od_electronic od_io od_cell proc~~write_pdos_fmt~~UsesGraph proc~write_pdos_fmt write_pdos_fmt module~od_electronic od_electronic proc~write_pdos_fmt->module~od_electronic module~od_io od_io proc~write_pdos_fmt->module~od_io module~od_cell od_cell proc~write_pdos_fmt->module~od_cell module~od_constants od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Write a formatted pdos file. Arguments None Calls proc~~write_pdos_fmt~~CallsGraph proc~write_pdos_fmt write_pdos_fmt proc~io_file_unit io_file_unit proc~write_pdos_fmt->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_pdos_fmt~~CalledByGraph proc~write_pdos_fmt write_pdos_fmt program~od2od od2od program~od2od->proc~write_pdos_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_pdos_fmt Source Code subroutine write_pdos_fmt () !! Write a formatted pdos file. use od_electronic , only : pdos_mwab , nbands_occ , pdos_orbital , nspins , pdos_weights use od_cell , only : nkpoints , kpoint_r use od_io , only : stdout , seedname , io_file_unit implicit none integer :: ik , is , ib integer :: pdos_in_unit character ( len = 80 ) :: string , string2 real ( dp ) :: file_version = 1.0_dp write ( stdout , * ) \" Write a formatted pdos file.\" !-------------------------------------------------------------------------! ! W R I T E   T H E   D A T A   H E A D E R pdos_in_unit = io_file_unit () open ( unit = pdos_in_unit , file = trim ( outseedname ) // \".pdos_fmt\" , form = 'formatted' ) write ( pdos_in_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( pdos_in_unit , '(a80)' ) adjustl ( pdosfile_header ) write ( pdos_in_unit , '(a10, i6)' ) \"Kpoints\" , pdos_mwab % nkpoints write ( pdos_in_unit , '(a10, i6)' ) \"Spins\" , pdos_mwab % nspins write ( pdos_in_unit , '(a10, i6)' ) \"Orbials\" , pdos_mwab % norbitals write ( pdos_in_unit , '(a10, i6)' ) \"Bands\" , pdos_mwab % nbands !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%nkpoints= \",pdos_mwab%nkpoints !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%nspins= \",pdos_mwab%nspins !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%norbitals= \",pdos_mwab%norbitals !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%nbands= \",pdos_mwab%nbands ! These should all be allocated! !allocate(pdos_orbital%species_no(pdos_mwab%norbitals),stat=ierr) !if(ierr/=0) call io_error(\" Error : cannot allocate pdos_orbital\") !allocate(pdos_orbital%rank_in_species(pdos_mwab%norbitals),stat=ierr) !if(ierr/=0) call io_error(\" Error : cannot allocate pdos_orbital\") !allocate(pdos_orbital%am_channel(pdos_mwab%norbitals),stat=ierr) !if(ierr/=0) call io_error(\" Error : cannot allocate pdos_orbital\") write ( string , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , trim ( format_precision ) write ( pdos_in_unit , '(a60)' ) \" Species number for each orbital\" write ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) write ( pdos_in_unit , '(a60)' ) \" Species rank for each orbital\" write ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) write ( pdos_in_unit , '(a60)' ) \" AM channel for each orbital\" write ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A ! These should already be alloacted ! allocate(nbands_occ(1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate nbands_occ\" ! allocate(pdos_weights(1:pdos_mwab%norbitals,1:pdos_mwab%nbands, & !     1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate pdos_weights\" do ik = 1 , nkpoints ! The kpoint number, followed by the kpoint-vector write ( pdos_in_unit , '(i6,3' // trim ( format_precision ) // ')' ) ik , kpoint_r (:, ik ) do is = 1 , pdos_mwab % nspins write ( pdos_in_unit , '(i6)' ) is ! this is the spin number write ( pdos_in_unit , '(i6)' ) nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) !      write(stdout,*) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" !      write(stdout,*) \" DEBUG:\", ib, ik, is !      write(stdout,*) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" write ( pdos_in_unit , '(' // trim ( string2 ) // ')' ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) end do end do end do close ( pdos_in_unit ) write ( stdout , * ) \" Sucesfully written a formtted pdos file --> \" // trim ( outseedname ) // \".dome_bin\" end subroutine write_pdos_fmt","tags":"","loc":"proc/write_pdos_fmt.html"},{"title":"write_read_file – OptaDOS","text":"public  subroutine write_read_file() Noddy routine to prettify output Arguments None Called by proc~~write_read_file~~CalledByGraph proc~write_read_file write_read_file program~od2od od2od program~od2od->proc~write_read_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_read_file Source Code subroutine write_read_file () !! Noddy routine to prettify output implicit none write ( stdout , * ) write ( stdout , * ) \"+-------------------------------- Read File ---------------------------------+\" end subroutine write_read_file","tags":"","loc":"proc/write_read_file.html"},{"title":"core_calculate – OptaDOS","text":"public  subroutine core_calculate() Uses od_parameters od_comms od_dos_utils od_electronic od_io proc~~core_calculate~~UsesGraph proc~core_calculate core_calculate module~od_parameters od_parameters proc~core_calculate->module~od_parameters module~od_comms od_comms proc~core_calculate->module~od_comms module~od_io od_io proc~core_calculate->module~od_io module~od_dos_utils od_dos_utils proc~core_calculate->module~od_dos_utils module~od_electronic od_electronic proc~core_calculate->module~od_electronic module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~core_calculate~~CallsGraph proc~core_calculate core_calculate proc~elec_read_elnes_mat elec_read_elnes_mat proc~core_calculate->proc~elec_read_elnes_mat proc~dos_utils_set_efermi dos_utils_set_efermi proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate dos_utils_calculate proc~core_calculate->proc~dos_utils_calculate proc~io_time io_time proc~elec_read_elnes_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_elnes_mat->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_read_elnes_mat->interface~comms_bcast interface~comms_send comms_send proc~elec_read_elnes_mat->interface~comms_send proc~io_error io_error proc~elec_read_elnes_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_elnes_mat->interface~comms_recv proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_set_efermi->proc~io_error interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_calculate->proc~io_time proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_calculate->proc~io_error proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate->proc~elec_read_band_gradient proc~elec_elnes_find_channel_names->proc~io_error proc~dos_utils_merge->interface~comms_reduce proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->interface~comms_send proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~core_calculate~~CalledByGraph proc~core_calculate core_calculate program~optados optados program~optados->proc~core_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code core_calculate Source Code subroutine core_calculate use od_electronic , only : elec_read_elnes_mat , efermi_set use od_dos_utils , only : dos_utils_calculate , dos_utils_set_efermi , & & dos_utils_compute_bandgap use od_comms , only : on_root use od_io , only : stdout use od_parameters , only : core_LAI_broadening , LAI_gaussian , LAI_lorentzian , & & set_efermi_zero , LAI_lorentzian_scale , core_chemical_shift implicit none if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                            Core Loss Calculation                           +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if ! read in the core matrix elements from disk call elec_read_elnes_mat !    (elnes_mat(orb,nb,indx,nk,ns),indx=1,3) if (. not . efermi_set ) call dos_utils_set_efermi call core_prepare_matrix_elements call dos_utils_calculate ( matrix_weights , weighted_dos ) ! Lifetime and instrumental broadening if ( core_LAI_broadening . eqv . . true .) then allocate ( weighted_dos_broadened ( size ( weighted_dos , 1 ), size ( weighted_dos , 2 ), size ( weighted_dos , 3 ))) weighted_dos_broadened = 0.0_dp if ( LAI_lorentzian . or . ( LAI_lorentzian_scale . gt . 0.00001_dp )) call core_lorentzian if ( LAI_gaussian ) call core_gaussian end if if ( set_efermi_zero . and . . not . efermi_set ) call dos_utils_set_efermi if ( on_root ) then call write_core end if end subroutine core_calculate","tags":"","loc":"proc/core_calculate.html"},{"title":"xmgu_axis – OptaDOS","text":"public  subroutine xmgu_axis(unit, axis, label) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character, intent(in) :: axis character, intent(in) :: label Called by proc~~xmgu_axis~~CalledByGraph proc~xmgu_axis xmgu_axis proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_axis proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_axis proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_axis Source Code subroutine xmgu_axis ( unit , axis , label ) !==================================================================! implicit none integer , intent ( in ) :: unit character ( * ), intent ( in ) :: label character ( * ), intent ( in ) :: axis character ( 5 ) :: axis_name if ( axis == \"x\" ) then axis_name = \"xaxis\" elseif ( axis == \"y\" ) then axis_name = \"yaxis\" end if write ( unit , * ) '@    ' // trim ( axis_name ) // ' on' write ( unit , * ) '@    ' // trim ( axis_name ) // ' type zero false' write ( unit , * ) '@    ' // trim ( axis_name ) // ' offset 0.000000 , 0.000000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar on' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar linestyle 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar linewidth 2.5' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label \"' // trim ( label ) // '\"' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label layout para' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label place auto' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label char size 1.000000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label font 4' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label place normal' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick on' write ( unit , * ) '@ autoticks' !  write(unit,*)'@    '//trim(axis_name)//' tick major 10' !  write(unit,*)'@    '//trim(axis_name)//' tick minor ticks 1' !  write(unit,*)'@    '//trim(axis_name)//' tick default 6' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick place rounded true' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick in' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major size 1.000000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major linewidth 2.5' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major linestyle 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major grid off' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor linewidth 2.5' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor linestyle 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor grid off' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor size 0.500000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' ticklabel on' write ( unit , * ) '@    ' // trim ( axis_name ) // ' ticklabel format general' write ( unit , * ) '@    ' // trim ( axis_name ) // ' ticklabel font 4' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel prec 5' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel formula \"\"' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel append \"\"' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel prepend \"\"' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel angle 0' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel skip 0' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel stagger 0' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel place normal' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel offset auto' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel offset 0.000000 , 0.010000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel start type auto' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel start 0.000000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel stop type auto' ! 1write(unit,*)'@    '//trim(axis_name)//' ticklabel stop 0.000000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel char size 1.000000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel color 1' ! write(unit,*)'@    '//trim(axis_name)//' tick place both' ! write(unit,*)'@    '//trim(axis_name)//' tick spec type none' !    write(unit,*) trim(axis_name)//\" type zero true\" !    write(unit,*) trim(axis_name)//\" bar on\" !    write(unit,*) trim(axis_name)//\" bar color 1\" !    write(unit,*) trim(axis_name)//\" bar linestyle 1\" !    write(unit,*) trim(axis_name)//\" bar linewidth 2.5\" !    write(unit,*) trim(axis_name)//' label \"'//trim(label)//'\"' !    write(unit,*) trim(axis_name)//\" label layout para\" !    write(unit,*) trim(axis_name)//\" label place auto\" !    write(unit,*) trim(axis_name)//\" label char size 1.000000\" !    write(unit,*) trim(axis_name)//\" label font 4\" !    write(unit,*) trim(axis_name)//\" label color 1\" !    write(unit,*) trim(axis_name)//\" label place normal\" !    write(unit,*) trim(axis_name)//\" tick on\" !    write(unit,*) trim(axis_name)//\" tick major 0.2\" !    write(unit,*) trim(axis_name)//\" tick minor ticks 1\" !    write(unit,*) trim(axis_name)//\" tick default 6\" !    write(unit,*) trim(axis_name)//\" tick place rounded true\" !    write(unit,*) trim(axis_name)//\" tick in\" !    write(unit,*) trim(axis_name)//\" tick major size 1.000000\" !    write(unit,*) trim(axis_name)//\" tick major color 1\" !    write(unit,*) trim(axis_name)//\" tick major linewidth 2.5\" !    write(unit,*) trim(axis_name)//\" tick major linestyle 1\" !    write(unit,*) trim(axis_name)//\" tick major grid off\" !    write(unit,*) trim(axis_name)//\" tick minor color 1\" !    write(unit,*) trim(axis_name)//\" tick minor linewidth 2.5\" !    write(unit,*) trim(axis_name)//\" tick minor linestyle 1\" !    write(unit,*) trim(axis_name)//\" tick minor grid off\" !    write(unit,*) trim(axis_name)//\" tick minor size 0.500000\" !    write(unit,*) trim(axis_name)//\" ticklabel on\" !    write(unit,*) trim(axis_name)//\" ticklabel format general\" !    write(unit,*) trim(axis_name)//\" ticklabel prec 5\" !    write(unit,*) trim(axis_name)//\" ticklabel start type spec\" !    write(unit,*) trim(axis_name)//\" ticklabel start 0.200000\" !    write(unit,*) trim(axis_name)//\" ticklabel stop type spec\" !   write(unit,*) trim(axis_name)//\" ticklabel stop 0.800000\" !    write(unit,*) trim(axis_name)//\" ticklabel font 4\" end subroutine xmgu_axis","tags":"","loc":"proc/xmgu_axis.html"},{"title":"xmgu_data – OptaDOS","text":"public  subroutine xmgu_data(unit, field, x_data, y_data) Uses od_io od_constants proc~~xmgu_data~~UsesGraph proc~xmgu_data xmgu_data module~od_io od_io proc~xmgu_data->module~od_io module~od_constants od_constants proc~xmgu_data->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: field real(kind=dp), intent(in) :: x_data (:) real(kind=dp), intent(in) :: y_data (:) Calls proc~~xmgu_data~~CallsGraph proc~xmgu_data xmgu_data proc~io_error io_error proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~xmgu_data~~CalledByGraph proc~xmgu_data xmgu_data proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_data proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_data proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_data Source Code subroutine xmgu_data ( unit , field , x_data , y_data ) !==================================================================! use od_constants , only : dp use od_io , only : io_error implicit none integer , intent ( in ) :: unit integer , intent ( in ) :: field character ( 4 ) :: char_field real ( dp ), intent ( in ) :: x_data (:) real ( dp ), intent ( in ) :: y_data (:) integer :: i write ( char_field , '(I4)' ) field char_field = trim ( \"s\" // adjustl ( char_field )) write ( unit , * ) '@target G0.' // trim ( char_field ) write ( unit , * ) '@type xy' if ( size ( x_data , 1 ) . ne . size ( y_data , 1 )) call io_error ( \"xmgu_data: x and y axes have different number of elements\" ) do i = 1 , size ( x_data , 1 ) write ( unit , * ) x_data ( i ), y_data ( i ) end do write ( unit , * ) \"&\" end subroutine xmgu_data","tags":"","loc":"proc/xmgu_data.html"},{"title":"xmgu_data_header – OptaDOS","text":"public  subroutine xmgu_data_header(unit, field, colour, legend) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: field integer, intent(in) :: colour character, intent(in) :: legend Called by proc~~xmgu_data_header~~CalledByGraph proc~xmgu_data_header xmgu_data_header proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_data_header proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_data_header proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_data_header Source Code subroutine xmgu_data_header ( unit , field , colour , legend ) !==================================================================! integer , intent ( in ) :: unit integer , intent ( in ) :: field , colour character ( 4 ) :: char_field , char_colour character ( * ), intent ( in ) :: legend write ( char_field , '(I4)' ) field write ( char_colour , '(I4)' ) colour char_field = trim ( \"s\" // adjustl ( char_field )) write ( unit , * ) '@    ' // trim ( char_field ) // ' hidden false' write ( unit , * ) '@    ' // trim ( char_field ) // ' type xy' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol size 1.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol color ' // trim ( char_colour ) write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol fill color 2' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol fill pattern 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol linewidth 1.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol char 65' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol char font 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol skip 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' line type 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' line linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' line linewidth 2.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' line color  ' // trim ( char_colour ) write ( unit , * ) '@    ' // trim ( char_field ) // ' line pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' baseline type 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' baseline off' write ( unit , * ) '@    ' // trim ( char_field ) // ' dropline off' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill type 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill rule 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill color 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue off' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue type 2' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue char size 1.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue font 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue color 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue rot 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue format general' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue prec 3' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue prepend \"\"' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue append \"\"' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue offset 0.000000 , 0.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar on' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar place both' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar color 2' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar size 1.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar linewidth 1.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser linewidth 1.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser clip off' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser clip length 0.100000' write ( unit , * ) '@    ' // trim ( char_field ) // ' legend \"' // trim ( legend ) // '\"' ! write(unit,*) trim(char_field)//\" hidden false\" ! write(unit,*) trim(char_field)//\" type xy\" ! write(unit,*) trim(char_field)//\" symbol 9\" ! write(unit,*) trim(char_field)//\" symbol size 1.000000\" ! write(unit,*) trim(char_field)//\" symbol color \"//trim(char_colour) ! write(unit,*) trim(char_field)//\" symbol pattern 1\" ! write(unit,*) trim(char_field)//\" symbol fill color 4\" ! write(unit,*) trim(char_field)//\" symbol fill pattern 1\" ! write(unit,*) trim(char_field)//\" symbol linewidth 1.5\" ! write(unit,*) trim(char_field)//\" symbol linestyle 1\" ! write(unit,*) trim(char_field)//\" symbol char 65\" ! write(unit,*) trim(char_field)//\" symbol char font 0\" ! write(unit,*) trim(char_field)//\" symbol skip 0\" ! write(unit,*) trim(char_field)//\" line type 0\" ! write(unit,*) trim(char_field)//\" line linestyle 1\" ! write(unit,*) trim(char_field)//\" lyine linewidth 1.0\" !s0 legend  \"\" !s0 avalue on !s0 avalue type 4 !s0 avalue char size 0.80000 !s0 avalue font 4 !s0 avalue color 1 !s0 avalue rot 0 !s0 avalue format general !s0 avalue prec 4 !s0 avalue prepend \"\" !s0 avalue append \"\" !s0 avalue offset 0.000000 , 0.01000 end subroutine xmgu_data_header","tags":"","loc":"proc/xmgu_data_header.html"},{"title":"xmgu_legend – OptaDOS","text":"public  subroutine xmgu_legend(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Called by proc~~xmgu_legend~~CalledByGraph proc~xmgu_legend xmgu_legend proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_legend proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_legend proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_legend Source Code subroutine xmgu_legend ( unit ) !==================================================================! implicit none integer , intent ( in ) :: unit write ( unit , * ) '@    legend on' write ( unit , * ) '@    legend loctype view' write ( unit , * ) '@    legend 0.85, 0.8' write ( unit , * ) '@    legend box color 1' write ( unit , * ) '@    legend box pattern 1' write ( unit , * ) '@    legend box linewidth 2.0' write ( unit , * ) '@    legend box linestyle 1' write ( unit , * ) '@    legend box fill color 0' write ( unit , * ) '@    legend box fill pattern 1' write ( unit , * ) '@    legend font 4' write ( unit , * ) '@    legend char size 1.000000' write ( unit , * ) '@    legend color 1' write ( unit , * ) '@    legend length 4' write ( unit , * ) '@    legend vgap 1' write ( unit , * ) '@    legend hgap 1' write ( unit , * ) '@    legend invert false' end subroutine xmgu_legend","tags":"","loc":"proc/xmgu_legend.html"},{"title":"xmgu_setup – OptaDOS","text":"public  subroutine xmgu_setup(unit) Uses od_io proc~~xmgu_setup~~UsesGraph proc~xmgu_setup xmgu_setup module~od_io od_io proc~xmgu_setup->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Calls proc~~xmgu_setup~~CallsGraph proc~xmgu_setup xmgu_setup proc~io_date io_date proc~xmgu_setup->proc~io_date Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~xmgu_setup~~CalledByGraph proc~xmgu_setup xmgu_setup proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_setup proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_setup proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_setup Source Code subroutine xmgu_setup ( unit ) !==================================================================! use od_io , only : io_date implicit none integer , intent ( in ) :: unit character ( len = 9 ) :: ctime ! Temp. time string character ( len = 11 ) :: cdate ! Temp. date string call io_date ( cdate , ctime ) write ( unit , * ) '# Grace project file' write ( unit , * ) '# Autogenrated by OptaDOS on ' , cdate , ' at ' , ctime write ( unit , * ) '@version 50122' write ( unit , * ) '@page size 792, 612' write ( unit , * ) '@page scroll 5%' write ( unit , * ) '@page inout 5%' write ( unit , * ) '@link page off' write ( unit , * ) '@map font 0 to \"Times-Roman\", \"Times-Roman\"' write ( unit , * ) '@map font 1 to \"Times-Italic\", \"Times-Italic\"' write ( unit , * ) '@map font 2 to \"Times-Bold\", \"Times-Bold\"' write ( unit , * ) '@map font 3 to \"Times-BoldItalic\", \"Times-BoldItalic\"' write ( unit , * ) '@map font 4 to \"Helvetica\", \"Helvetica\"' write ( unit , * ) '@map font 5 to \"Helvetica-Oblique\", \"Helvetica-Oblique\"' write ( unit , * ) '@map font 6 to \"Helvetica-Bold\", \"Helvetica-Bold\"' write ( unit , * ) '@map font 7 to \"Helvetica-BoldOblique\", \"Helvetica-BoldOblique\"' write ( unit , * ) '@map font 8 to \"Courier\", \"Courier\"' write ( unit , * ) '@map font 9 to \"Courier-Oblique\", \"Courier-Oblique\"' write ( unit , * ) '@map font 10 to \"Courier-Bold\", \"Courier-Bold\"' write ( unit , * ) '@map font 11 to \"Courier-BoldOblique\", \"Courier-BoldOblique\"' write ( unit , * ) '@map font 12 to \"Symbol\", \"Symbol\"' write ( unit , * ) '@map font 13 to \"ZapfDingbats\", \"ZapfDingbats\"' write ( unit , * ) '@map color 0 to (255, 255, 255), \"white\"' write ( unit , * ) '@map color 1 to (0, 0, 0), \"black\"' write ( unit , * ) '@map color 2 to (255, 0, 0), \"red\"' write ( unit , * ) '@map color 3 to (0, 255, 0), \"green\"' write ( unit , * ) '@map color 4 to (0, 0, 255), \"blue\"' write ( unit , * ) '@map color 5 to (255, 255, 0), \"yellow\"' write ( unit , * ) '@map color 6 to (188, 143, 143), \"brown\"' write ( unit , * ) '@map color 7 to (220, 220, 220), \"grey\"' write ( unit , * ) '@map color 8 to (148, 0, 211), \"violet\"' write ( unit , * ) '@map color 9 to (0, 255, 255), \"cyan\"' write ( unit , * ) '@map color 10 to (255, 0, 255), \"magenta\"' write ( unit , * ) '@map color 11 to (255, 165, 0), \"orange\"' write ( unit , * ) '@map color 12 to (114, 33, 188), \"indigo\"' write ( unit , * ) '@map color 13 to (103, 7, 72), \"maroon\"' write ( unit , * ) '@map color 14 to (64, 224, 208), \"turquoise\"' write ( unit , * ) '@default linewidth 1.0' write ( unit , * ) '@default linestyle 1' write ( unit , * ) '@default color 1' write ( unit , * ) '@default pattern 1' write ( unit , * ) '@default font 0' write ( unit , * ) '@default char size 1.000000' write ( unit , * ) '@default symbol size 1.000000' write ( unit , * ) '@default sformat \"%.8g\"' write ( unit , * ) '@background color 0' write ( unit , * ) '@page background fill on' write ( unit , * ) '@g0 on' write ( unit , * ) '@g0 hidden false' write ( unit , * ) '@g0 type XY' write ( unit , * ) '@g0 stacked false' write ( unit , * ) '@g0 bar hgap 0.000000' write ( unit , * ) '@g0 fixedpoint off' write ( unit , * ) '@g0 fixedpoint type 0' write ( unit , * ) '@g0 fixedpoint xy 0.000000, 0.000000' write ( unit , * ) '@g0 fixedpoint format general general' write ( unit , * ) '@g0 fixedpoint prec 6, 6' !     write(unit,*) 'autoscale' !     write(unit,*) 'world xmin 0.0' !     write(unit,*) 'world xmax 1.0' !    write(unit,*) 'world ymax 0.1' !    write(unit,*) 'frame linestyle 1' !   write(unit,*) 'frame linewidth 2.5' !   write(unit,*) 'frame color 1' !   write(unit,*) 'frame pattern 1' !   write(unit,*) 'frame background color 0' !   write(unit,*) 'frame background pattern 0' !   write(unit,*) 'altxaxis  off' !   write(unit,*) 'altyaxis  off' end subroutine xmgu_setup","tags":"","loc":"proc/xmgu_setup.html"},{"title":"xmgu_subtitle – OptaDOS","text":"public  subroutine xmgu_subtitle(unit, subtitle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character, intent(in) :: subtitle Called by proc~~xmgu_subtitle~~CalledByGraph proc~xmgu_subtitle xmgu_subtitle proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_subtitle proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_subtitle proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_subtitle Source Code subroutine xmgu_subtitle ( unit , subtitle ) !==================================================================! implicit none integer , intent ( in ) :: unit character ( * ), intent ( in ) :: subtitle write ( unit , * ) '@    subtitle \"' // trim ( subtitle ) // '\"' write ( unit , * ) '@    subtitle font 4' write ( unit , * ) '@    subtitle size 1.000000' write ( unit , * ) '@    subtitle color 1' !   write(unit,*) 'subtitle '//trim(subtitle)//'\"' !   write(unit,*) \"subtitle font 4\" !   write(unit,*) \"subtitle size 1.000000\" !   write(unit,*) \"subtitle color 1\" end subroutine xmgu_subtitle","tags":"","loc":"proc/xmgu_subtitle.html"},{"title":"xmgu_title – OptaDOS","text":"public  subroutine xmgu_title(unit, min_x, max_x, min_y, max_y, title) Uses od_constants proc~~xmgu_title~~UsesGraph proc~xmgu_title xmgu_title module~od_constants od_constants proc~xmgu_title->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit real(kind=dp), intent(in) :: min_x real(kind=dp), intent(in) :: max_x real(kind=dp), intent(in) :: min_y real(kind=dp), intent(in) :: max_y character, intent(in) :: title Called by proc~~xmgu_title~~CalledByGraph proc~xmgu_title xmgu_title proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~xmgu_title proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_title proc~write_jdos write_jdos proc~write_jdos->proc~write_jdos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~jdos_calculate program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_title Source Code subroutine xmgu_title ( unit , min_x , max_x , min_y , max_y , title ) !==================================================================! use od_constants , only : dp implicit none integer , intent ( in ) :: unit character ( * ), intent ( in ) :: title real ( dp ), intent ( in ) :: min_x , max_x , min_y , max_y character ( 20 ) :: min_x_char , min_y_char , max_x_char , max_y_char write ( min_x_char , '(F20.6)' ) min_x write ( max_x_char , '(F20.6)' ) max_x write ( min_y_char , '(F20.6)' ) min_y write ( max_y_char , '(F20.6)' ) max_y min_x_char = trim ( adjustl (( min_x_char ))) max_x_char = trim ( adjustl (( max_x_char ))) min_y_char = trim ( adjustl (( min_y_char ))) max_y_char = trim ( adjustl (( max_y_char ))) write ( unit , * ) '    @with g0' write ( unit , * ) '@    world ' // trim ( min_x_char ) // ', ' // trim ( min_y_char )& & // ', ' // trim ( max_x_char ) // ', ' // trim ( max_y_char ) write ( unit , * ) '@    stack world 0, 0, 0, 0' write ( unit , * ) '@    znorm 1' write ( unit , * ) '@    view 0.150000, 0.150000, 1.150000, 0.850000' write ( unit , * ) '@    title \"' // trim ( title ) // '\"' write ( unit , * ) '@    title font 4' write ( unit , * ) '@    title size 1.500000' write ( unit , * ) '@    title color 1' ! write(unit,*) 'title \"'//trim(title)//'\"' ! write(unit,*) \"title font 4\" ! write(unit,*) \"title size 1.500000\" ! write(unit,*) \"title color 1\" end subroutine xmgu_title","tags":"","loc":"proc/xmgu_title.html"},{"title":"xmgu_vertical_line – OptaDOS","text":"public  subroutine xmgu_vertical_line(unit, x_coord, y_max, y_min) Uses od_constants proc~~xmgu_vertical_line~~UsesGraph proc~xmgu_vertical_line xmgu_vertical_line module~od_constants od_constants proc~xmgu_vertical_line->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit real(kind=dp), intent(in) :: x_coord real(kind=dp), intent(in) :: y_max real(kind=dp), intent(in) :: y_min Called by proc~~xmgu_vertical_line~~CalledByGraph proc~xmgu_vertical_line xmgu_vertical_line proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~xmgu_vertical_line proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code xmgu_vertical_line Source Code subroutine xmgu_vertical_line ( unit , x_coord , y_max , y_min ) !==================================================================! use od_constants , only : dp implicit none integer , intent ( in ) :: unit real ( dp ), intent ( in ) :: x_coord , y_max , y_min character ( 20 ) :: x_coord_char , y_max_char , y_min_char write ( x_coord_char , '(F20.6)' ) x_coord write ( y_max_char , '(F20.6)' ) y_max write ( y_min_char , '(F20.6)' ) y_min x_coord_char = trim ( adjustl (( x_coord_char ))) y_max_char = trim ( adjustl (( y_max_char ))) y_min_char = trim ( adjustl (( y_min_char ))) write ( unit , * ) '@with line' write ( unit , * ) '@    line on' write ( unit , * ) '@    line loctype world' write ( unit , * ) '@    line g0' write ( unit , * ) '@    line ' // trim ( x_coord_char ) // ', ' // trim ( y_min_char )& & // ', ' // trim ( x_coord_char ) // ', ' // trim ( y_max_char ) write ( unit , * ) '@    line linewidth 1.5' write ( unit , * ) '@    line linestyle 3' write ( unit , * ) '@    line color 2' write ( unit , * ) '@    line arrow 0' write ( unit , * ) '@    line arrow type 0' write ( unit , * ) '@    line arrow length 1.000000' write ( unit , * ) '@    line arrow layout 1.000000, 1.000000' write ( unit , * ) '@line def' end subroutine xmgu_vertical_line","tags":"","loc":"proc/xmgu_vertical_line.html"},{"title":"cell_calc_kpoint_r_cart – OptaDOS","text":"public  subroutine cell_calc_kpoint_r_cart() Uses od_comms od_io od_algorithms proc~~cell_calc_kpoint_r_cart~~UsesGraph proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart module~od_comms od_comms proc~cell_calc_kpoint_r_cart->module~od_comms module~od_algorithms od_algorithms proc~cell_calc_kpoint_r_cart->module~od_algorithms module~od_io od_io proc~cell_calc_kpoint_r_cart->module~od_io module~od_constants od_constants module~od_comms->module~od_constants module~od_algorithms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_calc_kpoint_r_cart~~CallsGraph proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~io_error io_error proc~cell_calc_kpoint_r_cart->proc~io_error proc~utility_reciprocal_frac_to_cart utility_reciprocal_frac_to_cart proc~cell_calc_kpoint_r_cart->proc~utility_reciprocal_frac_to_cart proc~cell_calc_lattice cell_calc_lattice proc~cell_calc_kpoint_r_cart->proc~cell_calc_lattice proc~cell_get_real_lattice cell_get_real_lattice proc~cell_calc_kpoint_r_cart->proc~cell_get_real_lattice proc~cell_calc_lattice->proc~cell_get_real_lattice proc~io_file_unit io_file_unit proc~cell_get_real_lattice->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_calc_kpoint_r_cart Source Code subroutine cell_calc_kpoint_r_cart !========================================================================= ! This subroutine calculates the cartesian coordinates of the k points use od_algorithms , only : utility_reciprocal_frac_to_cart use od_comms , only : my_node_id use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time , & io_error !    use od_electronic, only : elec_read_band_energy integer :: i , ik , loop , ierr real ( kind = dp ), allocatable , dimension (:, :) :: kpoint_r_tmp real ( kind = dp ), allocatable , dimension (:, :) :: kpoint_r_cart_tmp allocate ( kpoint_r_tmp ( 3 , num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating kpoint_r_tmp in& &    cell_calc_kpoint_r_cart' ) allocate ( kpoint_r_cart_tmp ( 3 , num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating kpoint_r_cart_tmp in& &    cell_calc_kpoint_r_cart' ) kpoint_r_tmp = kpoint_r !This is to be sure that the k point fractional coordinates are stored. !If they are, the elec_read_band_energy will return. !    call elec_read_band_energy ! We will call this only if we have not read in the cell before. With a parallel build ! the non root nodes would not get the updated cell and perform another bohr2ang ! conversion. If I try to insert a comms_bcast in the cell_get_ ! F.Mildner 04/2023 if (. not . abs ( cell_volume ) . gt . 0.0_dp ) then call cell_get_real_lattice call cell_calc_lattice end if do loop = 1 , num_kpoints_on_node ( my_node_id ) call utility_reciprocal_frac_to_cart ( kpoint_r_tmp (:, loop ), kpoint_r_cart_tmp (:, loop ), recip_lattice ) !      print*,kpoint_r_tmp(1,loop),kpoint_r_tmp(2,loop),kpoint_r_tmp(3,loop),& !       kpoint_r_cart_tmp(1,loop),kpoint_r_cart_tmp(2,loop),kpoint_r_cart_tmp(3,loop) !print*,loop,kpoint_r_cart_tmp(:,loop),recip_lattice end do kpoint_r_cart = kpoint_r_cart_tmp !      do loop=1,num_kpoints_on_node(my_node_id) !      print*,kpoint_r_tmp(1,loop),kpoint_r_cart(1,loop),& !      kpoint_r_tmp(2,loop),kpoint_r_cart(2,loop),& !      kpoint_r_tmp(3,loop),kpoint_r_cart(3,loop) !      end do deallocate ( kpoint_r_tmp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: cell_calc_kpoint_r_cart - & &     failed to deallocate kpoint_r_tmp' ) deallocate ( kpoint_r_cart_tmp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: cell_calc_kpoint_r_cart - & &     failed to deallocate kpoint_r_cart_tmp' ) end subroutine cell_calc_kpoint_r_cart","tags":"","loc":"proc/cell_calc_kpoint_r_cart.html"},{"title":"cell_calc_lattice – OptaDOS","text":"public  subroutine cell_calc_lattice() Uses od_constants proc~~cell_calc_lattice~~UsesGraph proc~cell_calc_lattice cell_calc_lattice module~od_constants od_constants proc~cell_calc_lattice->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_calc_lattice~~CallsGraph proc~cell_calc_lattice cell_calc_lattice proc~cell_get_real_lattice cell_get_real_lattice proc~cell_calc_lattice->proc~cell_get_real_lattice proc~io_file_unit io_file_unit proc~cell_get_real_lattice->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_calc_lattice~~CalledByGraph proc~cell_calc_lattice cell_calc_lattice proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->proc~cell_calc_lattice program~optados optados program~optados->proc~cell_calc_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_calc_lattice Source Code subroutine cell_calc_lattice !=========================================================================! ! Begin with a real lattice. Convert from bohr. Calculate a reciprocal ! lattice and the volume of the cell !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables used: real_lattice, recip_lattice, cell_volume !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by Andrew Morris from the LinDOS program             11/10/2010 !========================================================================= use od_constants , only : pi , bohr2ang implicit none ! THESE ARE IN BOHR, DON'T GET TRIPPED UP AGAIN! real_lattice = real_lattice * bohr2ang call cell_get_real_lattice recip_lattice ( 1 , 1 ) = real_lattice ( 2 , 2 ) * real_lattice ( 3 , 3 ) - & real_lattice ( 3 , 2 ) * real_lattice ( 2 , 3 ) recip_lattice ( 2 , 1 ) = real_lattice ( 2 , 3 ) * real_lattice ( 3 , 1 ) - & real_lattice ( 3 , 3 ) * real_lattice ( 2 , 1 ) recip_lattice ( 3 , 1 ) = real_lattice ( 2 , 1 ) * real_lattice ( 3 , 2 ) - & real_lattice ( 3 , 1 ) * real_lattice ( 2 , 2 ) recip_lattice ( 1 , 2 ) = real_lattice ( 3 , 2 ) * real_lattice ( 1 , 3 ) - & real_lattice ( 1 , 2 ) * real_lattice ( 3 , 3 ) recip_lattice ( 2 , 2 ) = real_lattice ( 3 , 3 ) * real_lattice ( 1 , 1 ) - & real_lattice ( 1 , 3 ) * real_lattice ( 3 , 1 ) recip_lattice ( 3 , 2 ) = real_lattice ( 3 , 1 ) * real_lattice ( 1 , 2 ) - & real_lattice ( 1 , 1 ) * real_lattice ( 3 , 2 ) recip_lattice ( 1 , 3 ) = real_lattice ( 1 , 2 ) * real_lattice ( 2 , 3 ) - & real_lattice ( 2 , 2 ) * real_lattice ( 1 , 3 ) recip_lattice ( 2 , 3 ) = real_lattice ( 1 , 3 ) * real_lattice ( 2 , 1 ) - & real_lattice ( 2 , 3 ) * real_lattice ( 1 , 1 ) recip_lattice ( 3 , 3 ) = real_lattice ( 1 , 1 ) * real_lattice ( 2 , 2 ) - & real_lattice ( 2 , 1 ) * real_lattice ( 1 , 2 ) ! * Calculate cell volume cell_volume = real_lattice ( 1 , 1 ) * recip_lattice ( 1 , 1 ) + & real_lattice ( 2 , 1 ) * recip_lattice ( 1 , 2 ) + & real_lattice ( 3 , 1 ) * recip_lattice ( 1 , 3 ) if ( cell_volume < 0.0_dp ) then ! Left handed set cell_volume = - cell_volume end if ! Scale reciprocal lattice by 2*pi/volume recip_lattice (:, :) = recip_lattice (:, :) * pi * 2.0_dp / cell_volume end subroutine cell_calc_lattice","tags":"","loc":"proc/cell_calc_lattice.html"},{"title":"cell_dist – OptaDOS","text":"public  subroutine cell_dist() Uses od_comms od_io proc~~cell_dist~~UsesGraph proc~cell_dist cell_dist module~od_comms od_comms proc~cell_dist->module~od_comms module~od_io od_io proc~cell_dist->module~od_io module~od_constants od_constants module~od_comms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_dist~~CallsGraph proc~cell_dist cell_dist interface~comms_bcast comms_bcast proc~cell_dist->interface~comms_bcast proc~io_error io_error proc~cell_dist->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_dist~~CalledByGraph proc~cell_dist cell_dist program~optados optados program~optados->proc~cell_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_dist Source Code subroutine cell_dist use od_comms , only : comms_bcast , on_root use od_io , only : io_error implicit none integer :: max_sites , ierr call comms_bcast ( real_lattice ( 1 , 1 ), 9 ) call comms_bcast ( recip_lattice ( 1 , 1 ), 9 ) call comms_bcast ( cell_volume , 1 ) !call comms_bcast(kpoint_r(:,:) !call comms_bcast(kpoint_r_cart(:,:) !call comms_bcast(kpoint_weight(:) call comms_bcast ( nkpoints , 1 ) call comms_bcast ( kpoint_grid_dim ( 1 ), 3 ) !-------------------------------------------------------------------------! call comms_bcast ( num_atoms , 1 ) call comms_bcast ( num_species , 1 ) if ( num_atoms > 0 ) then if (. not . on_root ) then allocate ( atoms_species_num ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_species_num in cell_dist' ) end if call comms_bcast ( atoms_species_num ( 1 ), num_species ) max_sites = maxval ( atoms_species_num ) if (. not . on_root ) then allocate ( atoms_pos_frac ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac in cell_dist' ) allocate ( atoms_pos_cart ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart in cell_dist' ) allocate ( atoms_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label in cell_dist' ) allocate ( atoms_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_symbol in cell_dist' ) ! For Photoemission allocate ( atoms_pos_cart_photo ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_photo in cell_dist' ) allocate ( atoms_label_tmp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label_tmp in cell_dist' ) end if call comms_bcast ( atoms_pos_frac ( 1 , 1 , 1 ), 3 * num_species * max_sites ) call comms_bcast ( atoms_pos_cart ( 1 , 1 , 1 ), 3 * num_species * max_sites ) call comms_bcast ( atoms_label ( 1 ), len ( atoms_label ( 1 )) * num_species ) call comms_bcast ( atoms_symbol ( 1 ), len ( atoms_symbol ( 1 )) * num_species ) ! For Photoemission call comms_bcast ( atoms_pos_cart_photo ( 1 , 1 ), 3 * num_atoms ) call comms_bcast ( atoms_label_tmp ( 1 ), maxlen * num_atoms ) end if call comms_bcast ( num_crystal_symmetry_operations , 1 ) if ( num_crystal_symmetry_operations > 0 ) then if (. not . on_root ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_dist\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_dist\" ) end if call comms_bcast ( crystal_symmetry_operations ( 1 , 1 , 1 ), 3 * 3 * num_crystal_symmetry_operations ) call comms_bcast ( crystal_symmetry_disps ( 1 , 1 ), 3 * num_crystal_symmetry_operations ) end if end subroutine cell_dist","tags":"","loc":"proc/cell_dist.html"},{"title":"cell_find_MP_grid – OptaDOS","text":"public  subroutine cell_find_MP_grid(kpoints, num_kpts, kpoint_grid_dim, kpoint_offset) Uses od_io proc~~cell_find_mp_grid~~UsesGraph proc~cell_find_mp_grid cell_find_MP_grid module~od_io od_io proc~cell_find_mp_grid->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. AJM COMMENTED OUT AS A TEST AGAINST\nHEXAGONAL CELLS Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: kpoints (1:3,1:num_kpts) integer, intent(in) :: num_kpts integer, intent(out) :: kpoint_grid_dim (1:3) real(kind=dp), intent(out), optional :: kpoint_offset (1:3) Calls proc~~cell_find_mp_grid~~CallsGraph proc~cell_find_mp_grid cell_find_MP_grid proc~io_error io_error proc~cell_find_mp_grid->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_find_mp_grid~~CalledByGraph proc~cell_find_mp_grid cell_find_MP_grid proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->proc~cell_find_mp_grid proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->proc~cell_find_mp_grid proc~get_band_energy get_band_energy proc~get_band_energy->proc~elec_read_band_energy program~optados optados program~optados->proc~elec_read_band_energy program~optados->proc~elec_read_band_energy_ordered program~od2od od2od program~od2od->proc~get_band_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_find_MP_grid Source Code subroutine cell_find_MP_grid ( kpoints , num_kpts , kpoint_grid_dim , kpoint_offset ) ! WARNING the kpoint_offset is only +/- the true kpoint offset. We need to ! do some more work to find out its sign ! A J Morris 29th September 2011 !=========================================================================! use od_io , only : io_error , stdout implicit none integer , intent ( out ) :: kpoint_grid_dim ( 1 : 3 ) integer , intent ( in ) :: num_kpts real ( kind = dp ), intent ( in ) :: kpoints ( 1 : 3 , 1 : num_kpts ) real ( kind = dp ), intent ( out ), optional :: kpoint_offset ( 1 : 3 ) real ( kind = dp ) :: kpoint_TR ( 1 : 3 , 1 : num_kpts * 2 ) real ( kind = dp ) :: unique_kpoints ( 1 : 3 , num_kpts * 2 ) integer :: nunique_kpoints , iunique_kpoints integer :: ikpt , idim , jkpt , i real ( kind = dp ) :: subtraction_tol , min_img , min_img2 real ( kind = dp ) :: min_img3 , image , min_img_tol integer :: iprint = 1 ! We can't use the global iprint as it's higher that this ! in the module heirarchy. ! Before time reversal symmetry we could any combintaion of kpoints !--------------------X------------- !                  0.25 ! We apply TR to make we have a complete set (and add periodic images) !------X------X------X------X------ !    -0.75  -0.25   0.25  0.75 ! ! In this case the answer is easy. The minimim image is 0.5. Hence the grid is ! 1/0.5 = 2x MP. ! However the fun comes when shifts are applied. In this case applying TR makes ! things more complicated. Consider the same grid with a +ve 0.05 shift. ! ! Now CASTEP had to give us more kpoints !------------------X------X------ !                0.20   0.70 ! ! We couldn't know that an offset had been applied so we appy TR and get !   -0.70     -0.20  0.30    0.80 !----X-X-----X-X----X-X----X-X---- !  -0.80  -0.30  0.20   0.70 ! ! Hence now the 1st minimum image is 0.10, double the offset !           the 2nd    \"      \"   is 0.40 !           the 3rd    \"      \"   is 0.50  the reciprocal of the MP grid ! One can now image the case where the offset is 3/(4n) where n is the MP grid number. ! in this case 3/8=0.375 !                 (shifted -0.75)  (shifted -0.25) !------------------------X-------------X------------------------- !                     -0.375        0.125 ! ! After TR !                           -0.125        0.375 !------------------------X-----X------X-----X-------------------- !                     -0.375        0.125 ! ! So these are all equally spaced so algorithm sees this like the first example, easy, 0.25. Hence ! grid is 1/0.25 = 4x MP. Wrong! ! ! This is a known bug -- and without having the symmetry ops, we can't build the shifted 2xMP grid to ! show that it is not a 4x MP.  AJM 15/9/2014 ! When two numbers are the same subtraction_tol = epsilon ( subtraction_tol ) !write(*,*) \"subtraction_tol=\", subtraction_tol ! When one number is larger than another one min_img_tol = 0.000001_dp if ( iprint > 3 ) then write ( stdout , * ) write ( stdout , * ) \"+----------------------------------------------------------------------------+\" write ( stdout , * ) \"                              MP grid finder \" write ( stdout , * ) write ( stdout , * ) \" Kpoints found:\" , num_kpts end if ! Add time reversal kpoint_TR ( 1 : 3 , 1 : num_kpts ) = kpoints ( 1 : 3 , 1 : num_kpts ) kpoint_TR ( 1 : 3 , num_kpts + 1 : num_kpts * 2 ) = - kpoints ( 1 : 3 , 1 : num_kpts ) ! Act on each dimension independently do idim = 1 , 3 ! Fold all kpoints between (-0.5,0.5] do ikpt = 1 , num_kpts * 2 kpoint_TR ( idim , ikpt ) = kpoint_TR ( idim , ikpt ) - floor ( kpoint_TR ( idim , ikpt ) + 0.5_dp ) end do end do unique_kpoints = 0.0_dp over_dim : do idim = 1 , 3 ! Make unique if ( iprint > 3 ) write ( stdout , * ) \" ----- Dimension \" , idim , \" -----\" nunique_kpoints = 1 unique_kpoints ( idim , 1 ) = kpoint_TR ( idim , 1 ) over_kpts : do ikpt = 2 , 2 * num_kpts do iunique_kpoints = 1 , nunique_kpoints if ( abs ( unique_kpoints ( idim , iunique_kpoints ) - kpoint_TR ( idim , ikpt )) . le . subtraction_tol ) then !We've seen this before cycle over_kpts end if end do ! If we ended up here then, this is new nunique_kpoints = nunique_kpoints + 1 if ( iprint > 3 ) write ( stdout , * ) \" ikpt= \" , ikpt , \"nunique_kpoints= \" , nunique_kpoints unique_kpoints ( idim , nunique_kpoints ) = kpoint_TR ( idim , ikpt ) end do over_kpts if ( iprint > 3 ) write ( stdout , * ) \" Number of unique kpoints:\" , nunique_kpoints ! write(*,*) \"------------------------ KPOINTS IN+TR+FOLDING+UNIQUE -----------\" ! do i=1,nunique_kpoints !    write(*,*) i, idim, unique_kpoints(idim,i) ! enddo ! write(*,*) \"-----------------------------------------------------------\" if ( iprint > 3 ) write ( stdout , * ) \" Looking for special cases for dimension:\" , idim ! Look at special cases. These are largely necessary because the general finder needs to get to ! second nearest neighbour before it can work correctly. Except in the case of if ( nunique_kpoints == 1 ) then ! There is only 1 k-point ! The shift is it's position (either 0 or 0.5) if ( present ( kpoint_offset )) kpoint_offset ( idim ) = unique_kpoints ( idim , 1 ) kpoint_grid_dim ( idim ) = 1 cycle over_dim elseif ( nunique_kpoints == 2 ) then min_img = abs ( unique_kpoints ( idim , 1 ) - unique_kpoints ( idim , 2 )) if ( abs ( min_img - 0.5_dp ) . le . min_img_tol ) then ! If the 1stMI is 0.5 then there are 2 k-points ! The shift is it's position (either 0 or 0.25) if ( present ( kpoint_offset )) kpoint_offset ( idim ) = unique_kpoints ( idim , 1 ) kpoint_grid_dim ( idim ) = 2 cycle over_dim else ! If the 1stMI .ne.0.5 then there is 1 kpoint ! It's offset is min_img/2 if ( present ( kpoint_offset )) kpoint_offset ( idim ) = min_img / 2 kpoint_grid_dim ( idim ) = 1 cycle over_dim end if elseif ( nunique_kpoints == 3 ) then ! This is the case of a MP3 grid with a point at Gamma !! AJM COMMENTED OUT AS A TEST AGAINST !! HEXAGONAL CELLS !      if(present(kpoint_offset)) kpoint_offset(idim)=0.0_dp !      kpoint_grid_dim(idim)=3 !      cycle over_dim continue end if if ( iprint > 3 ) write ( stdout , * ) \" Left the special-case kpoint finder for dimension:\" , idim if ( iprint > 3 ) write ( stdout , * ) \" Now trying to use the general solver...\" ! Get 1st, 2nd and 3rd minimum images ! Get 1st min image min_img = huge ( min_img ) do ikpt = 1 , nunique_kpoints do jkpt = ikpt + 1 , nunique_kpoints image = abs ( unique_kpoints ( idim , ikpt ) - unique_kpoints ( idim , jkpt )) if ( image < min_img ) min_img = image end do end do if ( abs ( min_img - huge ( min_img )) . le . subtraction_tol ) & & call io_error ( 'cell_find_MP_grid: Failed to find a 1st min image' ) ! Get 2nd min image min_img2 = huge ( min_img2 ) do ikpt = 1 , nunique_kpoints do jkpt = ikpt , nunique_kpoints image = abs ( unique_kpoints ( idim , ikpt ) - unique_kpoints ( idim , jkpt )) if (( image < min_img2 ) . and . image > min_img + min_img_tol ) min_img2 = image end do end do if ( abs ( min_img2 - huge ( min_img2 )) . le . subtraction_tol ) & & call io_error ( 'cell_find_MP_grid: Failed to find a 2nd min image' ) ! Get 3rd min image min_img3 = huge ( min_img3 ) do ikpt = 1 , nunique_kpoints do jkpt = ikpt , nunique_kpoints image = abs ( unique_kpoints ( idim , ikpt ) - unique_kpoints ( idim , jkpt )) if (( image < min_img3 ) . and . image > min_img2 + min_img_tol ) min_img3 = image end do end do if ( abs ( min_img3 - huge ( min_img3 )) . le . subtraction_tol ) then ! It's possible in CASTEP 6 and 7 to have 3 kpoints only for a 5 MP grid ! the specieal case solver then got confused. if ( abs ( 2.0_dp * min_img - min_img2 ) < min_img_tol ) then ! If 1stMI==2ndMI then 1/1stMP is the grid density and we're still ok. Carry on. ! we'll catch this scenario further down the code. if ( iprint > 3 ) write ( stdout , * ) \" Couldn't find a third minimum image, but since we don't think\" if ( iprint > 3 ) write ( stdout , * ) \" there's an offset, it looks like a\" , 1.0_dp / min_img , \" kpoint grid\" continue else call io_error ( 'cell_find_MP_grid: Failed to find a 3rd min image' ) end if end if if ( iprint > 3 ) then write ( stdout , * ) \" Min images for dimension:\" , idim write ( stdout , * ) \" 1st:\" , min_img write ( stdout , * ) \" 2nd:\" , min_img2 write ( stdout , * ) \" 3rd:\" , min_img3 write ( stdout , * ) \" 1st&#94;-1:\" , 1.0_dp / min_img end if if ( abs ( 2.0_dp * min_img - min_img2 ) < min_img_tol ) then ! If 1stMI==2ndMI then 1/1stMP is the grid density if ( present ( kpoint_offset )) kpoint_offset ( idim ) = 0.0_dp kpoint_grid_dim ( idim ) = int ( 1.0_dp / min_img ) ! WARNING could also have a shifted grid with a perfect shift 3/(4n) ! this would be a known bug else ! If 1stMI.ne.2ndMI then 1/3rdMP is the grid density ! and 1stMI/2 is the shift if ( present ( kpoint_offset )) kpoint_offset ( idim ) = min_img / 2.0_dp kpoint_grid_dim ( idim ) = int ( 1.0_dp / min_img3 ) end if end do over_dim if ( iprint > 3 ) write ( stdout , * ) \" Conclusion = kpoint_grid_dim: \" , kpoint_grid_dim ! if(present(kpoint_offset))  write(*,*) \"kpoint_offset= \",  kpoint_offset if ( iprint > 3 ) & & write ( stdout , * ) \"+----------------------------------------------------------------------------+\" end subroutine cell_find_MP_grid","tags":"","loc":"proc/cell_find_mp_grid.html"},{"title":"cell_get_atoms – OptaDOS","text":"public  subroutine cell_get_atoms() Uses od_algorithms od_io od_constants proc~~cell_get_atoms~~UsesGraph proc~cell_get_atoms cell_get_atoms module~od_algorithms od_algorithms proc~cell_get_atoms->module~od_algorithms module~od_io od_io proc~cell_get_atoms->module~od_io module~od_constants od_constants proc~cell_get_atoms->module~od_constants module~od_algorithms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_get_atoms~~CallsGraph proc~cell_get_atoms cell_get_atoms proc~io_file_unit io_file_unit proc~cell_get_atoms->proc~io_file_unit proc~io_error io_error proc~cell_get_atoms->proc~io_error proc~cell_get_real_lattice cell_get_real_lattice proc~cell_get_atoms->proc~cell_get_real_lattice proc~utility_frac_to_cart utility_frac_to_cart proc~cell_get_atoms->proc~utility_frac_to_cart proc~utility_lowercase utility_lowercase proc~cell_get_atoms->proc~utility_lowercase proc~utility_cart_to_frac utility_cart_to_frac proc~cell_get_atoms->proc~utility_cart_to_frac proc~cell_get_real_lattice->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_get_atoms Source Code subroutine cell_get_atoms !=========================================================================! use od_constants , only : bohr2ang use od_io , only : io_file_unit , io_error , seedname , maxlen use od_algorithms , only : utility_cart_to_frac , utility_frac_to_cart , utility_lowercase implicit none real ( kind = dp ), allocatable :: atoms_pos_frac_tmp (:, :) real ( kind = dp ), allocatable :: atoms_pos_cart_tmp (:, :) character ( len = 20 ) :: keyword integer :: in , in1 , in2 , ins , ine , loop , i , line_e , line_s , counter , tot_num_lines integer :: loop2 , max_sites , ierr , ic , num_lines , line_counter , in_unit logical :: found_e , found_s , frac character ( len = maxlen ) :: dummy character ( len = maxlen ), allocatable :: ctemp (:) character ( len = maxlen ), allocatable :: atoms_label_tmp (:) logical :: lconvert character ( len = maxlen ), allocatable :: in_data (:) ! read in the cell file ! count the lines in_unit = io_file_unit () open ( in_unit , file = trim ( seedname ) // '.cell' , form = 'formatted' , status = 'old' , err = 101 ) num_lines = 0 ; tot_num_lines = 0 do read ( in_unit , '(a)' , iostat = ierr , err = 200 , end = 210 ) dummy dummy = adjustl ( dummy ) tot_num_lines = tot_num_lines + 1 if (. not . dummy ( 1 : 1 ) == '!' . and . . not . dummy ( 1 : 1 ) == '#' ) then if ( len ( trim ( dummy )) > 0 ) num_lines = num_lines + 1 end if end do 101 call io_error ( 'Error: Problem opening input file ' // trim ( seedname ) // '.cell' ) 200 call io_error ( 'Error: Problem reading input file ' // trim ( seedname ) // '.cell' ) 210 continue rewind ( in_unit ) ! now read in for real - ignoring comments allocate ( in_data ( num_lines ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating in_data in cell_get_atoms' ) line_counter = 0 do loop = 1 , tot_num_lines read ( in_unit , '(a)' , iostat = ierr , err = 200 ) dummy dummy = utility_lowercase ( dummy ) dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '!' . or . dummy ( 1 : 1 ) == '#' ) cycle if ( len ( trim ( dummy )) == 0 ) cycle line_counter = line_counter + 1 in1 = index ( dummy , '!' ) in2 = index ( dummy , '#' ) if ( in1 == 0 . and . in2 == 0 ) in_data ( line_counter ) = dummy if ( in1 == 0 . and . in2 > 0 ) in_data ( line_counter ) = dummy (: in2 - 1 ) if ( in2 == 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: in1 - 1 ) if ( in2 > 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: min ( in1 , in2 ) - 1 ) end do close ( in_unit ) ! let's look for the atoms block (remember everything is lower case) keyword = 'positions' found_s = . false . do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), '%block' ) if ( in == 0 . or . in > 1 ) cycle if ( index ( in_data ( loop ), 'frac' ) > 0 ) then frac = . true . elseif ( index ( in_data ( loop ), 'abs' ) > 0 ) then frac = . false . else cycle end if line_s = loop if ( found_s ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_s = . true . end do if ( frac ) then keyword = 'positions_frac' else keyword = 'positions_abs' end if found_e = . false . do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), '%endblock' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' but no %endblock' // trim ( keyword ) // ' in cell file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: %endblock' // trim ( keyword ) // ' comes before %block' // trim ( keyword ) // ' in input file' ) end if ! now we know where the atoms block is lconvert = . false . dummy = in_data ( line_s + 1 ) if ( index ( dummy , 'ang' ) . ne . 0 ) then lconvert = . false . line_s = line_s + 1 elseif ( index ( dummy , 'bohr' ) . ne . 0 ) then lconvert = . true . line_s = line_s + 1 end if num_atoms = line_e - 1 - ( line_s + 1 ) + 1 allocate ( atoms_pos_frac_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac_tmp in cell_get_atoms' ) allocate ( atoms_pos_cart_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_tmp in cell_get_atoms' ) allocate ( ctemp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating ctemp in cell_get_atoms' ) allocate ( atoms_label_tmp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label_tmp in cell_get_atoms' ) counter = 0 do loop = line_s + 1 , line_e - 1 dummy = in_data ( loop ) counter = counter + 1 if ( frac ) then read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_frac_tmp ( i , counter ), i = 1 , 3 ) else read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_cart_tmp ( i , counter ), i = 1 , 3 ) end if end do if ( lconvert ) then atoms_pos_cart_tmp = atoms_pos_cart_tmp * bohr2ang end if call cell_get_real_lattice if ( frac ) then do loop = 1 , num_atoms call utility_frac_to_cart ( atoms_pos_frac_tmp (:, loop ), atoms_pos_cart_tmp (:, loop ), real_lattice ) end do else do loop = 1 , num_atoms call utility_cart_to_frac ( atoms_pos_cart_tmp (:, loop ), atoms_pos_frac_tmp (:, loop ), recip_lattice ) end do end if ! Now we sort the data into the proper structures num_species = 1 ctemp ( 1 ) = atoms_label_tmp ( 1 ) do loop = 2 , num_atoms do loop2 = 1 , loop - 1 if ( trim ( atoms_label_tmp ( loop )) == trim ( atoms_label_tmp ( loop2 ))) exit if ( loop2 == loop - 1 ) then num_species = num_species + 1 ctemp ( num_species ) = atoms_label_tmp ( loop ) end if end do end do allocate ( atoms_species_num ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_species_num in cell_get_atoms' ) allocate ( atoms_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label in cell_get_atoms' ) allocate ( atoms_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_symbol in cell_get_atoms' ) atoms_species_num (:) = 0 do loop = 1 , num_species atoms_label ( loop ) = ctemp ( loop ) do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then atoms_species_num ( loop ) = atoms_species_num ( loop ) + 1 end if end do end do max_sites = maxval ( atoms_species_num ) allocate ( atoms_pos_frac ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac in cell_get_atoms' ) allocate ( atoms_pos_cart ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart in cell_get_atoms' ) do loop = 1 , num_species counter = 0 do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then counter = counter + 1 atoms_pos_frac (:, counter , loop ) = atoms_pos_frac_tmp (:, loop2 ) atoms_pos_cart (:, counter , loop ) = atoms_pos_cart_tmp (:, loop2 ) end if end do end do ! Strip any numeric characters from atoms_label to get atoms_symbol do loop = 1 , num_species atoms_symbol ( loop ) ( 1 : 2 ) = atoms_label ( loop ) ( 1 : 2 ) ic = ichar ( atoms_symbol ( loop ) ( 2 : 2 )) if (( ic . lt . ichar ( 'a' )) . or . ( ic . gt . ichar ( 'z' ))) & atoms_symbol ( loop ) ( 2 : 2 ) = ' ' end do return 240 call io_error ( 'Error: Problem reading block keyword ' // trim ( keyword )) end subroutine cell_get_atoms","tags":"","loc":"proc/cell_get_atoms.html"},{"title":"cell_get_real_lattice – OptaDOS","text":"public  subroutine cell_get_real_lattice() Uses od_comms od_io od_constants proc~~cell_get_real_lattice~~UsesGraph proc~cell_get_real_lattice cell_get_real_lattice module~od_comms od_comms proc~cell_get_real_lattice->module~od_comms module~od_io od_io proc~cell_get_real_lattice->module~od_io module~od_constants od_constants proc~cell_get_real_lattice->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_get_real_lattice~~CallsGraph proc~cell_get_real_lattice cell_get_real_lattice proc~io_file_unit io_file_unit proc~cell_get_real_lattice->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_get_real_lattice~~CalledByGraph proc~cell_get_real_lattice cell_get_real_lattice proc~cell_read_cell cell_read_cell proc~cell_read_cell->proc~cell_get_real_lattice proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->proc~cell_get_real_lattice proc~cell_calc_lattice cell_calc_lattice proc~cell_calc_kpoint_r_cart->proc~cell_calc_lattice proc~cell_calc_lattice->proc~cell_get_real_lattice proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->proc~cell_get_real_lattice proc~param_read param_read proc~param_read->proc~cell_read_cell program~optados optados program~optados->proc~cell_calc_lattice program~optados->proc~param_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_get_real_lattice Source Code subroutine cell_get_real_lattice !========================================================================= ! This subroutine reads the lattice parameters from the bands file in ! order to have them stored when the frac_to_cart and cart_frac subroutines ! are called. Independently of having used the elec_read_band_energy ! subroutine before. use od_comms , only : on_root use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time , & io_error use od_constants , only : bohr2ang integer :: band_unit character ( filename_len ) :: band_filename !Open the bands file band_unit = io_file_unit () band_filename = trim ( seedname ) // \".bands\" !    print*,'band_filename=',band_filename ! Read the header from the bands file if ( on_root ) then open ( unit = band_unit , file = band_filename , status = \"old\" , form = 'formatted' ) !,err=100) !100    call io_error('Error: Problem opening bands file in cell_get_real_lattice') read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) real_lattice (:, 1 ) read ( band_unit , * ) real_lattice (:, 2 ) read ( band_unit , * ) real_lattice (:, 3 ) end if real_lattice = real_lattice * bohr2ang if ( on_root ) close ( unit = band_unit ) end subroutine cell_get_real_lattice","tags":"","loc":"proc/cell_get_real_lattice.html"},{"title":"cell_get_symmetry – OptaDOS","text":"public  subroutine cell_get_symmetry() Uses od_comms od_io proc~~cell_get_symmetry~~UsesGraph proc~cell_get_symmetry cell_get_symmetry module~od_comms od_comms proc~cell_get_symmetry->module~od_comms module~od_io od_io proc~cell_get_symmetry->module~od_io module~od_constants od_constants module~od_comms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_get_symmetry~~CallsGraph proc~cell_get_symmetry cell_get_symmetry proc~io_file_unit io_file_unit proc~cell_get_symmetry->proc~io_file_unit interface~comms_bcast comms_bcast proc~cell_get_symmetry->interface~comms_bcast proc~io_error io_error proc~cell_get_symmetry->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_get_symmetry~~CalledByGraph proc~cell_get_symmetry cell_get_symmetry proc~make_weights make_weights proc~make_weights->proc~cell_get_symmetry proc~optics_calculate optics_calculate proc~optics_calculate->proc~make_weights program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_get_symmetry Source Code subroutine cell_get_symmetry !=========================================================================! ! Read in the cell symmetries                                             ! !-------------------------------------------------------------------------! ! Arguments: kpoints - an array of kpoints                                ! !            num_kpts - size of the kpoint array                          ! !-------------------------------------------------------------------------! ! Returns: kpint_grid_dim - the number of kpoints in each dimension       ! !-------------------------------------------------------------------------! ! Parent module variables used: None                                      ! !-------------------------------------------------------------------------! ! Modules used:  None                                                     ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! ! Described below                                                         ! !-------------------------------------------------------------------------! ! Necessary conditions: None !-------------------------------------------------------------------------- ! Known Worries: None !-------------------------------------------------------------------------! ! JRY, April 2011                                                         ! !=========================================================================! use od_comms , only : on_root , comms_bcast use od_io , only : filename_len , io_file_unit , seedname , io_error , stdout implicit none integer :: ierr , sym_file logical :: exists character ( filename_len ) :: sym_filename !check if we already have the symmetries if ( allocated ( crystal_symmetry_operations )) return sym_file = io_file_unit () sym_filename = trim ( seedname ) // \".sym\" if ( on_root ) inquire ( file = sym_filename , exist = exists ) call comms_bcast ( exists , 1 ) if (. not . exists ) then if ( on_root ) then write ( stdout , '(1x,78a)' ) '!--------------------------------- WARNING ----------------------------------!' write ( stdout , '(1x,78a)' ) '!                Symmetry Operations file (.sym) not found                   !' write ( stdout , '(1x,78a)' ) '!                       Proceeding without symmetry                          !' write ( stdout , '(1x,78a)' ) '!----------------------------------------------------------------------------!' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if num_crystal_symmetry_operations = 0 return end if if ( on_root ) then open ( unit = sym_file , file = sym_filename , form = 'unformatted' , err = 100 , status = 'old' ) read ( sym_file ) num_crystal_symmetry_operations if ( num_crystal_symmetry_operations > 0 ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_get_symmetry\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_get_symmetry\" ) read ( sym_file ) crystal_symmetry_operations read ( sym_file ) crystal_symmetry_disps end if end if call comms_bcast ( num_crystal_symmetry_operations , 1 ) if ( num_crystal_symmetry_operations > 0 ) then if (. not . on_root ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_get_symmetry\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_get_symmetry\" ) end if call comms_bcast ( crystal_symmetry_operations ( 1 , 1 , 1 ), 9 * num_crystal_symmetry_operations ) call comms_bcast ( crystal_symmetry_disps ( 1 , 1 ), 3 * num_crystal_symmetry_operations ) end if return 100 call io_error ( 'Error: Problem opening sym file in cell_get_symmetry' ) end subroutine cell_get_symmetry","tags":"","loc":"proc/cell_get_symmetry.html"},{"title":"cell_read_cell – OptaDOS","text":"public  subroutine cell_read_cell() Uses od_algorithms od_io od_constants proc~~cell_read_cell~~UsesGraph proc~cell_read_cell cell_read_cell module~od_algorithms od_algorithms proc~cell_read_cell->module~od_algorithms module~od_io od_io proc~cell_read_cell->module~od_io module~od_constants od_constants proc~cell_read_cell->module~od_constants module~od_algorithms->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~cell_read_cell~~CallsGraph proc~cell_read_cell cell_read_cell proc~io_file_unit io_file_unit proc~cell_read_cell->proc~io_file_unit proc~io_error io_error proc~cell_read_cell->proc~io_error proc~cell_get_real_lattice cell_get_real_lattice proc~cell_read_cell->proc~cell_get_real_lattice proc~utility_frac_to_cart utility_frac_to_cart proc~cell_read_cell->proc~utility_frac_to_cart proc~utility_lowercase utility_lowercase proc~cell_read_cell->proc~utility_lowercase proc~utility_cart_to_frac utility_cart_to_frac proc~cell_read_cell->proc~utility_cart_to_frac proc~cell_get_real_lattice->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_read_cell~~CalledByGraph proc~cell_read_cell cell_read_cell proc~param_read param_read proc~param_read->proc~cell_read_cell program~optados optados program~optados->proc~param_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_read_cell Source Code subroutine cell_read_cell !=========================================================================! use od_constants , only : bohr2ang use od_io , only : io_file_unit , io_error , seedname , maxlen use od_algorithms , only : utility_cart_to_frac , utility_frac_to_cart , utility_lowercase implicit none real ( kind = dp ), allocatable :: atoms_pos_frac_tmp (:, :) real ( kind = dp ), allocatable :: atoms_pos_cart_tmp (:, :) character ( len = 20 ) :: keyword integer :: in , in1 , in2 , ins , ine , loop , i , line_e , line_s , counter , tot_num_lines integer :: loop2 , max_sites , ierr , ic , num_lines , line_counter , in_unit logical :: found_e , found_s , frac character ( len = maxlen ) :: dummy character ( len = maxlen ), allocatable :: ctemp (:) !character(len=maxlen), allocatable :: atoms_label_tmp(:) logical :: lconvert character ( len = maxlen ), allocatable :: in_data (:) ! read in the cell file ! count the lines in_unit = io_file_unit () open ( in_unit , file = trim ( seedname ) // '-out.cell' , form = 'formatted' , status = 'old' , err = 101 ) num_lines = 0 ; tot_num_lines = 0 do read ( in_unit , '(a)' , iostat = ierr , err = 200 , end = 210 ) dummy dummy = adjustl ( dummy ) tot_num_lines = tot_num_lines + 1 if (. not . dummy ( 1 : 1 ) == '!' . and . . not . dummy ( 1 : 1 ) == '#' ) then if ( len ( trim ( dummy )) > 0 ) num_lines = num_lines + 1 end if end do 101 call io_error ( 'Error: Problem opening input file ' // trim ( seedname ) // '-out.cell' ) 200 call io_error ( 'Error: Problem reading input file ' // trim ( seedname ) // '-out.cell' ) 210 continue rewind ( in_unit ) ! now read in for real - ignoring comments allocate ( in_data ( num_lines ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating in_data in cell_get_atoms' ) line_counter = 0 do loop = 1 , tot_num_lines read ( in_unit , '(a)' , iostat = ierr , err = 200 ) dummy dummy = utility_lowercase ( dummy ) dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '!' . or . dummy ( 1 : 1 ) == '#' ) cycle if ( len ( trim ( dummy )) == 0 ) cycle line_counter = line_counter + 1 in1 = index ( dummy , '!' ) in2 = index ( dummy , '#' ) if ( in1 == 0 . and . in2 == 0 ) in_data ( line_counter ) = dummy if ( in1 == 0 . and . in2 > 0 ) in_data ( line_counter ) = dummy (: in2 - 1 ) if ( in2 == 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: in1 - 1 ) if ( in2 > 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: min ( in1 , in2 ) - 1 ) end do close ( in_unit ) ! let's look for the atoms block (remember everything is lower case) keyword = 'positions' found_s = . false . do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), '%block' ) if ( in == 0 . or . in > 1 ) cycle if ( index ( in_data ( loop ), 'frac' ) > 0 ) then frac = . true . elseif ( index ( in_data ( loop ), 'abs' ) > 0 ) then frac = . false . else cycle end if line_s = loop if ( found_s ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_s = . true . end do if ( frac ) then keyword = 'positions_frac' else keyword = 'positions_abs' end if found_e = . false . do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), '%endblock' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' but no %endblock' // trim ( keyword ) // ' in cell file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: %endblock' // trim ( keyword ) // ' comes before %block' // trim ( keyword ) // ' in input file' ) end if ! now we know where the atoms block is lconvert = . false . dummy = in_data ( line_s + 1 ) if ( index ( dummy , 'ang' ) . ne . 0 ) then lconvert = . false . line_s = line_s + 1 elseif ( index ( dummy , 'bohr' ) . ne . 0 ) then lconvert = . true . line_s = line_s + 1 end if num_atoms = line_e - 1 - ( line_s + 1 ) + 1 allocate ( atoms_pos_frac_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac_tmp in cell_get_atoms' ) allocate ( atoms_pos_cart_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_tmp in cell_get_atoms' ) allocate ( ctemp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating ctemp in cell_get_atoms' ) allocate ( atoms_label_tmp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label_tmp in cell_get_atoms' ) counter = 0 do loop = line_s + 1 , line_e - 1 dummy = in_data ( loop ) counter = counter + 1 if ( frac ) then read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_frac_tmp ( i , counter ), i = 1 , 3 ) else read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_cart_tmp ( i , counter ), i = 1 , 3 ) end if end do if ( lconvert ) then atoms_pos_cart_tmp = atoms_pos_cart_tmp * bohr2ang end if call cell_get_real_lattice if ( frac ) then do loop = 1 , num_atoms call utility_frac_to_cart ( atoms_pos_frac_tmp (:, loop ), atoms_pos_cart_tmp (:, loop ), real_lattice ) end do else do loop = 1 , num_atoms call utility_cart_to_frac ( atoms_pos_cart_tmp (:, loop ), atoms_pos_frac_tmp (:, loop ), recip_lattice ) end do end if ! Now we sort the data into the proper structures num_species = 1 ctemp ( 1 ) = atoms_label_tmp ( 1 ) do loop = 2 , num_atoms do loop2 = 1 , loop - 1 if ( trim ( atoms_label_tmp ( loop )) == trim ( atoms_label_tmp ( loop2 ))) exit if ( loop2 == loop - 1 ) then num_species = num_species + 1 ctemp ( num_species ) = atoms_label_tmp ( loop ) end if end do end do allocate ( atoms_species_num ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_species_num in cell_get_atoms' ) allocate ( atoms_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label in cell_get_atoms' ) allocate ( atoms_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_symbol in cell_get_atoms' ) atoms_species_num (:) = 0 do loop = 1 , num_species atoms_label ( loop ) = ctemp ( loop ) do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then atoms_species_num ( loop ) = atoms_species_num ( loop ) + 1 end if end do end do max_sites = maxval ( atoms_species_num ) allocate ( atoms_pos_frac ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac in cell_get_atoms' ) allocate ( atoms_pos_cart ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart in cell_get_atoms' ) allocate ( atoms_pos_cart_photo ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_photo in cell_get_atoms' ) ! Making a copy to use in the photo.f90 subroutine \"analyse_geometry\" atoms_pos_cart_photo = atoms_pos_cart_tmp do loop = 1 , num_species counter = 0 do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then counter = counter + 1 atoms_pos_frac (:, counter , loop ) = atoms_pos_frac_tmp (:, loop2 ) atoms_pos_cart (:, counter , loop ) = atoms_pos_cart_tmp (:, loop2 ) end if end do end do ! Strip any numeric characters from atoms_label to get atoms_symbol do loop = 1 , num_species atoms_symbol ( loop ) ( 1 : 2 ) = atoms_label ( loop ) ( 1 : 2 ) ic = ichar ( atoms_symbol ( loop ) ( 2 : 2 )) if (( ic . lt . ichar ( 'a' )) . or . ( ic . gt . ichar ( 'z' ))) & atoms_symbol ( loop ) ( 2 : 2 ) = ' ' end do ! let's look for the symmetry_ops block keyword = 'symmetry_ops' num_crystal_symmetry_operations = 0 found_s = . false . do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), '%block' ) if ( in == 0 . or . in > 1 ) cycle line_s = loop if ( found_s ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in out.cell file' ) end if found_s = . true . end do if ( found_s ) then found_e = . false . do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), '%endblock' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in out.cell file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' but no %endblock' // trim ( keyword ) // ' in out.cell file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: %endblock' // trim ( keyword ) // ' comes before %block' // trim ( keyword ) // ' in input file' ) end if ! now we know where the block is num_crystal_symmetry_operations = ( line_e - line_s - 1 ) / 4 if (( 4 * num_crystal_symmetry_operations ) /= ( line_e - line_s - 1 )) & call io_error ( 'Error: Something wrong with symmetry_ops block in -out.cell file' ) if ( num_crystal_symmetry_operations > 0 ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_read_cell\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_read_cell\" ) counter = 0 do loop = line_s + 1 , line_e - 1 , 4 dummy = in_data ( loop ) counter = counter + 1 dummy = in_data ( loop ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_operations ( 1 , 1 , counter ), & crystal_symmetry_operations ( 2 , 1 , counter ), crystal_symmetry_operations ( 3 , 1 , counter ) dummy = in_data ( loop + 1 ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_operations ( 1 , 2 , counter ), & crystal_symmetry_operations ( 2 , 2 , counter ), crystal_symmetry_operations ( 3 , 2 , counter ) dummy = in_data ( loop + 2 ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_operations ( 1 , 3 , counter ), & crystal_symmetry_operations ( 2 , 3 , counter ), crystal_symmetry_operations ( 3 , 3 , counter ) dummy = in_data ( loop + 3 ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_disps ( 1 , counter ), & crystal_symmetry_disps ( 2 , counter ), crystal_symmetry_disps ( 3 , counter ) end do end if else call io_error ( 'Error: Cannot find %block ' // trim ( keyword ) // ' in ' // trim ( seedname ) // '-out.cell' ) end if return 240 call io_error ( 'Error: Problem reading block keyword ' // trim ( keyword )) end subroutine cell_read_cell","tags":"","loc":"proc/cell_read_cell.html"},{"title":"cell_report_parameters – OptaDOS","text":"public  subroutine cell_report_parameters() Uses od_io proc~~cell_report_parameters~~UsesGraph proc~cell_report_parameters cell_report_parameters module~od_io od_io proc~cell_report_parameters->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~cell_report_parameters~~CalledByGraph proc~cell_report_parameters cell_report_parameters program~optados optados program~optados->proc~cell_report_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code cell_report_parameters Source Code subroutine cell_report_parameters !========================================================================= ! Begin with a real lattice. Convert from bohr. Calculate a reciprocal ! lattice and the volume of the cell !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables used: real_lattice, recip_lattice, cell_volume !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by J R Yates, modified A J Morris                     Dec 2010 !========================================================================= use od_io , only : stdout implicit none integer :: i write ( stdout , '(30x,a21)' ) 'Lattice Vectors (Ang)' write ( stdout , 101 ) 'a_1' , ( real_lattice ( 1 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'a_2' , ( real_lattice ( 2 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'a_3' , ( real_lattice ( 3 , I ), i = 1 , 3 ) write ( stdout , * ) write ( stdout , '(24x,a33)' ) 'Reciprocal-Space Vectors (Ang&#94;-1)' write ( stdout , 101 ) 'b_1' , ( recip_lattice ( 1 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'b_2' , ( recip_lattice ( 2 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'b_3' , ( recip_lattice ( 3 , I ), i = 1 , 3 ) write ( stdout , * ) write ( stdout , '(19x,a17,3x,f11.5)' , advance = 'no' ) & 'Unit Cell Volume:' , cell_volume write ( stdout , '(2x,a7)' ) '(Ang&#94;3)' write ( stdout , * ) return 101 format ( 20 x , a3 , 2 x , 3 F11 . 6 ) end subroutine cell_report_parameters","tags":"","loc":"proc/cell_report_parameters.html"},{"title":"allocate_jdos – OptaDOS","text":"public  subroutine allocate_jdos(jdos) Uses od_electronic od_parameters od_io proc~~allocate_jdos~~UsesGraph proc~allocate_jdos allocate_jdos module~od_electronic od_electronic proc~allocate_jdos->module~od_electronic module~od_parameters od_parameters proc~allocate_jdos->module~od_parameters module~od_io od_io proc~allocate_jdos->module~od_io module~od_constants od_constants module~od_electronic->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: jdos (:,:) Calls proc~~allocate_jdos~~CallsGraph proc~allocate_jdos allocate_jdos proc~io_error io_error proc~allocate_jdos->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_jdos~~CalledByGraph proc~allocate_jdos allocate_jdos proc~calculate_jdos calculate_jdos proc~calculate_jdos->proc~allocate_jdos proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_jdos Source Code subroutine allocate_jdos ( jdos ) !=============================================================================== !=============================================================================== use od_electronic , only : nspins use od_io , only : io_error use od_parameters , only : photo implicit none real ( kind = dp ), allocatable , intent ( out ) :: jdos (:, :) integer :: ierr allocate ( jdos ( jdos_nbins , nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"Error in allocating jdos (jdos_utils)\" ) jdos = 0.0_dp end subroutine allocate_jdos","tags":"","loc":"proc/allocate_jdos.html"},{"title":"calculate_jdos – OptaDOS","text":"public  subroutine calculate_jdos(jdos_type, jdos, matrix_weights, weighted_jdos) Uses od_algorithms od_parameters od_comms od_dos_utils od_cell od_constants od_electronic od_io proc~~calculate_jdos~~UsesGraph proc~calculate_jdos calculate_jdos module~od_algorithms od_algorithms proc~calculate_jdos->module~od_algorithms module~od_parameters od_parameters proc~calculate_jdos->module~od_parameters module~od_dos_utils od_dos_utils proc~calculate_jdos->module~od_dos_utils module~od_comms od_comms proc~calculate_jdos->module~od_comms module~od_cell od_cell proc~calculate_jdos->module~od_cell module~od_constants od_constants proc~calculate_jdos->module~od_constants module~od_electronic od_electronic proc~calculate_jdos->module~od_electronic module~od_io od_io proc~calculate_jdos->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_parameters->module~od_io module~od_dos_utils->module~od_constants module~od_dos_utils->module~od_electronic module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_electronic->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jdos_type real(kind=dp), intent(out), allocatable :: jdos (:,:) real(kind=dp), intent(in), optional :: matrix_weights (:,:,:,:,:) real(kind=dp), intent(inout), optional, allocatable :: weighted_jdos (:,:,:) Calls proc~~calculate_jdos~~CallsGraph proc~calculate_jdos calculate_jdos proc~io_error io_error proc~calculate_jdos->proc~io_error proc~doslin doslin proc~calculate_jdos->proc~doslin proc~gaussian gaussian proc~calculate_jdos->proc~gaussian proc~allocate_jdos allocate_jdos proc~calculate_jdos->proc~allocate_jdos proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~calculate_jdos->proc~doslin_sub_cell_corners proc~allocate_jdos->proc~io_error proc~heap_sort heap_sort proc~doslin_sub_cell_corners->proc~heap_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calculate_jdos~~CalledByGraph proc~calculate_jdos calculate_jdos proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_jdos Source Code subroutine calculate_jdos ( jdos_type , jdos , matrix_weights , weighted_jdos ) !=============================================================================== !=============================================================================== use od_comms , only : my_node_id , on_root use od_cell , only : num_kpoints_on_node , kpoint_grid_dim , kpoint_weight ,& & recip_lattice use od_parameters , only : adaptive_smearing , fixed_smearing , iprint , photo , & finite_bin_correction , scissor_op , hybrid_linear_grad_tol , hybrid_linear , exclude_bands , num_exclude_bands , & photo_slab_max , photo_slab_min use od_io , only : io_error , stdout use od_electronic , only : band_gradient , nbands , band_energy , nspins , electrons_per_state , & & efermi , elec_pdos_read , pdos_weights , pdos_mwab , elec_dealloc_pdos use od_dos_utils , only : doslin , doslin_sub_cell_corners use od_algorithms , only : gaussian use od_constants , only : pi implicit none integer :: ik , is , ib , idos , jb , i integer :: N2 , N_geom , ierr real ( kind = dp ) :: dos_temp , cuml , width , adaptive_smearing_temp , mean_height real ( kind = dp ) :: grad ( 1 : 3 ), step ( 1 : 3 ), EV ( 0 : 4 ), sub_cell_length ( 1 : 3 ) character ( len = 1 ), intent ( in ) :: jdos_type real ( kind = dp ), intent ( inout ), allocatable , optional :: weighted_jdos (:, :, :) real ( kind = dp ), intent ( in ), optional :: matrix_weights (:, :, :, :, :) real ( kind = dp ), intent ( out ), allocatable :: jdos (:, :) logical :: linear , fixed , adaptive , force_adaptive linear = . false . fixed = . false . adaptive = . false . select case ( jdos_type ) case ( \"l\" ) linear = . true . case ( \"a\" ) adaptive = . true . case ( \"f\" ) fixed = . true . case default call io_error ( \" ERROR : unknown jdos_type in calculate_jdos \" ) end select width = 0.0_dp if ( linear . or . adaptive ) step (:) = 1.0_dp / real ( kpoint_grid_dim (:), dp ) / 2.0_dp if ( adaptive . or . hybrid_linear ) then do i = 1 , 3 sub_cell_length ( i ) = sqrt ( recip_lattice ( i , 1 ) ** 2 + recip_lattice ( i , 2 ) ** 2 + recip_lattice ( i , 3 ) ** 2 ) * step ( i ) end do if ( photo ) then mean_height = ( photo_slab_min + photo_slab_max ) / ( 2 * 2 ) sub_cell_length ( 3 ) = sqrt ( recip_lattice ( 3 , 1 ) ** 2 + recip_lattice ( 3 , 2 ) ** 2 + ( pi / mean_height ) ** 2 ) * step ( 3 ) end if adaptive_smearing_temp = adaptive_smearing * sum ( sub_cell_length ) / 3.0_dp end if if ( fixed ) width = fixed_smearing call allocate_jdos ( jdos ) if ( calc_weighted_jdos ) then N_geom = size ( matrix_weights , 5 ) allocate ( weighted_jdos ( jdos_nbins , nspins , N_geom ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: calculate_jdos - failed to allocate weighted_jdos' ) weighted_jdos = 0.0_dp end if if ( iprint > 1 . and . on_root ) then write ( stdout , '(1x,a78)' ) '+------------------------------ Calculate JDOS ------------------------------+' end if do ik = 1 , num_kpoints_on_node ( my_node_id ) if ( iprint > 1 . and . on_root ) then if ( mod ( real ( ik , dp ), 1 0.0_dp ) == 0.0_dp ) write ( stdout , '(1x,a1,a38,i4,a3,i4,1x,a14,3x,a10)' ) ',' , & & \"Calculating k-point \" , ik , \" of\" , num_kpoints_on_node ( my_node_id ), 'on this node.' , \"<-- JDOS |\" end if do is = 1 , nspins occ_states : do ib = 1 , nbands if ( num_exclude_bands > 0 ) then if ( any ( exclude_bands == ib )) cycle end if if ( band_energy ( ib , is , ik ) . ge . efermi ) cycle occ_states unocc_states : do jb = 1 , nbands if ( band_energy ( jb , is , ik ) . lt . efermi ) cycle unocc_states if ( linear . or . adaptive ) grad (:) = band_gradient ( jb , :, ik , is ) - band_gradient ( ib , :, ik , is ) ! If the band is very flat linear broadening can have problems describing it. In this case, fall back to ! adaptive smearing (and take advantage of FBCS if required). force_adaptive = . false . if (. not . fixed ) then if ( hybrid_linear . and . ( hybrid_linear_grad_tol > sqrt ( dot_product ( grad , grad )))) force_adaptive = . true . if ( linear . and . . not . force_adaptive ) call doslin_sub_cell_corners ( grad , step , band_energy ( jb , is , ik ) - & & band_energy ( ib , is , ik ) + scissor_op , EV ) if ( adaptive . or . force_adaptive ) width = sqrt ( dot_product ( grad , grad )) * adaptive_smearing_temp end if ! Hybrid Adaptive -- This way we don't lose weight at very flat parts of the ! band. It's a kind of fudge that we wouldn't need if we had infinitely small bins. if ( finite_bin_correction . and . ( width < delta_bins )) width = delta_bins do idos = 1 , jdos_nbins ! The linear method has a special way to calculate the integrated dos ! we have to take account for this here. if ( linear . and . . not . force_adaptive ) then dos_temp = doslin ( EV ( 0 ), EV ( 1 ), EV ( 2 ), EV ( 3 ), EV ( 4 ), E ( idos ), cuml ) else dos_temp = gaussian ( band_energy ( jb , is , ik ) - band_energy ( ib , is , ik ) + scissor_op , width , E ( idos )) !& end if jdos ( idos , is ) = jdos ( idos , is ) + dos_temp * electrons_per_state * kpoint_weight ( ik ) ! this will become a loop over final index (polarisation) ! Also need to remove kpoints weights. if ( calc_weighted_jdos ) then do N2 = 1 , N_geom weighted_jdos ( idos , is , N2 ) = weighted_jdos ( idos , is , N2 ) + dos_temp * matrix_weights ( ib , jb , ik , is , N2 )& & * electrons_per_state * kpoint_weight ( ik ) end do end if end do end do unocc_states end do occ_states end do end do if ( iprint > 1 . and . on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if end subroutine calculate_jdos","tags":"","loc":"proc/calculate_jdos.html"},{"title":"jdos_deallocate – OptaDOS","text":"public  subroutine jdos_deallocate() Uses od_io proc~~jdos_deallocate~~UsesGraph proc~jdos_deallocate jdos_deallocate module~od_io od_io proc~jdos_deallocate->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~jdos_deallocate~~CallsGraph proc~jdos_deallocate jdos_deallocate proc~io_error io_error proc~jdos_deallocate->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code jdos_deallocate Source Code subroutine jdos_deallocate !=============================================================================== !=============================================================================== use od_io , only : io_error implicit none integer :: ierr if ( allocated ( jdos_adaptive )) then deallocate ( jdos_adaptive , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate jdos_adaptive' ) end if if ( allocated ( jdos_fixed )) then deallocate ( jdos_fixed , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate jdos_fixed' ) end if if ( allocated ( jdos_linear )) then deallocate ( jdos_linear , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate jdos_linear' ) end if if ( allocated ( E )) then deallocate ( E , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate E' ) end if end subroutine jdos_deallocate","tags":"","loc":"proc/jdos_deallocate.html"},{"title":"jdos_utils_calculate – OptaDOS","text":"public  subroutine jdos_utils_calculate(matrix_weights, weighted_jdos) Uses od_parameters od_comms od_dos_utils od_cell od_electronic od_io proc~~jdos_utils_calculate~~UsesGraph proc~jdos_utils_calculate jdos_utils_calculate module~od_parameters od_parameters proc~jdos_utils_calculate->module~od_parameters module~od_comms od_comms proc~jdos_utils_calculate->module~od_comms module~od_dos_utils od_dos_utils proc~jdos_utils_calculate->module~od_dos_utils module~od_cell od_cell proc~jdos_utils_calculate->module~od_cell module~od_electronic od_electronic proc~jdos_utils_calculate->module~od_electronic module~od_io od_io proc~jdos_utils_calculate->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: matrix_weights (:,:,:,:,:) real(kind=dp), intent(out), optional, allocatable :: weighted_jdos (:,:,:) Calls proc~~jdos_utils_calculate~~CallsGraph proc~jdos_utils_calculate jdos_utils_calculate proc~elec_read_band_gradient elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~io_time io_time proc~jdos_utils_calculate->proc~io_time proc~dos_utils_set_efermi dos_utils_set_efermi proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~setup_energy_scale setup_energy_scale proc~jdos_utils_calculate->proc~setup_energy_scale proc~calculate_jdos calculate_jdos proc~jdos_utils_calculate->proc~calculate_jdos proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_calculate->proc~jdos_utils_merge proc~io_error io_error proc~jdos_utils_calculate->proc~io_error proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->proc~io_error interface~comms_bcast comms_bcast proc~elec_read_band_gradient->interface~comms_bcast interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~dos_utils_set_efermi->proc~io_error proc~dos_utils_set_efermi->interface~comms_bcast interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~setup_energy_scale->proc~io_error proc~setup_energy_scale->interface~comms_bcast proc~setup_energy_scale->interface~comms_reduce proc~calculate_jdos->proc~io_error proc~gaussian gaussian proc~calculate_jdos->proc~gaussian proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~calculate_jdos->proc~doslin_sub_cell_corners proc~doslin doslin proc~calculate_jdos->proc~doslin proc~allocate_jdos allocate_jdos proc~calculate_jdos->proc~allocate_jdos proc~jdos_utils_merge->interface~comms_reduce proc~heap_sort heap_sort proc~doslin_sub_cell_corners->proc~heap_sort proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_file_unit proc~elec_dealloc_optical->proc~io_error proc~dos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_calculate->proc~io_time proc~dos_utils_calculate->proc~io_error proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~allocate_jdos->proc~io_error proc~dos_utils_merge->interface~comms_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~jdos_utils_calculate~~CalledByGraph proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code jdos_utils_calculate Source Code subroutine jdos_utils_calculate ( matrix_weights , weighted_jdos ) !=============================================================================== ! Main routine in dos module, drives the calculation of Density of states for ! both task : dos and also if it is required elsewhere. !=============================================================================== use od_parameters , only : linear , fixed , adaptive , quad , iprint , dos_per_volume , photo ,& jdos_max_energy , jdos_spacing , photo use od_electronic , only : elec_read_band_gradient , band_gradient , nspins , electrons_per_state , & num_electrons , efermi_set use od_comms , only : on_root , comms_bcast use od_io , only : stdout , io_error , io_time , seedname use od_cell , only : cell_volume use od_dos_utils , only : dos_utils_set_efermi implicit none !integer :: ierr real ( kind = dp ) :: time0 , time1 real ( kind = dp ), intent ( out ), allocatable , optional :: weighted_jdos (:, :, :) !I've added this real ( kind = dp ), intent ( in ), optional :: matrix_weights (:, :, :, :, :) !I've added this calc_weighted_jdos = . false . if ( present ( matrix_weights )) calc_weighted_jdos = . true . if ( calc_weighted_jdos . eqv . . false .) then ! We are called just to provide jdos. if ( allocated ( E )) then if ( on_root . and . iprint > 1 ) write ( stdout , * ) \" Already calculated jdos, so returning...\" return ! The jdos has already been calculated previously so just return. end if end if !------------------------------------------------------------------------------- ! R E A D   B A N D   G R A D I E N T S ! If we're using one of the more accurate roadening schemes we also need to read in the ! band gradients too if ( quad . or . linear . or . adaptive ) then if (. not . allocated ( band_gradient )) call elec_read_band_gradient end if !------------------------------------------------------------------------------- if (. not . efermi_set ) call dos_utils_set_efermi !------------------------------------------------------------------------------- ! C A L C U L A T E   J D O S ! Now everything is set up, we can perform the dos accumulation in parellel time0 = io_time () call setup_energy_scale ( E ) if ( fixed ) then if ( calc_weighted_jdos ) then call calculate_jdos ( 'f' , jdos_fixed , matrix_weights , weighted_jdos = weighted_jdos ) call jdos_utils_merge ( jdos_fixed , weighted_jdos ) else call calculate_jdos ( 'f' , jdos_fixed ) call jdos_utils_merge ( jdos_fixed ) end if end if if ( adaptive ) then if ( calc_weighted_jdos ) then call calculate_jdos ( 'a' , jdos_adaptive , matrix_weights , weighted_jdos = weighted_jdos ) call jdos_utils_merge ( jdos_adaptive , weighted_jdos ) else call calculate_jdos ( 'a' , jdos_adaptive ) call jdos_utils_merge ( jdos_adaptive ) end if end if if ( linear ) then if ( calc_weighted_jdos ) then call calculate_jdos ( 'l' , jdos_linear , matrix_weights , weighted_jdos = weighted_jdos ) call jdos_utils_merge ( jdos_linear , weighted_jdos ) else call calculate_jdos ( 'l' , jdos_linear ) call jdos_utils_merge ( jdos_linear ) end if end if if ( quad ) then call io_error ( \"quadratic broadening not implemented\" ) !if(quad)    call merge_dos(dos_quad) !if(quad)    call merge_dos(intdos_quad) end if !    if(.not.on_root) then !       if(allocated(E)) deallocate(E, stat=ierr) !       if (ierr/=0) call io_error (\"cannot deallocate  E\") !    endif time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Joint Density of States              & &      ' , time1 - time0 , ' (sec) +' end if !------------------------------------------------------------------------------- if ( dos_per_volume ) then if ( photo ) then if ( fixed ) then jdos_fixed = jdos_fixed end if if ( adaptive ) then jdos_adaptive = jdos_adaptive end if if ( linear ) then jdos_linear = jdos_linear end if else if ( fixed ) then jdos_fixed = jdos_fixed / cell_volume end if if ( adaptive ) then jdos_adaptive = jdos_adaptive / cell_volume end if if ( linear ) then jdos_linear = jdos_linear / cell_volume end if end if ! if(quad) then !    dos_quad=dos_quad/cell_volume !    intdos_quad=intdos_quad/cell_volume ! endif end if end subroutine jdos_utils_calculate","tags":"","loc":"proc/jdos_utils_calculate.html"},{"title":"jdos_utils_merge – OptaDOS","text":"public  subroutine jdos_utils_merge(jdos, weighted_jdos) Uses od_comms od_electronic od_parameters proc~~jdos_utils_merge~~UsesGraph proc~jdos_utils_merge jdos_utils_merge module~od_comms od_comms proc~jdos_utils_merge->module~od_comms module~od_parameters od_parameters proc~jdos_utils_merge->module~od_parameters module~od_electronic od_electronic proc~jdos_utils_merge->module~od_electronic module~od_constants od_constants module~od_comms->module~od_constants module~od_parameters->module~od_constants module~od_io od_io module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_electronic->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: jdos (:,:) real(kind=dp), intent(inout), optional, allocatable :: weighted_jdos (:,:,:) Calls proc~~jdos_utils_merge~~CallsGraph proc~jdos_utils_merge jdos_utils_merge interface~comms_reduce comms_reduce proc~jdos_utils_merge->interface~comms_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~jdos_utils_merge~~CalledByGraph proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~jdos_utils_merge proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code jdos_utils_merge Source Code subroutine jdos_utils_merge ( jdos , weighted_jdos ) !=============================================================================== ! The DOS was calculated accross nodes. Now give them all back to root ! and free up the memeory on the slaves !------------------------------------------------------------------------------- ! Arguments: dos          (in - slaves) (inout -  root)       : The DOS !            weighted_dos (in - slaves) (inout -  root) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_comms , only : comms_reduce use od_electronic , only : nspins use od_parameters , only : photo implicit none real ( kind = dp ), intent ( inout ), allocatable , optional :: weighted_jdos (:, :, :) ! bins.spins, orbitals real ( kind = dp ), allocatable , intent ( inout ) :: jdos (:, :) integer :: N_geom if ( present ( weighted_jdos )) N_geom = size ( weighted_jdos , 3 ) call comms_reduce ( jdos ( 1 , 1 ), nspins * jdos_nbins , \"SUM\" ) if ( present ( weighted_jdos )) call comms_reduce ( weighted_jdos ( 1 , 1 , 1 ), nspins * jdos_nbins * N_geom , \"SUM\" ) !    if(.not.on_root) then !       if(allocated(jdos)) deallocate(jdos,stat=ierr) !       if (ierr/=0) call io_error (\" ERROR : jdos : merge_jdos : cannot deallocate dos\") !       if(present(weighted_jdos))  then !          if(allocated(weighted_jdos)) deallocate(weighted_jdos,stat=ierr) !          if (ierr/=0) call io_error (\" ERROR : jdos : merge_jdos : cannot deallocate weighted_dos\") !       end if !    endif end subroutine jdos_utils_merge","tags":"","loc":"proc/jdos_utils_merge.html"},{"title":"setup_energy_scale – OptaDOS","text":"public  subroutine setup_energy_scale(E) Uses od_parameters od_dos_utils od_comms od_electronic od_io proc~~setup_energy_scale~~UsesGraph proc~setup_energy_scale setup_energy_scale module~od_parameters od_parameters proc~setup_energy_scale->module~od_parameters module~od_dos_utils od_dos_utils proc~setup_energy_scale->module~od_dos_utils module~od_io od_io proc~setup_energy_scale->module~od_io module~od_comms od_comms proc~setup_energy_scale->module~od_comms module~od_electronic od_electronic proc~setup_energy_scale->module~od_electronic module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_io->module~od_constants module~od_comms->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), optional, allocatable :: E (:) Calls proc~~setup_energy_scale~~CallsGraph proc~setup_energy_scale setup_energy_scale interface~comms_reduce comms_reduce proc~setup_energy_scale->interface~comms_reduce interface~comms_bcast comms_bcast proc~setup_energy_scale->interface~comms_bcast proc~io_error io_error proc~setup_energy_scale->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_energy_scale~~CalledByGraph proc~setup_energy_scale setup_energy_scale proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~setup_energy_scale proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate program~optados optados program~optados->proc~jdos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_energy_scale Source Code subroutine setup_energy_scale ( E ) !=============================================================================== ! Sets up all broadening independent DOS concerns ! Calls the relevant dos calculator. !=============================================================================== use od_dos_utils , only : dos_utils_calculate use od_parameters , only : jdos_max_energy , jdos_spacing , iprint use od_electronic , only : efermi , band_energy use od_comms , only : comms_reduce , comms_bcast , on_root use od_io , only : stdout , io_error implicit none integer :: idos , ierr real ( kind = dp ) :: max_band_energy real ( kind = dp ), intent ( out ), allocatable , optional :: E (:) if ( jdos_max_energy < 0.0_dp ) then ! we have to work it out ourselves max_band_energy = maxval ( band_energy ) call comms_reduce ( max_band_energy , 1 , 'MAX' ) call comms_bcast ( max_band_energy , 1 ) jdos_max_energy = efermi - max_band_energy if ( on_root . and . ( iprint > 2 )) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) & & '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) & & '|' , 'max_band_energy (before correction) : ' ,& & max_band_energy , \"<-- JDOS Grid |\" end if end if jdos_nbins = abs ( ceiling ( jdos_max_energy / jdos_spacing )) jdos_max_energy = jdos_nbins * jdos_spacing allocate ( E ( 1 : jdos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"Error: jdos_utils, setup_energy_scale: cannot allocate E\" ) delta_bins = jdos_max_energy / real ( jdos_nbins - 1 , dp ) do idos = 1 , jdos_nbins E ( idos ) = real ( idos - 1 , dp ) * delta_bins end do if ( on_root . and . ( iprint > 2 )) then write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'efermi : ' , efermi , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'jdos_max_energy : ' , jdos_max_energy , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,i11,13x,a15)' ) '|' , ' jdos_nbins : ' , jdos_nbins , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'jdos_spacing : ' , jdos_spacing , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'delta_bins : ' , delta_bins , \"<-- JDOS Grid |\" write ( stdout , '(1x,a78)' ) & '+----------------------------------------------------------------------------+' end if end subroutine setup_energy_scale","tags":"","loc":"proc/setup_energy_scale.html"},{"title":"calc_absorp – OptaDOS","text":"public  subroutine calc_absorp() Uses od_jdos_utils proc~~calc_absorp~~UsesGraph proc~calc_absorp calc_absorp module~od_jdos_utils od_jdos_utils proc~calc_absorp->module~od_jdos_utils module~od_constants od_constants module~od_jdos_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine calculates the absorption coefficient Arguments None Called by proc~~calc_absorp~~CalledByGraph proc~calc_absorp calc_absorp proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_absorp program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_absorp Source Code subroutine calc_absorp !*************************************************************** ! This subroutine calculates the absorption coefficient use od_jdos_utils , only : jdos_nbins , E integer :: N_energy allocate ( absorp ( jdos_nbins )) absorp = 0.0_dp do N_energy = 1 , jdos_nbins absorp ( N_energy ) = 2 * refract ( N_energy , 2 ) * E ( N_energy ) * e_charge / ( hbar * c_speed ) end do end subroutine calc_absorp","tags":"","loc":"proc/calc_absorp.html"},{"title":"calc_conduct – OptaDOS","text":"public  subroutine calc_conduct() Uses od_parameters od_jdos_utils proc~~calc_conduct~~UsesGraph proc~calc_conduct calc_conduct module~od_parameters od_parameters proc~calc_conduct->module~od_parameters module~od_jdos_utils od_jdos_utils proc~calc_conduct->module~od_jdos_utils module~od_cell od_cell module~od_parameters->module~od_cell module~od_io od_io module~od_parameters->module~od_io module~od_constants od_constants module~od_parameters->module~od_constants module~od_jdos_utils->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine calculates the conductivity Arguments None Called by proc~~calc_conduct~~CalledByGraph proc~calc_conduct calc_conduct proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_conduct program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_conduct Source Code subroutine calc_conduct !*************************************************************** ! This subroutine calculates the conductivity use od_jdos_utils , only : jdos_nbins , E use od_parameters , only : optics_intraband integer :: N_energy allocate ( conduct ( 1 : jdos_nbins , 2 )) conduct = 0.0_dp if (. not . optics_intraband ) then do N_energy = 1 , jdos_nbins conduct ( N_energy , 1 ) = ( E ( N_energy ) * e_charge / hbar ) * epsilon_0 * epsilon ( N_energy , 2 , 1 , 1 ) end do do N_energy = 1 , jdos_nbins conduct ( N_energy , 2 ) = ( E ( N_energy ) * e_charge / hbar ) * epsilon_0 * ( 1.0_dp - epsilon ( N_energy , 1 , 1 , 1 )) end do else do N_energy = 1 , jdos_nbins conduct ( N_energy , 1 ) = epsilon_0 * epsilon ( N_energy , 2 , 1 , 3 ) / hbar end do do N_energy = 1 , jdos_nbins conduct ( N_energy , 2 ) = ( E ( N_energy ) * e_charge / hbar ) * epsilon_0 * ( 1.0_dp - epsilon ( N_energy , 1 , 1 , 3 )) end do end if end subroutine calc_conduct","tags":"","loc":"proc/calc_conduct.html"},{"title":"calc_epsilon_1 – OptaDOS","text":"public  subroutine calc_epsilon_1() Uses od_jdos_utils od_parameters od_comms od_constants od_io proc~~calc_epsilon_1~~UsesGraph proc~calc_epsilon_1 calc_epsilon_1 module~od_jdos_utils od_jdos_utils proc~calc_epsilon_1->module~od_jdos_utils module~od_parameters od_parameters proc~calc_epsilon_1->module~od_parameters module~od_comms od_comms proc~calc_epsilon_1->module~od_comms module~od_io od_io proc~calc_epsilon_1->module~od_io module~od_constants od_constants proc~calc_epsilon_1->module~od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_comms->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine uses kramers kronig to calculate epsilon_1 Arguments None Called by proc~~calc_epsilon_1~~CalledByGraph proc~calc_epsilon_1 calc_epsilon_1 proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_epsilon_1 program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_epsilon_1 Source Code subroutine calc_epsilon_1 !*************************************************************** ! This subroutine uses kramers kronig to calculate epsilon_1 use od_constants , only : dp , pi use od_jdos_utils , only : E , jdos_nbins use od_parameters , only : optics_intraband , optics_drude_broadening , iprint use od_comms , only : on_root use od_io , only : stdout integer :: N_energy integer :: N_energy2 integer :: N2 real ( kind = dp ), allocatable , dimension (:) :: q real ( kind = dp ) :: energy1 real ( kind = dp ) :: energy2 real ( kind = dp ) :: dE integer :: i , jdos_bin , j dE = E ( 2 ) - E ( 1 ) if (. not . optics_intraband ) then allocate ( q ( 1 )) else allocate ( q ( 3 )) end if do N2 = 1 , N_geom do N_energy = 1 , jdos_nbins q = 0.0_dp do N_energy2 = 1 , jdos_nbins if ( N_energy2 . ne . N_energy ) then energy1 = E ( N_energy ) energy2 = E ( N_energy2 ) q ( 1 ) = q ( 1 ) + ((( energy2 * epsilon ( N_energy2 , 2 , N2 , 1 )) / (( energy2 ** 2 ) - ( energy1 ** 2 ))) * dE ) if ( optics_intraband ) then q ( 2 ) = q ( 2 ) + (( dE * epsilon ( N_energy2 , 2 , N2 , 2 )) / ((( energy2 ** 2 ) - ( energy1 ** 2 )) * e_charge )) q ( 3 ) = q ( 3 ) + (( dE * epsilon ( N_energy2 , 2 , N2 , 3 )) / ((( energy2 ** 2 ) - ( energy1 ** 2 )) * e_charge )) end if end if end do if ( N2 . le . 3 ) then epsilon ( N_energy , 1 , N2 , 1 ) = (( 2.0_dp / pi ) * q ( 1 )) + 1.0_dp else epsilon ( N_energy , 1 , N2 , 1 ) = (( 2.0_dp / pi ) * q ( 1 )) end if if ( optics_intraband ) then !             epsilon(N_energy,1,N2,2)=((2.0_dp/pi)*q(2))+1.0_dp  !! old KK method epsilon ( N_energy , 1 , N2 , 2 ) = 1.0_dp - ( intra ( N2 ) / (( E ( N_energy ) ** 2 ) & & + ((( optics_drude_broadening * hbar ) / e_charge ) ** 2 ))) !             epsilon(N_energy,1,N2,3)=((2.0_dp/pi)*q(3))+1.0_dp  !! old KK method epsilon ( N_energy , 1 , N2 , 3 ) = epsilon ( N_energy , 1 , N2 , 1 ) + epsilon ( N_energy , 1 , N2 , 2 ) - 1.0_dp end if end do end do end subroutine calc_epsilon_1","tags":"","loc":"proc/calc_epsilon_1.html"},{"title":"calc_epsilon_2 – OptaDOS","text":"public  subroutine calc_epsilon_2(weighted_jdos, weighted_dos_at_e, photo_atom_volume) Uses od_parameters od_jdos_utils od_comms od_cell od_constants od_electronic od_io proc~~calc_epsilon_2~~UsesGraph proc~calc_epsilon_2 calc_epsilon_2 module~od_parameters od_parameters proc~calc_epsilon_2->module~od_parameters module~od_comms od_comms proc~calc_epsilon_2->module~od_comms module~od_jdos_utils od_jdos_utils proc~calc_epsilon_2->module~od_jdos_utils module~od_constants od_constants proc~calc_epsilon_2->module~od_constants module~od_cell od_cell proc~calc_epsilon_2->module~od_cell module~od_electronic od_electronic proc~calc_epsilon_2->module~od_electronic module~od_io od_io proc~calc_epsilon_2->module~od_io module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_jdos_utils->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_electronic->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine calculates epsilon_2 don't include 0eV as it makes in intraband case blow up (and should be zero otherwise) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), allocatable, dimension(:, :, :) :: weighted_jdos real(kind=dp), intent(in), allocatable, dimension(:, :) :: weighted_dos_at_e real(kind=dp), intent(in), optional :: photo_atom_volume Called by proc~~calc_epsilon_2~~CalledByGraph proc~calc_epsilon_2 calc_epsilon_2 proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_epsilon_2 program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_epsilon_2 Source Code subroutine calc_epsilon_2 ( weighted_jdos , weighted_dos_at_e , photo_atom_volume ) !*************************************************************** ! This subroutine calculates epsilon_2 use od_constants , only : dp , pi use od_cell , only : nkpoints , cell_volume use od_electronic , only : nspins , electrons_per_state , nbands use od_jdos_utils , only : E , jdos_nbins use od_parameters , only : optics_intraband , optics_drude_broadening , photo , iprint use od_io , only : stdout use od_comms , only : on_root real ( kind = dp ), intent ( in ), allocatable , dimension (:, :, :) :: weighted_jdos real ( kind = dp ), intent ( in ), allocatable , dimension (:, :) :: weighted_dos_at_e real ( kind = dp ), intent ( in ), optional :: photo_atom_volume integer :: N_energy integer :: N integer :: N_spin integer :: N2 integer :: jdos_bin integer :: i , j real ( kind = dp ) :: dE real ( kind = dp ) :: x real ( kind = dp ) :: epsilon2_const dE = E ( 2 ) - E ( 1 ) if ( present ( photo_atom_volume )) then epsilon2_const = ( e_charge * pi * 1E-20 ) / ( photo_atom_volume * 1E-30 * epsilon_0 ) write ( stdout , '(1x,a33,1x,f15.8,3x,a25)' ) '+------------ Using atom_volume =' , photo_atom_volume , '------------------------+' else write ( stdout , '(1x,a78)' ) '+----------------------------- Using cell_volume ----------------------------+' epsilon2_const = ( e_charge * pi * 1E-20 ) / ( cell_volume * 1E-30 * epsilon_0 ) end if !epsilon2_const = (e_charge*pi*1E-20)/(cell_volume*1E-30*epsilon_0) if ( optics_intraband ) then allocate ( intra ( N_geom )) intra = 0.0_dp do N = 1 , N_geom do N_spin = 1 , nspins intra ( N ) = intra ( N ) + weighted_dos_at_e ( N_spin , N ) end do end do if ( present ( photo_atom_volume )) then write ( stdout , '(1x,a33,1x,f15.8,3x,a25)' ) '+------------ Using atom_volume =' , photo_atom_volume , '------------------------+' intra = intra * e_charge / ( photo_atom_volume * 1E-10 * epsilon_0 ) else write ( stdout , '(1x,a78)' ) '+----------------------------- Using cell_volume ----------------------------+' intra = intra * e_charge / ( cell_volume * 1E-10 * epsilon_0 ) end if ! intra = intra*e_charge/(cell_volume*1E-10*epsilon_0) end if if (. not . optics_intraband ) then allocate ( epsilon ( jdos_nbins , 2 , N_geom , 1 )) else allocate ( epsilon ( jdos_nbins , 2 , N_geom , 3 )) end if epsilon = 0.0_dp do N2 = 1 , N_geom do N_spin = 1 , nspins ! Loop over spins do N_energy = 2 , jdos_nbins epsilon ( N_energy , 2 , N2 , 1 ) = epsilon ( N_energy , 2 , N2 , 1 ) + & epsilon2_const * weighted_jdos ( N_energy , N_spin , N2 ) if ( optics_intraband ) then epsilon ( N_energy , 2 , N2 , 2 ) = epsilon ( N_energy , 2 , N2 , 2 ) + & &(( intra ( N2 ) * ( e_charge ** 2 ) * hbar * optics_drude_broadening ) & & / ((( E ( N_energy ) * e_charge ) ** 2 ) & & + (( optics_drude_broadening * hbar ) ** 2 ))) epsilon ( N_energy , 2 , N2 , 3 ) = epsilon ( N_energy , 2 , N2 , 3 ) + & & epsilon ( N_energy , 2 , N2 , 2 ) & & + epsilon ( N_energy , 2 , N2 , 1 ) * E ( N_energy ) * e_charge end if end do end do end do ! Sum rule if ( N_geom == 1 ) then x = 0.0_dp do N = 2 , jdos_nbins !! don't include 0eV as it makes in intraband case blow up (and should be zero otherwise) if (. not . optics_intraband ) then x = x + (( N * ( dE ** 2 ) * epsilon ( N , 2 , 1 , 1 )) / ( hbar ** 2 )) else x = x + (( N * ( dE ** 2 ) * epsilon ( N , 2 , 1 , 3 )) / (( hbar ** 2 ) * E ( N ) * e_charge )) end if end do if ( present ( photo_atom_volume )) then N_eff = ( x * e_mass * photo_atom_volume * 1E-30 * epsilon_0 * 2 ) / ( pi ) else write ( stdout , '(1x,a78)' ) '+----------------------------- Using cell_volume ----------------------------+' N_eff = ( x * e_mass * cell_volume * 1E-30 * epsilon_0 * 2 ) / ( pi ) end if ! N_eff = (x*e_mass*cell_volume*1E-30*epsilon_0*2)/(pi) end if end subroutine calc_epsilon_2","tags":"","loc":"proc/calc_epsilon_2.html"},{"title":"calc_loss_fn – OptaDOS","text":"public  subroutine calc_loss_fn() Uses od_jdos_utils od_parameters od_constants od_cell proc~~calc_loss_fn~~UsesGraph proc~calc_loss_fn calc_loss_fn module~od_jdos_utils od_jdos_utils proc~calc_loss_fn->module~od_jdos_utils module~od_parameters od_parameters proc~calc_loss_fn->module~od_parameters module~od_constants od_constants proc~calc_loss_fn->module~od_constants module~od_cell od_cell proc~calc_loss_fn->module~od_cell module~od_jdos_utils->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_io od_io module~od_parameters->module~od_io module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine calculates the loss function and the sum rules Arguments None Called by proc~~calc_loss_fn~~CalledByGraph proc~calc_loss_fn calc_loss_fn proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_loss_fn program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_loss_fn Source Code subroutine calc_loss_fn !*************************************************************** ! This subroutine calculates the loss function and the sum rules use od_constants , only : dp , cmplx_i , pi use od_jdos_utils , only : E , jdos_nbins use od_cell , only : cell_volume use od_parameters , only : optics_intraband , optics_lossfn_broadening , optics_lossfn_gaussian complex ( kind = dp ) :: g integer :: N_energy integer :: N_energy2 real ( kind = dp ) :: x real ( kind = dp ) :: dE if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then allocate ( loss_fn ( jdos_nbins , 2 )) else allocate ( loss_fn ( jdos_nbins , 1 )) end if else if ( optics_lossfn_broadening ) then allocate ( loss_fn ( jdos_nbins , 4 )) else allocate ( loss_fn ( jdos_nbins , 3 )) end if end if loss_fn = 0.0_dp dE = E ( 2 ) - E ( 1 ) g = ( 0.0_dp , 0.0_dp ) do N_energy = 1 , jdos_nbins g = epsilon ( N_energy , 1 , 1 , 1 ) + ( cmplx_i * epsilon ( N_energy , 2 , 1 , 1 )) loss_fn ( N_energy , 1 ) = - 1 * aimag ( 1.0_dp / g ) if ( optics_intraband ) then if ( N_energy == 1 ) then loss_fn ( 1 , 2 ) = 0.0_dp loss_fn ( 1 , 3 ) = 0.0_dp else g = epsilon ( N_energy , 1 , 1 , 2 ) + ( cmplx_i * epsilon ( N_energy , 2 , 1 , 2 ) / ( E ( N_energy ) * e_charge )) loss_fn ( N_energy , 2 ) = - 1 * aimag ( 1.0_dp / g ) g = epsilon ( N_energy , 1 , 1 , 3 ) + ( cmplx_i * epsilon ( N_energy , 2 , 1 , 3 ) / ( E ( N_energy ) * e_charge )) loss_fn ( N_energy , 3 ) = - 1 * aimag ( 1.0_dp / g ) end if end if end do ! Broadening if ( optics_lossfn_broadening ) then if (. not . optics_intraband ) then do N_energy = 1 , jdos_nbins ! Loop over energy do N_energy2 = 1 , jdos_nbins ! Turn each energy value into a function g = ((( 4.0_dp * log ( 2.0_dp )) / pi ) ** ( 0.5_dp )) * & & ( 1.0_dp / optics_lossfn_gaussian ) * exp ( - 4.0_dp * ( log ( 2.0_dp )) * & & ((( E ( N_energy2 ) - E ( N_energy )) / optics_lossfn_gaussian ) ** 2.0_dp )) ! Gaussian loss_fn ( N_energy2 , 2 ) = loss_fn ( N_energy2 , 2 ) + ( g * loss_fn ( N_energy , 1 ) * dE ) end do end do ! End loop over energy end if if ( optics_intraband ) then do N_energy = 1 , jdos_nbins ! Loop over energy do N_energy2 = 1 , jdos_nbins ! Turn each energy value into a function g = ((( 4.0_dp * log ( 2.0_dp )) / pi ) ** ( 0.5_dp )) * & & ( 1.0_dp / optics_lossfn_gaussian ) * exp ( - 4.0_dp * ( log ( 2.0_dp )) * & & ((( E ( N_energy2 ) - E ( N_energy )) / optics_lossfn_gaussian ) ** 2.0_dp )) ! Gaussian loss_fn ( N_energy2 , 4 ) = loss_fn ( N_energy2 , 4 ) + ( g * loss_fn ( N_energy , 3 ) * dE ) end do end do ! End loop over energy end if end if ! Sum rule 1 x = 0.0_dp do N_energy = 2 , jdos_nbins if (. not . optics_intraband ) then x = x + ( N_energy * ( dE ** 2 ) * loss_fn ( N_energy , 1 )) else x = x + ( N_energy * ( dE ** 2 ) * loss_fn ( N_energy , 3 )) end if end do N_eff2 = x * ( e_mass * cell_volume * 1E-30 * epsilon_0 * 2 ) / ( pi * ( hbar ** 2 )) ! Sum rule 2 x = 0 do N_energy = 2 , jdos_nbins if (. not . optics_intraband ) then x = x + ( loss_fn ( N_energy , 1 ) / N_energy ) else x = x + ( loss_fn ( N_energy , 3 ) / N_energy ) end if end do N_eff3 = x end subroutine calc_loss_fn","tags":"","loc":"proc/calc_loss_fn.html"},{"title":"calc_reflect – OptaDOS","text":"public  subroutine calc_reflect() Uses od_jdos_utils proc~~calc_reflect~~UsesGraph proc~calc_reflect calc_reflect module~od_jdos_utils od_jdos_utils proc~calc_reflect->module~od_jdos_utils module~od_constants od_constants module~od_jdos_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine calculates the reflection coefficient Arguments None Called by proc~~calc_reflect~~CalledByGraph proc~calc_reflect calc_reflect proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_reflect program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_reflect Source Code subroutine calc_reflect !*************************************************************** ! This subroutine calculates the reflection coefficient use od_jdos_utils , only : E , jdos_nbins integer :: N_energy allocate ( reflect ( jdos_nbins )) reflect = 0.0_dp do N_energy = 1 , jdos_nbins reflect ( N_energy ) = ((( refract ( N_energy , 1 ) - 1 ) ** 2 ) + ( refract ( N_energy , 2 ) ** 2 )) / & &((( refract ( N_energy , 1 ) + 1 ) ** 2 ) + ( refract ( N_energy , 2 ) ** 2 )) end do end subroutine calc_reflect","tags":"","loc":"proc/calc_reflect.html"},{"title":"calc_refract – OptaDOS","text":"public  subroutine calc_refract() Uses od_parameters od_jdos_utils proc~~calc_refract~~UsesGraph proc~calc_refract calc_refract module~od_parameters od_parameters proc~calc_refract->module~od_parameters module~od_jdos_utils od_jdos_utils proc~calc_refract->module~od_jdos_utils module~od_cell od_cell module~od_parameters->module~od_cell module~od_io od_io module~od_parameters->module~od_io module~od_constants od_constants module~od_parameters->module~od_constants module~od_jdos_utils->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine calculates the refractive index Arguments None Called by proc~~calc_refract~~CalledByGraph proc~calc_refract calc_refract proc~optics_calculate optics_calculate proc~optics_calculate->proc~calc_refract program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calc_refract Source Code subroutine calc_refract !*************************************************************** ! This subroutine calculates the refractive index use od_jdos_utils , only : jdos_nbins , E use od_parameters , only : optics_intraband integer :: N_energy allocate ( refract ( jdos_nbins , 2 )) refract = 0.0_dp if (. not . optics_intraband ) then do N_energy = 1 , jdos_nbins refract ( N_energy , 1 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 1 ) ** 2 ) + & &( epsilon ( N_energy , 2 , 1 , 1 ) ** 2 )) ** 0.5_dp ) + epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do do N_energy = 1 , jdos_nbins refract ( N_energy , 2 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 1 ) ** 2 ) + & &( epsilon ( N_energy , 2 , 1 , 1 ) ** 2 )) ** 0.5_dp ) - epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do else do N_energy = 2 , jdos_nbins refract ( N_energy , 1 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 3 ) ** 2 ) + & &(( epsilon ( N_energy , 2 , 1 , 3 ) / ( E ( N_energy ) * e_charge )) ** 2 )) ** 0.5_dp ) + epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do do N_energy = 2 , jdos_nbins refract ( N_energy , 2 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 1 ) ** 2 ) + & &(( epsilon ( N_energy , 2 , 1 , 3 ) / ( E ( N_energy ) * e_charge )) ** 2 )) ** 0.5_dp ) - epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do end if end subroutine calc_refract","tags":"","loc":"proc/calc_refract.html"},{"title":"make_weights – OptaDOS","text":"public  subroutine make_weights(matrix_weights) Uses od_parameters od_comms od_cell od_constants od_electronic od_io proc~~make_weights~~UsesGraph proc~make_weights make_weights module~od_parameters od_parameters proc~make_weights->module~od_parameters module~od_comms od_comms proc~make_weights->module~od_comms module~od_constants od_constants proc~make_weights->module~od_constants module~od_cell od_cell proc~make_weights->module~od_cell module~od_electronic od_electronic proc~make_weights->module~od_electronic module~od_io od_io proc~make_weights->module~od_io module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_electronic->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable, dimension(:, :, :, :, :) :: matrix_weights Calls proc~~make_weights~~CallsGraph proc~make_weights make_weights proc~cell_get_symmetry cell_get_symmetry proc~make_weights->proc~cell_get_symmetry proc~io_error io_error proc~make_weights->proc~io_error proc~cell_get_symmetry->proc~io_error proc~io_file_unit io_file_unit proc~cell_get_symmetry->proc~io_file_unit interface~comms_bcast comms_bcast proc~cell_get_symmetry->interface~comms_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~make_weights~~CalledByGraph proc~make_weights make_weights proc~optics_calculate optics_calculate proc~optics_calculate->proc~make_weights program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code make_weights Source Code subroutine make_weights ( matrix_weights ) !*************************************************************** use od_constants , only : dp use od_electronic , only : nbands , nspins , optical_mat , num_electrons , & electrons_per_state , band_energy , efermi use od_cell , only : nkpoints , cell_volume , num_kpoints_on_node , cell_get_symmetry , & num_crystal_symmetry_operations , crystal_symmetry_operations , kpoint_r use od_parameters , only : optics_geom , optics_qdir , legacy_file_format , scissor_op , devel_flag use od_io , only : io_error , stdout use od_comms , only : my_node_id real ( kind = dp ), intent ( out ), allocatable , dimension (:, :, :, :, :) :: matrix_weights real ( kind = dp ), dimension ( 3 ) :: qdir real ( kind = dp ), dimension ( 3 ) :: qdir1 real ( kind = dp ), dimension ( 3 ) :: qdir2 real ( kind = dp ) :: q_weight1 real ( kind = dp ) :: q_weight2 integer :: N , i , j , k integer :: N_in integer :: N_spin integer :: N2 , N3 integer :: n_eigen integer :: n_eigen2 integer :: num_symm real ( kind = dp ), dimension ( 2 ) :: num_occ complex ( kind = dp ), dimension ( 3 ) :: g real ( kind = dp ) :: factor integer :: gamma_is , top_filled_band , upper_window , lower_window character ( len = 30 ) :: rowfmt logical :: print_omes print_omes = . false . ! Only set to true if you want the experiemental OME writing top_filled_band = 0 gamma_is = - 1 if (. not . legacy_file_format . and . index ( devel_flag , 'old_filename' ) > 0 ) then num_symm = 0 call cell_get_symmetry end if ! otherwise we have already set this num_symm = num_crystal_symmetry_operations !      Do N=1,num_symm !         Do N2=1,3 !            print *, crystal_symmetry_operations(1,N2,N), crystal_symmetry_operations(2,N2,N), crystal_symmetry_operations(3,N2,N) !         end do !         print *,'# ' !      end do num_occ = 0.0_dp do N_spin = 1 , nspins num_occ ( N_spin ) = num_electrons ( N_spin ) end do if ( electrons_per_state == 2 ) then num_occ ( 1 ) = num_occ ( 1 ) / 2.0_dp end if if (. not . index ( optics_geom , 'tensor' ) > 0 ) then ! I can rewrite this in a simplier way?? N_geom = 1 elseif ( index ( optics_geom , 'tensor' ) > 0 ) then N_geom = 6 end if allocate ( matrix_weights ( nbands , nbands , num_kpoints_on_node ( my_node_id ), nspins , N_geom )) matrix_weights = 0.0_dp if ( index ( optics_geom , 'polar' ) > 0 ) then qdir = optics_qdir q_weight = (( qdir ( 1 ) ** 2 ) + ( qdir ( 2 ) ** 2 ) + ( qdir ( 3 ) ** 2 )) ** 0.5_dp if ( q_weight < 0.001_dp ) & call io_error ( \"Error:  please check optics_qdir, norm close to zero\" ) end if if ( index ( optics_geom , 'unpolar' ) > 0 ) then if ( optics_qdir ( 3 ) == 0 ) then qdir1 ( 1 ) = 0.0_dp qdir1 ( 2 ) = 0.0_dp qdir1 ( 3 ) = 1.0_dp else qdir1 ( 1 ) = 1.0_dp qdir1 ( 2 ) = 1.0_dp qdir1 ( 3 ) = - ( optics_qdir ( 1 ) + optics_qdir ( 2 )) / optics_qdir ( 3 ) end if qdir2 ( 1 ) = ( optics_qdir ( 2 ) * qdir1 ( 3 )) - ( optics_qdir ( 3 ) * qdir1 ( 2 )) qdir2 ( 2 ) = ( optics_qdir ( 3 ) * qdir1 ( 1 )) - ( optics_qdir ( 1 ) * qdir1 ( 3 )) qdir2 ( 3 ) = ( optics_qdir ( 1 ) * qdir1 ( 2 )) - ( optics_qdir ( 2 ) * qdir1 ( 1 )) q_weight1 = (( qdir1 ( 1 ) ** 2 ) + ( qdir1 ( 2 ) ** 2 ) + ( qdir1 ( 3 ) ** 2 )) ** 0.5_dp q_weight2 = (( qdir2 ( 1 ) ** 2 ) + ( qdir2 ( 2 ) ** 2 ) + ( qdir2 ( 3 ) ** 2 )) ** 0.5_dp end if N_in = 1 ! 0 = no inversion, 1 = inversion g = 0.0_dp do N = 1 , num_kpoints_on_node ( my_node_id ) ! Loop over kpoints if ( print_omes ) then ! If .not. then hopefully the compiler will get rid of this at ! compile time, and there's no 'if' overhead. AJM May 2018 if (( kpoint_r ( 1 , N ) ** 2 + kpoint_r ( 2 , N ) ** 2 + kpoint_r ( 3 , N ) ** 2 ) < 0.01 ) then write ( stdout , * ) kpoint_r ( 1 , N ) ** 2 + kpoint_r ( 2 , N ) ** 2 + kpoint_r ( 3 , N ) ** 2 , \" = kpoint norm \" write ( stdout , * ) \" N= \" , N gamma_is = N end if end if do N_spin = 1 , nspins ! Loop over spins do n_eigen = 1 , nbands ! Loop over state 1 do n_eigen2 = n_eigen , nbands ! Loop over state 2 if ( band_energy ( n_eigen , N_spin , N ) > efermi . and . n_eigen /= n_eigen2 ) cycle if ( band_energy ( n_eigen2 , N_spin , N ) < efermi . and . n_eigen /= n_eigen2 ) cycle factor = 0.0_dp if ( n_eigen2 == n_eigen ) then factor = 1.0_dp elseif ( band_energy ( n_eigen2 , N_spin , N ) > efermi ) then factor = 1.0_dp / (( band_energy ( n_eigen2 , N_spin , N ) - band_energy ( n_eigen , N_spin , N ) & + scissor_op ) ** 2 ) end if if ( index ( optics_geom , 'unpolar' ) > 0 ) then if ( num_symm == 0 ) then g ( 1 ) = ((( qdir1 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir1 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir1 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight1 ) g ( 2 ) = ((( qdir2 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir2 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir2 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight2 ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & 0.5_dp * factor * ( real ( g ( 1 ) * conjg ( g ( 1 )), dp ) + real ( g ( 2 ) * conjg ( g ( 2 )), dp )) else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in do i = 1 , 3 qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * qdir1 ( j )) end do end do g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight1 ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & ( 0.5_dp / Real (( num_symm * ( N_in + 1 )), dp )) * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) * factor g ( 1 ) = 0.0_dp do i = 1 , 3 ! if I include an extra variable I can merge this and the last do loops qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * qdir2 ( j )) end do end do g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight2 ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & ( 0.5_dp / Real (( num_symm * ( N_in + 1 )), dp )) * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) * factor end do end do end if elseif ( index ( optics_geom , 'polar' ) > 0 ) then if ( num_symm == 0 ) then g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) !           matrix_weights(n_eigen,n_eigen2,N,N_spin) = 1.0_dp  ! for JDOS else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in do i = 1 , 3 qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * optics_qdir ( j )) end do end do g ( 1 ) = 0.0_dp g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & ( 1.0_dp / Real (( num_symm * ( N_in + 1 )), dp )) * factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) end do end do end if elseif ( index ( optics_geom , 'poly' ) > 0 ) then if ( num_symm == 0 ) then do N2 = 1 , 3 g ( N2 ) = optical_mat ( n_eigen , n_eigen2 , N2 , N , N_spin ) !if (n_eigen==1) then !if (n_eigen2==NINT(num_occ(N_spin)+1)) then !print *, N, N2 !print *, g(N2), abs(g(N2)) !print *, optical_mat(n_eigen2,n_eigen,N2,N,N_spin) !print *, optical_mat(n_eigen,n_eigen,N2,N,N_spin), optical_mat(n_eigen2,n_eigen2,N2,N,N_spin) !end if !end if end do matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = ( factor / 3.0_dp ) * & & ( real ( g ( 1 ) * conjg ( g ( 1 )), dp ) + real ( g ( 2 ) * conjg ( g ( 2 )), dp ) + & & real ( g ( 3 ) * conjg ( g ( 3 )), dp )) ! write (*, *) matrix_weights(n_eigen, n_eigen2, N, N_spin, N_geom) !                 print *, n_eigen, n_eigen2, N, matrix_weights(n_eigen,n_eigen2,N,N_spin,N_geom) !                 print *, band_energy(n_eigen2,N_spin,N), band_energy(n_eigen,N_spin,N) else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in qdir = 0.0_dp qdir1 = 0.0_dp qdir2 = 0.0_dp do i = 1 , 3 qdir ( i ) = (( - 1.0_dp ) ** ( N3 + 1 )) * crystal_symmetry_operations ( 1 , i , N2 ) qdir1 ( i ) = (( - 1.0_dp ) ** ( N3 + 1 )) * crystal_symmetry_operations ( 2 , i , N2 ) qdir2 ( i ) = (( - 1.0_dp ) ** ( N3 + 1 )) * crystal_symmetry_operations ( 3 , i , N2 ) end do g = 0.0_dp g ( 1 ) = (( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) g ( 2 ) = (( qdir1 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir1 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir1 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) g ( 3 ) = (( qdir2 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir2 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir2 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & &( 1.0_dp / Real (( num_symm * ( N_in + 1 )), dp )) * factor * (( real ( g ( 1 ) * conjg ( g ( 1 )), dp ) + & & real ( g ( 2 ) * conjg ( g ( 2 )), dp ) + real ( g ( 3 ) * conjg ( g ( 3 )), dp )) / 3.0_dp ) !        write(*,*) \"mw =\", matrix_weights end do end do end if elseif ( index ( optics_geom , 'tensor' ) > 0 ) then if ( num_symm == 0 ) then do N2 = 1 , 3 g ( N2 ) = optical_mat ( n_eigen , n_eigen2 , N2 , N , N_spin ) end do matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 1 ) = factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 2 ) = factor * real ( g ( 2 ) * conjg ( g ( 2 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 3 ) = factor * real ( g ( 3 ) * conjg ( g ( 3 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 4 ) = factor * real ( g ( 1 ) * conjg ( g ( 2 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 5 ) = factor * real ( g ( 1 ) * conjg ( g ( 3 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 6 ) = factor * real ( g ( 2 ) * conjg ( g ( 3 )), dp ) else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in g = 0.0_dp do i = 1 , 3 do j = 1 , 3 g ( i ) = g ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * ( crystal_symmetry_operations ( i , j , N2 ) & * optical_mat ( n_eigen , n_eigen2 , j , N , N_spin )) end do end do matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 1 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 1 ) + factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) & & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 2 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 2 ) + factor * real ( g ( 2 ) * conjg ( g ( 2 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 3 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 3 ) + factor * real ( g ( 3 ) * conjg ( g ( 3 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 4 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 4 ) + factor * real ( g ( 1 ) * conjg ( g ( 2 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 5 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 5 ) + factor * real ( g ( 1 ) * conjg ( g ( 3 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 6 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 6 ) + factor * real ( g ( 2 ) * conjg ( g ( 3 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) end do end do end if end if end do end do end do end do if ( print_omes ) then ! This seems to be a rare thing to want to be able to do. So at the moment, I've made it a hard ! coded decision.  If you want the OMEs you probably know what you're doing enough to set this ! I haven't thought about spin or MPI. I think it behaves ok with symmetry. ! The results I wanted were polycrystalline. ! AJM May 2018 ! Above, we have already looked to label the gamma point. That is, ! the kpoint number at gamma. The variable was set to -1. So if it ! hasn't been set -- we didn't find the gamma point. ! If we didn't find it -- then we're not going to get the OMEs ! at the Gamma point. It's a critical stop. if ( gamma_is < 0 ) stop \"Couldnt find the gamma point\" ! Run through all the bands and find the last one that isn't above the Fermi level. ! This is inventivly called the \"top filled band\" do i = 1 , nbands if ( band_energy ( i , 1 , gamma_is ) . ge . efermi ) then exit else top_filled_band = i end if end do ! Set these for the number of bands either side of the Fermi energy that you want the ! OMES for. upper_window = top_filled_band + 2 lower_window = top_filled_band - 25 ! write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' + PRINT OUT SOME OPTICAL MATRIX ELEMENTS -- EASTER EGG CODE                  +' write ( stdout , * ) ' + Note that I wrote this for a specific purpose. I have documented it as best+' write ( stdout , * ) \" + I can, but you should fully understand what's happening before you use it  +\" write ( stdout , * ) \" + AJM May 2018 B'ham                                                         +\" write ( stdout , * ) \" + Top filled band is\" , top_filled_band write ( rowfmt , '(A,I4,A)' ) '(8x,' , upper_window - lower_window + 1 , '(3X,f8.5))' ! write(*,*) rowfmt ! For debugging write ( stdout , * ) kpoint_r ( gamma_is , :) write ( stdout , '(1x,a78)' ) '+============================================================================+' ! I haven't really thought about spins. So if you have a spin system, you get both an up and down spin ! OME do k = 1 , nspins write ( stdout , * ) '+ For spin channel' , k write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , FMT = rowfmt ) ( band_energy ( i , k , gamma_is ) - band_energy ( top_filled_band , k , gamma_is ), & & i = lower_window , upper_window ) write ( rowfmt , '(A,I4,A)' ) '(f8.5,' , upper_window - lower_window + 1 , '(3X,f8.5))' do i = lower_window , upper_window write ( stdout , FMT = rowfmt ) band_energy ( i , k , gamma_is ) - band_energy ( top_filled_band , k , gamma_is ), & & ( matrix_weights ( i , j , gamma_is , k , :), j = lower_window , upper_window ) end do end do write ( stdout , '(1x,a78)' ) '+============================================================================+' stop \" Completed generating the OMEs -- see the odo file\" end if end subroutine make_weights","tags":"","loc":"proc/make_weights.html"},{"title":"optics_calculate – OptaDOS","text":"public  subroutine optics_calculate() Uses od_parameters od_jdos_utils od_comms od_dos_utils od_cell od_electronic od_io proc~~optics_calculate~~UsesGraph proc~optics_calculate optics_calculate module~od_parameters od_parameters proc~optics_calculate->module~od_parameters module~od_comms od_comms proc~optics_calculate->module~od_comms module~od_jdos_utils od_jdos_utils proc~optics_calculate->module~od_jdos_utils module~od_dos_utils od_dos_utils proc~optics_calculate->module~od_dos_utils module~od_cell od_cell proc~optics_calculate->module~od_cell module~od_electronic od_electronic proc~optics_calculate->module~od_electronic module~od_io od_io proc~optics_calculate->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_jdos_utils->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~optics_calculate~~CallsGraph proc~optics_calculate optics_calculate proc~write_conduct write_conduct proc~optics_calculate->proc~write_conduct proc~write_absorp write_absorp proc~optics_calculate->proc~write_absorp proc~jdos_utils_calculate jdos_utils_calculate proc~optics_calculate->proc~jdos_utils_calculate proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~elec_read_optical_mat elec_read_optical_mat proc~optics_calculate->proc~elec_read_optical_mat proc~make_weights make_weights proc~optics_calculate->proc~make_weights proc~calc_epsilon_2 calc_epsilon_2 proc~optics_calculate->proc~calc_epsilon_2 proc~calc_epsilon_1 calc_epsilon_1 proc~optics_calculate->proc~calc_epsilon_1 proc~calc_refract calc_refract proc~optics_calculate->proc~calc_refract proc~calc_reflect calc_reflect proc~optics_calculate->proc~calc_reflect proc~calc_conduct calc_conduct proc~optics_calculate->proc~calc_conduct proc~write_epsilon write_epsilon proc~optics_calculate->proc~write_epsilon proc~calc_loss_fn calc_loss_fn proc~optics_calculate->proc~calc_loss_fn proc~write_refract write_refract proc~optics_calculate->proc~write_refract proc~dos_utils_set_efermi dos_utils_set_efermi proc~optics_calculate->proc~dos_utils_set_efermi proc~write_loss_fn write_loss_fn proc~optics_calculate->proc~write_loss_fn proc~write_reflect write_reflect proc~optics_calculate->proc~write_reflect proc~calc_absorp calc_absorp proc~optics_calculate->proc~calc_absorp proc~elec_dealloc_optical elec_dealloc_optical proc~optics_calculate->proc~elec_dealloc_optical proc~io_file_unit io_file_unit proc~write_conduct->proc~io_file_unit proc~write_absorp->proc~io_file_unit proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~io_time io_time proc~jdos_utils_calculate->proc~io_time proc~calculate_jdos calculate_jdos proc~jdos_utils_calculate->proc~calculate_jdos proc~setup_energy_scale setup_energy_scale proc~jdos_utils_calculate->proc~setup_energy_scale proc~elec_read_band_gradient elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_calculate->proc~jdos_utils_merge proc~io_error io_error proc~jdos_utils_calculate->proc~io_error proc~dos_utils_calculate_at_e->proc~io_time proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~dos_utils_calculate_at_e->proc~io_error proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~algor_dist_array algor_dist_array proc~elec_read_optical_mat->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_optical_mat->interface~comms_send interface~comms_recv comms_recv proc~elec_read_optical_mat->interface~comms_recv proc~cell_get_symmetry cell_get_symmetry proc~make_weights->proc~cell_get_symmetry proc~make_weights->proc~io_error proc~write_epsilon->proc~io_file_unit proc~write_refract->proc~io_file_unit proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate interface~comms_bcast comms_bcast proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_set_efermi->proc~io_error interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce proc~write_loss_fn->proc~io_file_unit proc~write_reflect->proc~io_file_unit proc~elec_dealloc_optical->proc~io_error proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_calculate->proc~io_time proc~dos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_calculate->proc~io_error proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~cell_get_symmetry->interface~comms_bcast proc~cell_get_symmetry->proc~io_file_unit proc~cell_get_symmetry->proc~io_error proc~calculate_jdos->proc~io_error proc~doslin doslin proc~calculate_jdos->proc~doslin proc~gaussian gaussian proc~calculate_jdos->proc~gaussian proc~allocate_jdos allocate_jdos proc~calculate_jdos->proc~allocate_jdos proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~calculate_jdos->proc~doslin_sub_cell_corners proc~setup_energy_scale->interface~comms_bcast proc~setup_energy_scale->proc~io_error proc~setup_energy_scale->interface~comms_reduce proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_band_gradient->interface~comms_send proc~elec_read_band_gradient->interface~comms_recv proc~jdos_utils_merge->interface~comms_reduce proc~algor_dist_array->proc~io_error proc~dos_utils_merge->interface~comms_reduce proc~allocate_jdos->proc~io_error proc~heap_sort heap_sort proc~doslin_sub_cell_corners->proc~heap_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~optics_calculate~~CalledByGraph proc~optics_calculate optics_calculate program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code optics_calculate Source Code subroutine optics_calculate ! !  Program to calculate optical properties ! use od_electronic , only : optical_mat , elec_read_optical_mat , nbands , nspins , & efermi , efermi_set , elec_dealloc_optical use od_cell , only : cell_volume , num_kpoints_on_node , kpoint_r , real_lattice use od_jdos_utils , only : jdos_utils_calculate use od_comms , only : on_root , my_node_id use od_parameters , only : optics_geom , adaptive , linear , fixed , optics_intraband , & optics_drude_broadening , photo_slab_min , photo_slab_max , devel_flag use od_dos_utils , only : dos_utils_calculate_at_e , dos_utils_set_efermi use od_io , only : stdout if ( on_root ) then write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                                Optics Calculation                          +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if if (. not . efermi_set ) call dos_utils_set_efermi ! Get information from .cst_ome file call elec_read_optical_mat ! Form matrix element call make_weights ( matrix_weights ) ! Send matrix element to jDOS routine and get weighted jDOS back call jdos_utils_calculate ( matrix_weights , weighted_jdos = weighted_jdos ) ! Calculate weighted DOS at Ef for intraband term if ( optics_intraband ) then allocate ( dos_matrix_weights ( size ( matrix_weights , 5 ), nbands , num_kpoints_on_node ( my_node_id ), nspins )) allocate ( dos_at_e ( 3 , nspins )) allocate ( weighted_dos_at_e ( nspins , size ( matrix_weights , 5 ))) weighted_dos_at_e = 0.0_dp do N = 1 , size ( matrix_weights , 5 ) do N2 = 1 , nbands dos_matrix_weights ( N , N2 , :, :) = matrix_weights ( N2 , N2 , :, :, N ) end do end do call dos_utils_calculate_at_e ( efermi , dos_at_e , dos_matrix_weights , weighted_dos_at_e ) end if call elec_dealloc_optical ! don't need this large array anymore if ( on_root ) then if ( index ( devel_flag , 'slab_volume' ) > 0 ) then slab_volume = ( cell_volume / real_lattice ( 3 , 3 )) * ( photo_slab_max - photo_slab_min ) ! Calculate epsilon_2 call calc_epsilon_2 ( weighted_jdos , weighted_dos_at_e , slab_volume ) else ! Calculate epsilon_2 call calc_epsilon_2 ( weighted_jdos , weighted_dos_at_e ) end if ! Calculate epsilon_1 call calc_epsilon_1 ! Calculate other optical properties if (. not . index ( optics_geom , 'tensor' ) > 0 ) then call calc_conduct call calc_refract call calc_loss_fn call calc_absorp call calc_reflect end if ! Write everything out if ( index ( devel_flag , 'slab_volume' ) > 0 ) then call write_epsilon ( atom = 0 , photo_volume = slab_volume ) else call write_epsilon ( 0 ) end if if (. not . index ( optics_geom , 'tensor' ) > 0 ) then call write_conduct call write_loss_fn if ( index ( devel_flag , 'slab_volume' ) > 0 ) then call write_refract ( atom = 0 , photo_volume = slab_volume ) call write_absorp ( atom = 0 , photo_volume = slab_volume ) call write_reflect ( atom = 0 , photo_volume = slab_volume ) else call write_refract ( 0 ) call write_absorp ( 0 ) call write_reflect ( 0 ) end if end if end if end subroutine optics_calculate","tags":"","loc":"proc/optics_calculate.html"},{"title":"write_absorp – OptaDOS","text":"public  subroutine write_absorp(atom, photo_volume) Uses od_jdos_utils od_parameters od_cell od_electronic od_io proc~~write_absorp~~UsesGraph proc~write_absorp write_absorp module~od_jdos_utils od_jdos_utils proc~write_absorp->module~od_jdos_utils module~od_parameters od_parameters proc~write_absorp->module~od_parameters module~od_io od_io proc~write_absorp->module~od_io module~od_cell od_cell proc~write_absorp->module~od_cell module~od_electronic od_electronic proc~write_absorp->module~od_electronic module~od_constants od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine writes out the absorption coefficient Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional :: photo_volume Calls proc~~write_absorp~~CallsGraph proc~write_absorp write_absorp proc~io_file_unit io_file_unit proc~write_absorp->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_absorp~~CalledByGraph proc~write_absorp write_absorp proc~optics_calculate optics_calculate proc~optics_calculate->proc~write_absorp program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_absorp Source Code subroutine write_absorp ( atom , photo_volume ) !*************************************************************** ! This subroutine writes out the absorption coefficient use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N integer :: absorp_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"absorption_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"absorption\" end if label % title = \"Absorption Coefficient (m-1)\" ! per metre label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"A\" ! Open the output file absorp_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = absorp_unit , action = 'write' , file = trim ( seedname ) // '_absorption_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = absorp_unit , action = 'write' , file = trim ( seedname ) // '_absorption.dat' ) end if ! Write into the output file write ( absorp_unit , * ) '#*********************************************' write ( absorp_unit , * ) '#             Absorption coefficent                 ' write ( absorp_unit , * ) '#*********************************************' write ( absorp_unit , * ) '#' write ( absorp_unit , * ) '#' write ( absorp_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( absorp_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( absorp_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( absorp_unit , * ) '# No of bands:' , nbands if ( present ( photo_volume )) then write ( absorp_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( absorp_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( absorp_unit , * ) '#' write ( absorp_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( absorp_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( absorp_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( absorp_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( absorp_unit , * ) '#' do N = 1 , jdos_nbins write ( absorp_unit , * ) E ( N ), ',' , absorp ( N ) end do ! Close output file close ( unit = absorp_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , absorp ) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , absorp ) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_absorp","tags":"","loc":"proc/write_absorp.html"},{"title":"write_conduct – OptaDOS","text":"public  subroutine write_conduct() Uses od_jdos_utils od_parameters od_cell od_electronic od_io proc~~write_conduct~~UsesGraph proc~write_conduct write_conduct module~od_jdos_utils od_jdos_utils proc~write_conduct->module~od_jdos_utils module~od_parameters od_parameters proc~write_conduct->module~od_parameters module~od_io od_io proc~write_conduct->module~od_io module~od_cell od_cell proc~write_conduct->module~od_cell module~od_electronic od_electronic proc~write_conduct->module~od_electronic module~od_constants od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine writes out the conductivity Arguments None Calls proc~~write_conduct~~CallsGraph proc~write_conduct write_conduct proc~io_file_unit io_file_unit proc~write_conduct->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_conduct~~CalledByGraph proc~write_conduct write_conduct proc~optics_calculate optics_calculate proc~optics_calculate->proc~write_conduct program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_conduct Source Code subroutine write_conduct !*************************************************************** ! This subroutine writes out the conductivity use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N integer :: conduct_unit type ( graph_labels ) :: label label % name = \"conductivity\" label % title = \"Conductivity (S m-1)\" ! Siemens per metre label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"Real\" label % legend_b = \"Imaginary\" ! Open the output file conduct_unit = io_file_unit () open ( unit = conduct_unit , action = 'write' , file = trim ( seedname ) // '_conductivity.dat' ) ! Write into the output file write ( conduct_unit , * ) '#*********************************************' write ( conduct_unit , * ) '#               Conductivity                ' write ( conduct_unit , * ) '#*********************************************' write ( conduct_unit , * ) '#' write ( conduct_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( conduct_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( conduct_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( conduct_unit , * ) '# No of bands:' , nbands write ( conduct_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume write ( conduct_unit , * ) '#' write ( conduct_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( conduct_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( conduct_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( conduct_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( conduct_unit , * ) '# Note: the conductivity is outputted in SI units, Siemens per metre' write ( conduct_unit , * ) '# to convert from SI units (Sm-1) to cgs units (s) divide by 4pixepsilon_0' write ( conduct_unit , * ) '# to convert from cgs (s) units to SI units (Sm-1) multiply by 4pixepsilon_0, ' write ( conduct_unit , * ) '#' do N = 1 , jdos_nbins write ( conduct_unit , * ) E ( N ), conduct ( N , 1 ), conduct ( N , 2 ) end do ! Close output file close ( unit = conduct_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , conduct (:, 1 ), conduct (:, 2 )) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , conduct (:, 1 ), conduct (:, 2 )) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_conduct","tags":"","loc":"proc/write_conduct.html"},{"title":"write_epsilon – OptaDOS","text":"public  subroutine write_epsilon(atom, photo_at_e, photo_volume) Uses od_jdos_utils od_parameters od_cell od_electronic od_io proc~~write_epsilon~~UsesGraph proc~write_epsilon write_epsilon module~od_jdos_utils od_jdos_utils proc~write_epsilon->module~od_jdos_utils module~od_parameters od_parameters proc~write_epsilon->module~od_parameters module~od_io od_io proc~write_epsilon->module~od_io module~od_cell od_cell proc~write_epsilon->module~od_cell module~od_electronic od_electronic proc~write_epsilon->module~od_electronic module~od_constants od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine writes out the dielectric function $          label%name=\"epsilon\"//trim(achar(N2))\n$          if(trim(output_format)==\"xmgrace\") then\n$             call write_optics_xmgrace(label,E,epsilon(:,1,N2,1),epsilon(:,2,N2,1))\n$          elseif(trim(output_format)==\"gnuplot\") then\n$             write(stdout, )  \" WARNING: GNUPLOT output not yet available, continuing...\"\n$          else\n$             write(stdout, )  \" WARNING: Unknown output format requested, continuing...\"\n$          endif Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional, dimension(:, :) :: photo_at_e real(kind=dp), intent(in), optional :: photo_volume Calls proc~~write_epsilon~~CallsGraph proc~write_epsilon write_epsilon proc~io_file_unit io_file_unit proc~write_epsilon->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_epsilon~~CalledByGraph proc~write_epsilon write_epsilon proc~optics_calculate optics_calculate proc~optics_calculate->proc~write_epsilon program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_epsilon Source Code subroutine write_epsilon ( atom , photo_at_e , photo_volume ) !*************************************************************** ! This subroutine writes out the dielectric function use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , & & output_format , fixed , adaptive , linear , optics_intraband use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : E , jdos_nbins use od_io , only : seedname , io_file_unit , stdout integer :: N , N2 , N3 real ( kind = dp ) :: dE integer :: epsilon_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), dimension (:, :), optional :: photo_at_e real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"epsilon_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"epsilon\" end if label % title = \"Dielectric Function\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"Real\" label % legend_b = \"Imaginary\" dE = E ( 2 ) - E ( 1 ) ! Open the output file epsilon_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = epsilon_unit , action = 'write' , file = trim ( seedname ) // '_epsilon_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = epsilon_unit , action = 'write' , file = trim ( seedname ) // '_epsilon.dat' ) end if ! Write into the output file write ( epsilon_unit , * ) '#*********************************************' write ( epsilon_unit , * ) '#            Dielectric function                 ' write ( epsilon_unit , * ) '#*********************************************' write ( epsilon_unit , * ) '#' write ( epsilon_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( epsilon_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( epsilon_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( epsilon_unit , * ) '# Number of bands:' , nbands if ( present ( photo_volume )) then write ( epsilon_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( epsilon_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( epsilon_unit , * ) '#' write ( epsilon_unit , '(1x,a,f10.6,1x,a,f10.6,1x,a)' ) & & '# Dielectric function calculated to' , jdos_max_energy , 'eV in' , dE , 'eV steps' write ( epsilon_unit , * ) '#' write ( epsilon_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( epsilon_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , & & optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( epsilon_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( epsilon_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( epsilon_unit , * ) '#' if ( optics_intraband ) then write ( epsilon_unit , * ) '# Calculation includes intraband term' if ( present ( photo_at_e )) then if ( fixed ) write ( epsilon_unit , * ) '# DOS at Ef:' , photo_at_e ( 1 , :) if ( adaptive ) write ( epsilon_unit , * ) '# DOS at Ef:' , photo_at_e ( 2 , :) if ( linear ) write ( epsilon_unit , * ) '# DOS at Ef:' , photo_at_e ( 3 , :) else if ( fixed ) write ( epsilon_unit , * ) '# DOS at Ef:' , dos_at_e ( 1 , :) if ( adaptive ) write ( epsilon_unit , * ) '# DOS at Ef:' , dos_at_e ( 2 , :) if ( linear ) write ( epsilon_unit , * ) '# DOS at Ef:' , dos_at_e ( 3 , :) end if do N = 1 , N_geom write ( epsilon_unit , * ) '# Plasmon energy:' , ( intra ( N ) ** 0.5 ) end do end if if ( N_geom == 1 ) then write ( epsilon_unit , * ) '# Result of sum rule: Neff(E) =  ' , N_eff write ( epsilon_unit , * ) '#' if (. not . optics_intraband ) then do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), ',' , epsilon ( N , 1 , 1 , 1 ), ',' , epsilon ( N , 2 , 1 , 1 ) end do else write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), ',' , epsilon ( N , 1 , 1 , 1 ), ',' , epsilon ( N , 2 , 1 , 1 ) end do do N2 = 2 , 3 write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' do N = 2 , jdos_nbins write ( epsilon_unit , * ) E ( N ), ',' , epsilon ( N , 1 , 1 , N2 ), ',' , epsilon ( N , 2 , 1 , N2 ) / ( E ( N ) * e_charge ) end do end do end if if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , epsilon (:, 1 , 1 , 1 ), epsilon (:, 2 , 1 , 1 )) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , epsilon (:, 1 , 1 , 1 ), epsilon (:, 2 , 1 , 1 )) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end if if ( index ( optics_geom , 'tensor' ) > 0 ) then write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' do N2 = 1 , N_geom write ( epsilon_unit , * ) '# Component ' , N2 write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' if (. not . optics_intraband ) then do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), epsilon ( N , 1 , N2 , 1 ), epsilon ( N , 2 , N2 , 1 ) end do else do N3 = 1 , 3 do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), epsilon ( N , 1 , N2 , N3 ), epsilon ( N , 2 , N2 , N3 ) end do write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' end do end if ! I don't think we want to plot in the tensor case, so this is commented out (it's broke anyhow!) jry !!$          label%name=\"epsilon\"//trim(achar(N2)) !!$          if(trim(output_format)==\"xmgrace\") then !!$             call write_optics_xmgrace(label,E,epsilon(:,1,N2,1),epsilon(:,2,N2,1)) !!$          elseif(trim(output_format)==\"gnuplot\") then !!$             write(stdout,*)  \" WARNING: GNUPLOT output not yet available, continuing...\" !!$          else !!$             write(stdout,*)  \" WARNING: Unknown output format requested, continuing...\" !!$          endif end do end if ! Close output file close ( unit = epsilon_unit ) end subroutine write_epsilon","tags":"","loc":"proc/write_epsilon.html"},{"title":"write_loss_fn – OptaDOS","text":"public  subroutine write_loss_fn() Uses od_jdos_utils od_parameters od_cell od_electronic od_io proc~~write_loss_fn~~UsesGraph proc~write_loss_fn write_loss_fn module~od_jdos_utils od_jdos_utils proc~write_loss_fn->module~od_jdos_utils module~od_parameters od_parameters proc~write_loss_fn->module~od_parameters module~od_io od_io proc~write_loss_fn->module~od_io module~od_cell od_cell proc~write_loss_fn->module~od_cell module~od_electronic od_electronic proc~write_loss_fn->module~od_electronic module~od_constants od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine writes out the loss function Arguments None Calls proc~~write_loss_fn~~CallsGraph proc~write_loss_fn write_loss_fn proc~io_file_unit io_file_unit proc~write_loss_fn->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_loss_fn~~CalledByGraph proc~write_loss_fn write_loss_fn proc~optics_calculate optics_calculate proc~optics_calculate->proc~write_loss_fn program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_loss_fn Source Code subroutine write_loss_fn !*************************************************************** ! This subroutine writes out the loss function use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format , & optics_intraband , optics_lossfn_broadening use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N , N2 integer :: loss_fn_unit type ( graph_labels ) :: label label % name = \"loss_fn\" label % title = \"Loss Function\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then label % legend_a = \"\" label % legend_b = \"Broadened\" else label % legend_a = \"\" end if else if ( optics_lossfn_broadening ) then label % legend_a = \"Interband\" label % legend_b = \"Intraband\" label % legend_c = \"Total\" label % legend_d = \"Broadened\" else label % legend_a = \"Interband\" label % legend_b = \"Intraband\" label % legend_c = \"Total\" end if end if ! Open the output file loss_fn_unit = io_file_unit () open ( unit = loss_fn_unit , action = 'write' , file = trim ( seedname ) // '_loss_fn.dat' ) ! Write into the output file write ( loss_fn_unit , * ) '#*********************************************' write ( loss_fn_unit , * ) '#               Loss function                 ' write ( loss_fn_unit , * ) '#*********************************************' write ( loss_fn_unit , * ) '#' write ( loss_fn_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( loss_fn_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( loss_fn_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( loss_fn_unit , * ) '# No of bands:' , nbands write ( loss_fn_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume write ( loss_fn_unit , * ) '#' write ( loss_fn_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( loss_fn_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( loss_fn_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( loss_fn_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( loss_fn_unit , * ) '#' write ( loss_fn_unit , * ) '# Result of first sum rule: Neff(E) = ' , N_eff2 write ( loss_fn_unit , * ) '# Result of second sum rule (pi/2 = 1.570796327):' , N_eff3 write ( loss_fn_unit , * ) '#' if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , 1 ), loss_fn ( N , 2 ) end do else do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , 1 ) end do end if else if ( optics_lossfn_broadening ) then do N2 = 1 , 4 do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , N2 ) end do end do else do N2 = 1 , 3 do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , N2 ) end do end do end if end if ! Close output file close ( unit = loss_fn_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then call write_optics_xmgrace ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 )) else call write_optics_xmgrace ( label , E , loss_fn (:, 1 )) end if else if ( optics_lossfn_broadening ) then call write_optics_xmgrace ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 ), loss_fn (:, 3 ), loss_fn (:, 4 )) else call write_optics_xmgrace ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 ), loss_fn (:, 3 )) end if end if elseif ( trim ( output_format ) == \"gnuplot\" ) then if (. not . optics_intraband ) then call write_optics_gnuplot ( label , E , loss_fn (:, 1 )) else call write_optics_gnuplot ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 ), loss_fn (:, 3 )) end if else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_loss_fn","tags":"","loc":"proc/write_loss_fn.html"},{"title":"write_reflect – OptaDOS","text":"public  subroutine write_reflect(atom, photo_volume) Uses od_jdos_utils od_parameters od_cell od_electronic od_io proc~~write_reflect~~UsesGraph proc~write_reflect write_reflect module~od_jdos_utils od_jdos_utils proc~write_reflect->module~od_jdos_utils module~od_parameters od_parameters proc~write_reflect->module~od_parameters module~od_io od_io proc~write_reflect->module~od_io module~od_cell od_cell proc~write_reflect->module~od_cell module~od_electronic od_electronic proc~write_reflect->module~od_electronic module~od_constants od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine writes out the reflection coefficient Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional :: photo_volume Calls proc~~write_reflect~~CallsGraph proc~write_reflect write_reflect proc~io_file_unit io_file_unit proc~write_reflect->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_reflect~~CalledByGraph proc~write_reflect write_reflect proc~optics_calculate optics_calculate proc~optics_calculate->proc~write_reflect program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_reflect Source Code subroutine write_reflect ( atom , photo_volume ) !*************************************************************** ! This subroutine writes out the reflection coefficient use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_io , only : seedname , io_file_unit , stdout use od_jdos_utils , only : jdos_nbins , E integer :: N integer :: reflect_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"reflection_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"reflection\" end if label % title = \"Reflection Coefficient\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"R\" ! Open the output file reflect_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = reflect_unit , action = 'write' , file = trim ( seedname ) // '_reflection_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = reflect_unit , action = 'write' , file = trim ( seedname ) // '_reflection.dat' ) end if ! Write into the output file write ( reflect_unit , * ) '#*********************************************' write ( reflect_unit , * ) '#           Reflection coefficient                ' write ( reflect_unit , * ) '#*********************************************' write ( reflect_unit , * ) '#' write ( reflect_unit , * ) '# N=n+ik' write ( reflect_unit , * ) '#' write ( reflect_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( reflect_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( reflect_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( reflect_unit , * ) '# No of bands:' , nbands if ( present ( photo_volume )) then write ( reflect_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( reflect_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( reflect_unit , * ) '#' write ( reflect_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( reflect_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( reflect_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( reflect_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( reflect_unit , * ) '#' do N = 1 , jdos_nbins write ( reflect_unit , * ) E ( N ), ',' , reflect ( N ) end do ! Close output file close ( unit = reflect_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , reflect ) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , reflect ) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_reflect","tags":"","loc":"proc/write_reflect.html"},{"title":"write_refract – OptaDOS","text":"public  subroutine write_refract(atom, photo_volume) Uses od_jdos_utils od_parameters od_cell od_electronic od_io proc~~write_refract~~UsesGraph proc~write_refract write_refract module~od_jdos_utils od_jdos_utils proc~write_refract->module~od_jdos_utils module~od_parameters od_parameters proc~write_refract->module~od_parameters module~od_io od_io proc~write_refract->module~od_io module~od_cell od_cell proc~write_refract->module~od_cell module~od_electronic od_electronic proc~write_refract->module~od_electronic module~od_constants od_constants module~od_jdos_utils->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This subroutine writes out the refractive index Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional :: photo_volume Calls proc~~write_refract~~CallsGraph proc~write_refract write_refract proc~io_file_unit io_file_unit proc~write_refract->proc~io_file_unit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_refract~~CalledByGraph proc~write_refract write_refract proc~optics_calculate optics_calculate proc~optics_calculate->proc~write_refract program~optados optados program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_refract Source Code subroutine write_refract ( atom , photo_volume ) !*************************************************************** ! This subroutine writes out the refractive index use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N integer :: refract_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"refractive_index_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"refractive_index\" end if label % title = \"Refractive Index\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"Real\" label % legend_b = \"Imaginary\" ! Open the output file refract_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = refract_unit , action = 'write' , file = trim ( seedname ) // '_refractive_index_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = refract_unit , action = 'write' , file = trim ( seedname ) // '_refractive_index.dat' ) end if ! Write into the output file write ( refract_unit , * ) '#*********************************************' write ( refract_unit , * ) '#             Refractive index                 ' write ( refract_unit , * ) '#*********************************************' write ( refract_unit , * ) '#' write ( refract_unit , * ) '# N=n+ik' write ( refract_unit , * ) '#' write ( refract_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( refract_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( refract_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( refract_unit , * ) '# No of bands:' , nbands if ( present ( photo_volume )) then write ( refract_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( refract_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( refract_unit , * ) '#' write ( refract_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( refract_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( refract_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( refract_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( refract_unit , * ) '#' do N = 1 , jdos_nbins write ( refract_unit , * ) E ( N ), ',' , refract ( N , 1 ), ',' , refract ( N , 2 ) end do ! Close output file close ( unit = refract_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , refract (:, 1 ), refract (:, 2 )) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , refract (:, 1 ), refract (:, 2 )) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_refract","tags":"","loc":"proc/write_refract.html"},{"title":"comms_end – OptaDOS","text":"public  subroutine comms_end() Arguments None Called by proc~~comms_end~~CalledByGraph proc~comms_end comms_end program~optados optados program~optados->proc~comms_end program~od2od od2od program~od2od->proc~comms_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code comms_end Source Code subroutine comms_end implicit none integer :: ierr #ifdef MPI call mpi_finalize ( ierr ) #else stop #endif end subroutine comms_end","tags":"","loc":"proc/comms_end.html"},{"title":"comms_setup – OptaDOS","text":"public  subroutine comms_setup() Arguments None Called by proc~~comms_setup~~CalledByGraph proc~comms_setup comms_setup program~optados optados program~optados->proc~comms_setup program~od2od od2od program~od2od->proc~comms_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code comms_setup Source Code subroutine comms_setup implicit none integer :: ierr #ifdef MPI call mpi_init ( ierr ) if ( ierr . ne . 0 ) stop 'MPI initialisation error' call mpi_comm_rank ( mpi_comm_world , my_node_id , ierr ) call mpi_comm_size ( mpi_comm_world , num_nodes , ierr ) #else num_nodes = 1 my_node_id = 0 #endif on_root = . false . if ( my_node_id == root_id ) on_root = . true . end subroutine comms_setup","tags":"","loc":"proc/comms_setup.html"},{"title":"comms_bcast – OptaDOS","text":"public interface comms_bcast Called by interface~~comms_bcast~~CalledByGraph interface~comms_bcast comms_bcast proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->interface~comms_bcast proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->interface~comms_bcast proc~cell_get_symmetry cell_get_symmetry proc~cell_get_symmetry->interface~comms_bcast proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->interface~comms_bcast proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->interface~comms_bcast proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->interface~comms_bcast proc~dos_utils_calculate->interface~comms_bcast proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate->proc~elec_read_band_gradient proc~elec_read_band_gradient->interface~comms_bcast proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->interface~comms_bcast proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~param_dist param_dist proc~param_dist->interface~comms_bcast proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->interface~comms_bcast proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->interface~comms_bcast proc~cell_dist cell_dist proc~cell_dist->interface~comms_bcast proc~read_dome_bin read_dome_bin proc~read_dome_bin->proc~elec_read_band_gradient proc~read_elnes_bin read_elnes_bin proc~read_elnes_bin->proc~elec_read_elnes_mat proc~get_band_energy get_band_energy proc~get_band_energy->proc~elec_read_band_energy proc~make_weights make_weights proc~make_weights->proc~cell_get_symmetry proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~pdos_calculate->proc~elec_pdos_read proc~pdos_calculate->proc~dos_utils_calculate proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~jdos_utils_calculate->proc~setup_energy_scale proc~jdos_utils_calculate->proc~elec_read_band_gradient program~optados optados program~optados->proc~elec_read_band_energy program~optados->proc~elec_read_band_energy_ordered program~optados->proc~param_dist program~optados->proc~cell_dist program~optados->proc~pdos_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~core_calculate core_calculate program~optados->proc~core_calculate proc~pdis_calculate pdis_calculate program~optados->proc~pdis_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~optics_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~make_weights proc~optics_calculate->proc~jdos_utils_calculate proc~optics_calculate->proc~dos_utils_calculate_at_e proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~core_calculate->proc~dos_utils_set_efermi proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~elec_read_elnes_mat proc~read_pdos_bin read_pdos_bin proc~read_pdos_bin->proc~elec_pdos_read proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~pdis_calculate->proc~elec_pdis_read program~od2od od2od program~od2od->proc~read_dome_bin program~od2od->proc~read_elnes_bin program~od2od->proc~get_band_energy program~od2od->proc~read_pdos_bin proc~jdos_calculate->proc~jdos_utils_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures comms_bcast_int comms_bcast_logical comms_bcast_real comms_bcast_cmplx comms_bcast_char Module Procedures private  subroutine comms_bcast_int(array, size) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_logical(array, size) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_real(array, size) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_cmplx(array, size) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_char(array, size) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array integer, intent(in) :: size","tags":"","loc":"interface/comms_bcast.html"},{"title":"comms_recv – OptaDOS","text":"public interface comms_recv Called by interface~~comms_recv~~CalledByGraph interface~comms_recv comms_recv proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->interface~comms_recv proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->interface~comms_recv proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->interface~comms_recv proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->interface~comms_recv proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->interface~comms_recv proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->interface~comms_recv proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->interface~comms_recv proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->interface~comms_recv proc~core_calculate core_calculate proc~core_calculate->proc~elec_read_elnes_mat proc~dos_utils_calculate dos_utils_calculate proc~core_calculate->proc~dos_utils_calculate proc~dos_utils_set_efermi dos_utils_set_efermi proc~core_calculate->proc~dos_utils_set_efermi proc~read_dome_bin read_dome_bin proc~read_dome_bin->proc~elec_read_band_gradient proc~read_elnes_bin read_elnes_bin proc~read_elnes_bin->proc~elec_read_elnes_mat proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~elec_pdos_read proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~get_band_energy get_band_energy proc~get_band_energy->proc~elec_read_band_energy proc~read_pdos_bin read_pdos_bin proc~read_pdos_bin->proc~elec_pdos_read proc~read_ome_bin read_ome_bin proc~read_ome_bin->proc~elec_read_optical_mat proc~optics_calculate optics_calculate proc~optics_calculate->proc~elec_read_optical_mat proc~jdos_utils_calculate jdos_utils_calculate proc~optics_calculate->proc~jdos_utils_calculate proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_set_efermi program~optados optados program~optados->proc~elec_read_band_energy program~optados->proc~elec_read_band_energy_ordered program~optados->proc~core_calculate program~optados->proc~pdos_calculate program~optados->proc~optics_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate->proc~dos_utils_compute_bandgap proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_fem_bin read_fem_bin proc~read_fem_bin->proc~elec_read_foptical_mat program~od2od od2od program~od2od->proc~read_dome_bin program~od2od->proc~read_elnes_bin program~od2od->proc~get_band_energy program~od2od->proc~read_pdos_bin program~od2od->proc~read_ome_bin program~od2od->proc~read_fem_bin proc~jdos_calculate->proc~jdos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures comms_recv_int comms_recv_logical comms_recv_real comms_recv_cmplx comms_recv_char Module Procedures private  subroutine comms_recv_int(array, size, from) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_logical(array, size, from) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_real(array, size, from) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_cmplx(array, size, from) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_char(array, size, from) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from","tags":"","loc":"interface/comms_recv.html"},{"title":"comms_reduce – OptaDOS","text":"public interface comms_reduce Called by interface~~comms_reduce~~CalledByGraph interface~comms_reduce comms_reduce proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->interface~comms_reduce proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->interface~comms_reduce proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->interface~comms_reduce proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->interface~comms_reduce proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->interface~comms_reduce proc~dos_utils_calculate->proc~dos_utils_merge proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~jdos_utils_merge proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~jdos_utils_calculate->proc~setup_energy_scale proc~optics_calculate optics_calculate proc~optics_calculate->proc~dos_utils_set_efermi proc~optics_calculate->proc~jdos_utils_calculate proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_calculate->proc~dos_utils_compute_band_energies proc~dos_calculate->proc~dos_utils_calculate proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~pdos_calculate->proc~dos_utils_calculate proc~core_calculate core_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~core_calculate->proc~dos_utils_calculate proc~read_fem_bin read_fem_bin proc~read_fem_bin->proc~elec_read_foptical_mat proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate program~od2od od2od program~od2od->proc~read_fem_bin program~optados optados program~optados->proc~optics_calculate program~optados->proc~dos_calculate program~optados->proc~pdos_calculate program~optados->proc~core_calculate program~optados->proc~jdos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures comms_reduce_int comms_reduce_real comms_reduce_cmplx Module Procedures private  subroutine comms_reduce_int(array, size, op) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size character(len=*), intent(in) :: op private  subroutine comms_reduce_real(array, size, op) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size character(len=*), intent(in) :: op private  subroutine comms_reduce_cmplx(array, size, op) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size character(len=*), intent(in) :: op","tags":"","loc":"interface/comms_reduce.html"},{"title":"comms_send – OptaDOS","text":"public interface comms_send Called by interface~~comms_send~~CalledByGraph interface~comms_send comms_send proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->interface~comms_send proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->interface~comms_send proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->interface~comms_send proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->interface~comms_send proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->interface~comms_send proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->interface~comms_send proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->interface~comms_send proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->interface~comms_send proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->interface~comms_send proc~core_calculate core_calculate proc~core_calculate->proc~elec_read_elnes_mat proc~dos_utils_calculate dos_utils_calculate proc~core_calculate->proc~dos_utils_calculate proc~dos_utils_set_efermi dos_utils_set_efermi proc~core_calculate->proc~dos_utils_set_efermi proc~read_dome_bin read_dome_bin proc~read_dome_bin->proc~elec_read_band_gradient proc~read_elnes_bin read_elnes_bin proc~read_elnes_bin->proc~elec_read_elnes_mat proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~elec_pdos_read proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~get_band_energy get_band_energy proc~get_band_energy->proc~elec_read_band_energy proc~read_pdos_bin read_pdos_bin proc~read_pdos_bin->proc~elec_pdos_read proc~read_ome_bin read_ome_bin proc~read_ome_bin->proc~elec_read_optical_mat proc~optics_calculate optics_calculate proc~optics_calculate->proc~elec_read_optical_mat proc~jdos_utils_calculate jdos_utils_calculate proc~optics_calculate->proc~jdos_utils_calculate proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_set_efermi program~optados optados program~optados->proc~elec_read_band_energy program~optados->proc~elec_read_band_energy_ordered program~optados->proc~core_calculate program~optados->proc~pdos_calculate program~optados->proc~optics_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate->proc~dos_utils_compute_bandgap proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_fem_bin read_fem_bin proc~read_fem_bin->proc~elec_read_foptical_mat program~od2od od2od program~od2od->proc~read_dome_bin program~od2od->proc~read_elnes_bin program~od2od->proc~get_band_energy program~od2od->proc~read_pdos_bin program~od2od->proc~read_ome_bin program~od2od->proc~read_fem_bin proc~jdos_calculate->proc~jdos_utils_calculate proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures comms_send_int comms_send_logical comms_send_real comms_send_cmplx comms_send_char Module Procedures private  subroutine comms_send_int(array, size, to) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_logical(array, size, to) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_real(array, size, to) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_cmplx(array, size, to) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_char(array, size, to) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to","tags":"","loc":"interface/comms_send.html"},{"title":"elec_dealloc_band_gradient – OptaDOS","text":"public  subroutine elec_dealloc_band_gradient() Uses od_io proc~~elec_dealloc_band_gradient~~UsesGraph proc~elec_dealloc_band_gradient elec_dealloc_band_gradient module~od_io od_io proc~elec_dealloc_band_gradient->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_dealloc_band_gradient~~CallsGraph proc~elec_dealloc_band_gradient elec_dealloc_band_gradient proc~io_error io_error proc~elec_dealloc_band_gradient->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_dealloc_band_gradient Source Code subroutine elec_dealloc_band_gradient use od_io , only : io_error implicit none integer :: ierr if ( allocated ( band_gradient )) then deallocate ( band_gradient , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating band_gradient in elec_dealloc_band_gradient' ) end if end subroutine elec_dealloc_band_gradient","tags":"","loc":"proc/elec_dealloc_band_gradient.html"},{"title":"elec_dealloc_elnes – OptaDOS","text":"public  subroutine elec_dealloc_elnes() Uses od_io proc~~elec_dealloc_elnes~~UsesGraph proc~elec_dealloc_elnes elec_dealloc_elnes module~od_io od_io proc~elec_dealloc_elnes->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_dealloc_elnes~~CallsGraph proc~elec_dealloc_elnes elec_dealloc_elnes proc~io_error io_error proc~elec_dealloc_elnes->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_dealloc_elnes Source Code subroutine elec_dealloc_elnes use od_io , only : io_error implicit none integer :: ierr if ( allocated ( elnes_mat )) then deallocate ( elnes_mat , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating elnes_mat in elec_dealloc_elnes' ) end if !    if(allocated(elnes_orbital)) then !       deallocate(elnes_orbital,stat=ierr) !       if (ierr/=0) call io_error('Error in deallocating elnes_orbital in elec_dealloc_elnes') !    end if end subroutine elec_dealloc_elnes","tags":"","loc":"proc/elec_dealloc_elnes.html"},{"title":"elec_dealloc_optical – OptaDOS","text":"public  subroutine elec_dealloc_optical() Uses od_io proc~~elec_dealloc_optical~~UsesGraph proc~elec_dealloc_optical elec_dealloc_optical module~od_io od_io proc~elec_dealloc_optical->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_dealloc_optical~~CallsGraph proc~elec_dealloc_optical elec_dealloc_optical proc~io_error io_error proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_dealloc_optical~~CalledByGraph proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~optics_calculate optics_calculate proc~optics_calculate->proc~elec_dealloc_optical proc~jdos_utils_calculate jdos_utils_calculate proc~optics_calculate->proc~jdos_utils_calculate proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~dos_utils_set_efermi dos_utils_set_efermi proc~optics_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_dome_bin read_dome_bin proc~read_dome_bin->proc~elec_read_band_gradient program~optados optados program~optados->proc~optics_calculate proc~pdos_calculate pdos_calculate program~optados->proc~pdos_calculate proc~core_calculate core_calculate program~optados->proc~core_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e program~od2od od2od program~od2od->proc~read_dome_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_dealloc_optical Source Code subroutine elec_dealloc_optical use od_io , only : io_error implicit none integer :: ierr if ( allocated ( optical_mat )) then deallocate ( optical_mat , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating optical_mat in elec_dealloc_optical' ) end if end subroutine elec_dealloc_optical","tags":"","loc":"proc/elec_dealloc_optical.html"},{"title":"elec_dealloc_pdos – OptaDOS","text":"public  subroutine elec_dealloc_pdos() Uses od_io proc~~elec_dealloc_pdos~~UsesGraph proc~elec_dealloc_pdos elec_dealloc_pdos module~od_io od_io proc~elec_dealloc_pdos->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_dealloc_pdos~~CallsGraph proc~elec_dealloc_pdos elec_dealloc_pdos proc~io_error io_error proc~elec_dealloc_pdos->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_dealloc_pdos Source Code subroutine elec_dealloc_pdos use od_io , only : io_error implicit none integer :: ierr if ( allocated ( pdos_weights )) then deallocate ( pdos_weights , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating pdos_weights in elec_dealloc_pdos' ) end if end subroutine elec_dealloc_pdos","tags":"","loc":"proc/elec_dealloc_pdos.html"},{"title":"elec_elnes_find_channel_names – OptaDOS","text":"public  subroutine elec_elnes_find_channel_names() Uses od_io proc~~elec_elnes_find_channel_names~~UsesGraph proc~elec_elnes_find_channel_names elec_elnes_find_channel_names module~od_io od_io proc~elec_elnes_find_channel_names->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_elnes_find_channel_names~~CallsGraph proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~io_error io_error proc~elec_elnes_find_channel_names->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_elnes_find_channel_names~~CalledByGraph proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~read_elnes_fmt read_elnes_fmt proc~read_elnes_fmt->proc~elec_elnes_find_channel_names proc~read_elnes_bin read_elnes_bin proc~read_elnes_bin->proc~elec_read_elnes_mat program~od2od od2od program~od2od->proc~read_elnes_fmt program~od2od->proc~read_elnes_bin proc~core_calculate core_calculate proc~core_calculate->proc~elec_read_elnes_mat program~optados optados program~optados->proc~core_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_elnes_find_channel_names Source Code subroutine elec_elnes_find_channel_names !========================================================================= ! ! fill in some extra indexing data ! Moved from within elec_read_elnes_mat when I made od2od ! AJM 5/12/2019 use od_io , only : io_error implicit none integer :: loop !  elnes_mwab is a module variable so don't declare. do loop = 1 , elnes_mwab % norbitals if ( elnes_orbital % am_channel ( loop ) == 1 ) then elnes_orbital % am_channel ( loop ) = 0 elnes_orbital % am_channel_name ( loop ) = 's' elseif ( elnes_orbital % am_channel ( loop ) == 2 ) then elnes_orbital % am_channel ( loop ) = 1 elnes_orbital % am_channel_name ( loop ) = 'px' elseif ( elnes_orbital % am_channel ( loop ) == 3 ) then elnes_orbital % am_channel ( loop ) = 1 elnes_orbital % am_channel_name ( loop ) = 'py' elseif ( elnes_orbital % am_channel ( loop ) == 4 ) then elnes_orbital % am_channel ( loop ) = 1 elnes_orbital % am_channel_name ( loop ) = 'pz' elseif ( elnes_orbital % am_channel ( loop ) == 5 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dzz' elseif ( elnes_orbital % am_channel ( loop ) == 6 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dzy' elseif ( elnes_orbital % am_channel ( loop ) == 7 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dzx' elseif ( elnes_orbital % am_channel ( loop ) == 8 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dxx-yy' elseif ( elnes_orbital % am_channel ( loop ) == 9 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dxy' elseif ( elnes_orbital % am_channel ( loop ) == 10 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fxxx' elseif ( elnes_orbital % am_channel ( loop ) == 11 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fyyy' elseif ( elnes_orbital % am_channel ( loop ) == 12 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fzzz' elseif ( elnes_orbital % am_channel ( loop ) == 13 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fxyz' elseif ( elnes_orbital % am_channel ( loop ) == 14 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fz(xx-yy)' elseif ( elnes_orbital % am_channel ( loop ) == 15 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fy(zz-xx)' elseif ( elnes_orbital % am_channel ( loop ) == 16 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fx(yy-zz)' else call io_error ( ' Error : unknown angular momentum state in elec_elnes_find_channel_names' ) end if end do end subroutine elec_elnes_find_channel_names","tags":"","loc":"proc/elec_elnes_find_channel_names.html"},{"title":"elec_elnes_find_channel_numbers – OptaDOS","text":"public  subroutine elec_elnes_find_channel_numbers() Uses od_io proc~~elec_elnes_find_channel_numbers~~UsesGraph proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers module~od_io od_io proc~elec_elnes_find_channel_numbers->module~od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_elnes_find_channel_numbers~~CallsGraph proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers selectcase selectcase proc~elec_elnes_find_channel_numbers->selectcase proc~io_error io_error proc~elec_elnes_find_channel_numbers->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_elnes_find_channel_numbers~~CalledByGraph proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~write_elnes_bin write_elnes_bin proc~write_elnes_bin->proc~elec_elnes_find_channel_numbers proc~write_elnes_fmt write_elnes_fmt proc~write_elnes_fmt->proc~elec_elnes_find_channel_numbers program~od2od od2od program~od2od->proc~write_elnes_bin program~od2od->proc~write_elnes_fmt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_elnes_find_channel_numbers Source Code subroutine elec_elnes_find_channel_numbers !========================================================================= ! ! The elnes_bin has channel numbers 1-16 internally optados thinks about ! channel names. So we need to be able to go back and forth. ! ! CASTEP (hence the bin file) and OptaDOS think about am_channel numbers ! differently. To keep consistent we convert to CASTEP's numbering scheme ! before we write out. ! AJM 5/12/2019 use od_io , only : io_error implicit none integer :: loop do loop = 1 , elnes_mwab % norbitals selectcase ( trim ( elnes_orbital % am_channel_name ( loop ))) case ( 's' ) elnes_orbital % am_channel ( loop ) = 1 case ( 'px' ) elnes_orbital % am_channel ( loop ) = 2 case ( 'py' ) elnes_orbital % am_channel ( loop ) = 3 case ( 'pz' ) elnes_orbital % am_channel ( loop ) = 4 case ( 'dzz' ) elnes_orbital % am_channel ( loop ) = 5 case ( 'dzy' ) elnes_orbital % am_channel ( loop ) = 6 case ( 'dzx' ) elnes_orbital % am_channel ( loop ) = 7 case ( 'dxx-yy' ) elnes_orbital % am_channel ( loop ) = 8 case ( 'dxy' ) elnes_orbital % am_channel ( loop ) = 9 case ( 'fxxx' ) elnes_orbital % am_channel ( loop ) = 10 case ( 'fyyy' ) elnes_orbital % am_channel ( loop ) = 11 case ( 'fzzz' ) elnes_orbital % am_channel ( loop ) = 12 case ( 'fxyz' ) elnes_orbital % am_channel ( loop ) = 13 case ( 'fz(xx-yy)' ) elnes_orbital % am_channel ( loop ) = 14 case ( 'fy(zz-xx)' ) elnes_orbital % am_channel ( loop ) = 15 case ( 'fx(yy-zz)' ) elnes_orbital % am_channel ( loop ) = 16 case default call io_error ( ' Error : unknown angular momentum state in elec_elnes_find_channel_numbers' ) end select end do end subroutine elec_elnes_find_channel_numbers","tags":"","loc":"proc/elec_elnes_find_channel_numbers.html"},{"title":"elec_pdis_read – OptaDOS","text":"public  subroutine elec_pdis_read() Uses od_comms od_cell od_parameters od_io proc~~elec_pdis_read~~UsesGraph proc~elec_pdis_read elec_pdis_read module~od_comms od_comms proc~elec_pdis_read->module~od_comms module~od_parameters od_parameters proc~elec_pdis_read->module~od_parameters module~od_io od_io proc~elec_pdis_read->module~od_io module~od_cell od_cell proc~elec_pdis_read->module~od_cell module~od_constants od_constants module~od_comms->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_pdis_read~~CallsGraph proc~elec_pdis_read elec_pdis_read proc~io_file_unit io_file_unit proc~elec_pdis_read->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_pdis_read->interface~comms_bcast proc~io_error io_error proc~elec_pdis_read->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_pdis_read~~CalledByGraph proc~elec_pdis_read elec_pdis_read proc~pdis_calculate pdis_calculate proc~pdis_calculate->proc~elec_pdis_read program~optados optados program~optados->proc~pdis_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_pdis_read Source Code subroutine elec_pdis_read !========================================================================= ! Read in the full pdos_weights, in correct kpoint path order. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: pw, pdos_weights, pdos_orbital !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Adapted by M L Evans from elec_pdos_read written by A J Morris Aug 2018 !========================================================================= use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : stdout , io_file_unit , io_error , seedname , filename_len use od_cell , only : num_kpoints_on_node , nkpoints use od_parameters , only : legacy_file_format , devel_flag , iprint implicit none ! Band indices used in the read-in of the pdos integer , allocatable , dimension (:, :) :: all_nbands_occ real ( kind = dp ) :: dummyr1 , dummyr2 , dummyr3 integer :: dummyk , cachek , dummyi , ib , ik , is , stride , iorb integer :: pdos_in_unit , ierr , inodes , iall_kpoints logical :: full_debug_pdos_weights = . false . character ( filename_len ) :: pdos_filename character ( len = 80 ) :: header real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp if ( allocated ( pdos_weights )) return !-------------------------------------------------------------------------! ! R E A D   T H E   D A T A   H E A D E R !-------------------------------------------------------------------------! if ( on_root ) then pdos_in_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then pdos_filename = trim ( seedname ) // \".pdos_weights\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , form = 'unformatted' , err = 100 , status = 'old' ) else pdos_filename = trim ( seedname ) // \".pdos_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( pdos_in_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of pdos_bin file. Update optados!' ) read ( pdos_in_unit ) header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( header ) end if read ( pdos_in_unit ) pdos_mwab % nkpoints read ( pdos_in_unit ) pdos_mwab % nspins read ( pdos_in_unit ) pdos_mwab % norbitals read ( pdos_in_unit ) pdos_mwab % nbands if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) \"pdos_mwab%nkpoints= \" , pdos_mwab % nkpoints write ( stdout , * ) \"pdos_mwab%nspins= \" , pdos_mwab % nspins write ( stdout , * ) \"pdos_mwab%norbitals= \" , pdos_mwab % norbitals write ( stdout , * ) \"pdos_mwab%nbands= \" , pdos_mwab % nbands write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) read ( pdos_in_unit ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! call comms_bcast ( pdos_mwab % norbitals , 1 ) call comms_bcast ( pdos_mwab % nbands , 1 ) call comms_bcast ( pdos_mwab % nkpoints , 1 ) call comms_bcast ( pdos_mwab % nspins , 1 ) end if if (. not . on_root ) then allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) end if call comms_bcast ( pdos_orbital % species_no ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % rank_in_species ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % am_channel ( 1 ), pdos_mwab % norbitals ) !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A allocate ( all_nbands_occ ( 1 : nkpoints , 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate all_nbands_occ\" allocate ( pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : num_kpoints_on_node ( 0 ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate pdos_weights\" allocate ( all_pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : nkpoints , 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate all_pdos_weights\" if ( on_root ) then ! Read in the k-points in the correct path ordering, not the file ordering cachek = 0 stride = 1 do ik = 1 , nkpoints ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit ) dummyk , dummyr1 , dummyr2 , dummyr3 if ( ik == 2 ) then stride = dummyk - cachek end if if (( dummyk - cachek ) < stride ) then if ( mod ( ik , ( nkpoints / stride )) == 1 ) then dummyk = dummyk else dummyk = cachek + stride end if end if cachek = dummyk do is = 1 , pdos_mwab % nspins read ( pdos_in_unit ) dummyi ! this is the spin number read ( pdos_in_unit ) all_nbands_occ ( dummyk , is ) do ib = 1 , all_nbands_occ ( dummyk , is ) read ( pdos_in_unit ) all_pdos_weights ( 1 : pdos_mwab % norbitals , ib , dummyk , is ) end do end do end do close ( pdos_in_unit ) end if call comms_bcast ( all_pdos_weights ( 1 , 1 , 1 , 1 ), size ( all_pdos_weights )) iall_kpoints = 0 do inodes = 0 , my_node_id - 1 iall_kpoints = iall_kpoints + inodes * num_kpoints_on_node ( inodes ) end do do ik = 1 , num_kpoints_on_node ( my_node_id ) do is = 1 , pdos_mwab % nspins do ib = 1 , all_nbands_occ ( ik + iall_kpoints , is ) do iorb = 1 , pdos_mwab % norbitals pdos_weights ( iorb , ib , ik , is ) = all_pdos_weights ( iorb , ib , ik + iall_kpoints , is ) end do end do end do end do deallocate ( all_pdos_weights ) return 100 call io_error ( 'Error: Problem opening pdos_weights file in elec_pdis_read' ) 102 call io_error ( 'Error: Problem opening pdos_bin file in elec_pdis_read' ) end subroutine elec_pdis_read","tags":"","loc":"proc/elec_pdis_read.html"},{"title":"elec_pdos_read – OptaDOS","text":"public  subroutine elec_pdos_read() Uses od_comms od_cell od_parameters od_io proc~~elec_pdos_read~~UsesGraph proc~elec_pdos_read elec_pdos_read module~od_comms od_comms proc~elec_pdos_read->module~od_comms module~od_parameters od_parameters proc~elec_pdos_read->module~od_parameters module~od_io od_io proc~elec_pdos_read->module~od_io module~od_cell od_cell proc~elec_pdos_read->module~od_cell module~od_constants od_constants module~od_comms->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_pdos_read~~CallsGraph proc~elec_pdos_read elec_pdos_read proc~io_file_unit io_file_unit proc~elec_pdos_read->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_pdos_read->interface~comms_bcast interface~comms_recv comms_recv proc~elec_pdos_read->interface~comms_recv interface~comms_send comms_send proc~elec_pdos_read->interface~comms_send proc~io_error io_error proc~elec_pdos_read->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_pdos_read~~CalledByGraph proc~elec_pdos_read elec_pdos_read proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~elec_pdos_read proc~read_pdos_bin read_pdos_bin proc~read_pdos_bin->proc~elec_pdos_read program~optados optados program~optados->proc~pdos_calculate program~od2od od2od program~od2od->proc~read_pdos_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_pdos_read Source Code subroutine elec_pdos_read !========================================================================= ! Read in the full pdos_weights. Write out any variables that we find on the ! way. These will be checked for consistency in the dos module. We can't do it ! yet as we haven't read the bands file. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: pw, pdos_weights, pdos_orbital !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : stdout , io_file_unit , io_error , seedname , filename_len use od_cell , only : num_kpoints_on_node use od_parameters , only : legacy_file_format , devel_flag , iprint implicit none ! Band indices used in the read-in of the pdos real ( kind = dp ) :: dummyr1 , dummyr2 , dummyr3 integer :: dummyi , ib , ik , is integer :: pdos_in_unit , ierr , inodes logical :: full_debug_pdos_weights = . false . character ( filename_len ) :: pdos_filename real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp if ( allocated ( pdos_weights )) return !-------------------------------------------------------------------------! ! R E A D   T H E   D A T A   H E A D E R if ( on_root ) then pdos_in_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then pdos_filename = trim ( seedname ) // \".pdos_weights\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , form = 'unformatted' , err = 100 , status = 'old' ) else pdos_filename = trim ( seedname ) // \".pdos_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( pdos_in_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of pdos_bin file. Update optados!' ) read ( pdos_in_unit ) pdosfile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( pdosfile_header ) end if read ( pdos_in_unit ) pdos_mwab % nkpoints read ( pdos_in_unit ) pdos_mwab % nspins read ( pdos_in_unit ) pdos_mwab % norbitals read ( pdos_in_unit ) pdos_mwab % nbands if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) \"pdos_mwab%nkpoints= \" , pdos_mwab % nkpoints write ( stdout , * ) \"pdos_mwab%nspins= \" , pdos_mwab % nspins write ( stdout , * ) \"pdos_mwab%norbitals= \" , pdos_mwab % norbitals write ( stdout , * ) \"pdos_mwab%nbands= \" , pdos_mwab % nbands write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) read ( pdos_in_unit ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! end if call comms_bcast ( pdos_mwab % norbitals , 1 ) call comms_bcast ( pdos_mwab % nbands , 1 ) call comms_bcast ( pdos_mwab % nkpoints , 1 ) call comms_bcast ( pdos_mwab % nspins , 1 ) if (. not . on_root ) then allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) end if call comms_bcast ( pdos_orbital % species_no ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % rank_in_species ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % am_channel ( 1 ), pdos_mwab % norbitals ) !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A allocate ( nbands_occ ( 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate nbands_occ\" allocate ( pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate pdos_weights\" if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit ) dummyi , dummyr1 , dummyr2 , dummyr3 do is = 1 , pdos_mwab % nspins read ( pdos_in_unit ) dummyi ! this is the spin number read ( pdos_in_unit ) nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) write ( nbands_occ ( ik , is )) do ib = 1 , nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) ib , ik , is write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if read ( pdos_in_unit ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) end do end do end do call comms_send ( pdos_weights ( 1 , 1 , 1 , 1 ), pdos_mwab % norbitals * pdos_mwab % nbands * & nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit ) dummyi , dummyr1 , dummyr2 , dummyr3 do is = 1 , pdos_mwab % nspins read ( pdos_in_unit ) dummyi ! this is the spin number read ( pdos_in_unit ) nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) write ( stdout , * ) nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) ib , ik , is write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if read ( pdos_in_unit ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) if ( full_debug_pdos_weights ) write ( stdout , * ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) end do end do end do end if if (. not . on_root ) then call comms_recv ( pdos_weights ( 1 , 1 , 1 , 1 ), pdos_mwab % norbitals * pdos_mwab % nbands * & nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( pdos_in_unit ) return 100 call io_error ( 'Error: Problem opening pdos_weights file in elec_pdos_read' ) 102 call io_error ( 'Error: Problem opening pdos_bin file in elec_pdos_read' ) end subroutine elec_pdos_read","tags":"","loc":"proc/elec_pdos_read.html"},{"title":"elec_read_band_curvature – OptaDOS","text":"public  subroutine elec_read_band_curvature() Uses od_algorithms od_parameters od_comms od_cell od_constants od_io proc~~elec_read_band_curvature~~UsesGraph proc~elec_read_band_curvature elec_read_band_curvature module~od_algorithms od_algorithms proc~elec_read_band_curvature->module~od_algorithms module~od_parameters od_parameters proc~elec_read_band_curvature->module~od_parameters module~od_comms od_comms proc~elec_read_band_curvature->module~od_comms module~od_constants od_constants proc~elec_read_band_curvature->module~od_constants module~od_cell od_cell proc~elec_read_band_curvature->module~od_cell module~od_io od_io proc~elec_read_band_curvature->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_band_curvature~~CallsGraph proc~elec_read_band_curvature elec_read_band_curvature interface~comms_bcast comms_bcast proc~elec_read_band_curvature->interface~comms_bcast proc~io_time io_time proc~elec_read_band_curvature->proc~io_time proc~io_error io_error proc~elec_read_band_curvature->proc~io_error proc~algor_dist_array algor_dist_array proc~elec_read_band_curvature->proc~algor_dist_array proc~io_file_unit io_file_unit proc~elec_read_band_curvature->proc~io_file_unit interface~comms_send comms_send proc~elec_read_band_curvature->interface~comms_send interface~comms_recv comms_recv proc~elec_read_band_curvature->interface~comms_recv proc~algor_dist_array->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_band_curvature Source Code subroutine elec_read_band_curvature !========================================================================= ! Read the .ddome file in paralell if appropriate. These are the ! curvatures of the bands at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_curvature,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  V Chang                                             Nov 2020 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send , comms_bcast use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: curvature_unit , i , j , ib , jb , is , ik , inodes , ierr , loop character ( filename_len ) :: curvature_filename character ( len = 80 ) :: header logical :: exists real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp ! Check that we haven't already done this. if ( allocated ( band_curvature )) return ! first try to read a effective mass file curvature_filename = trim ( seedname ) // \".ddome_bin\" if ( on_root ) inquire ( file = curvature_filename , exist = exists ) call comms_bcast ( exists , 1 ) if ( exists ) then ! good. We are reading from a velocity file time0 = io_time () if ( on_root ) then if ( iprint > 1 ) write ( stdout , '(a)' ) ' ' if ( iprint > 1 ) write ( stdout , '(a)' ) ' Reading band curvature from file:' // trim ( curvature_filename ) curvature_unit = io_file_unit () curvature_filename = trim ( seedname ) // \".ddome_bin\" open ( unit = curvature_unit , file = curvature_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( curvature_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of ddome_bin file. Update optados!' ) read ( curvature_unit ) femfile_header if ( iprint > 1 ) write ( stdout , * ) trim ( femfile_header ) end if ! Figure out how many kpoint should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( band_curvature ( 1 : nbands , 1 : 3 , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_curvature in elec_read_band_curvature' ) if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins do ib = 1 , nbands do i = 1 , 3 do j = 1 , 3 read ( curvature_unit ) band_curvature ( ib , i , j , ik , is ) end do end do end do end do end do call comms_send ( band_curvature ( 1 , 1 , 1 , 1 , 1 ), nbands * 3 * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins do ib = 1 , nbands do i = 1 , 3 do j = 1 , 3 read ( curvature_unit ) band_curvature ( ib , i , j , ik , is ) end do end do end do end do end do end if if (. not . on_root ) then call comms_recv ( band_curvature ( 1 , 1 , 1 , 1 , 1 ), nbands * 3 * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = curvature_unit ) ! Convert all band curvatures to eV Ang&#94;2 band_curvature = band_curvature * bohr2ang * bohr2ang * H2eV time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read band curvature' , time1 - time0 , ' (sec)' end if return 101 call io_error ( 'Error: Problem opening cst_vel file in read_band_curvature' ) 102 call io_error ( 'Error: Problem opening dome_bin file in read_band_curvature' ) end subroutine elec_read_band_curvature","tags":"","loc":"proc/elec_read_band_curvature.html"},{"title":"elec_read_band_energy – OptaDOS","text":"public  subroutine elec_read_band_energy() Uses od_algorithms od_parameters od_comms od_cell od_constants od_io proc~~elec_read_band_energy~~UsesGraph proc~elec_read_band_energy elec_read_band_energy module~od_algorithms od_algorithms proc~elec_read_band_energy->module~od_algorithms module~od_parameters od_parameters proc~elec_read_band_energy->module~od_parameters module~od_comms od_comms proc~elec_read_band_energy->module~od_comms module~od_constants od_constants proc~elec_read_band_energy->module~od_constants module~od_cell od_cell proc~elec_read_band_energy->module~od_cell module~od_io od_io proc~elec_read_band_energy->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_band_energy~~CallsGraph proc~elec_read_band_energy elec_read_band_energy proc~io_time io_time proc~elec_read_band_energy->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_band_energy->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_read_band_energy->interface~comms_bcast proc~algor_dist_array algor_dist_array proc~elec_read_band_energy->proc~algor_dist_array proc~io_error io_error proc~elec_read_band_energy->proc~io_error interface~comms_send comms_send proc~elec_read_band_energy->interface~comms_send proc~cell_find_mp_grid cell_find_MP_grid proc~elec_read_band_energy->proc~cell_find_mp_grid interface~comms_recv comms_recv proc~elec_read_band_energy->interface~comms_recv proc~algor_dist_array->proc~io_error proc~cell_find_mp_grid->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_read_band_energy~~CalledByGraph proc~elec_read_band_energy elec_read_band_energy proc~get_band_energy get_band_energy proc~get_band_energy->proc~elec_read_band_energy program~optados optados program~optados->proc~elec_read_band_energy program~od2od od2od program~od2od->proc~get_band_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_band_energy Source Code subroutine elec_read_band_energy !(band_energy,kpoint_r,kpoint_weight) !========================================================================= ! Read the .bands file in the kpoint list, kpoint weights and band energies ! also obtain, nkpoints, nspins, num_electrons(:),nbands, efermi_castep !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_energy, efermi_castep, num_electrons ! spin_polarised, electrons_per_state, nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_constants , only : H2eV use od_cell , only : nkpoints , kpoint_r , kpoint_weight , cell_find_MP_grid ,& & real_lattice , kpoint_grid_dim , num_kpoints_on_node use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time ,& & io_error use od_algorithms , only : algor_dist_array use od_parameters , only : iprint , compute_band_gap , kpoint_mp_grid implicit none integer :: inodes , ik , is , ib , band_unit , iall_kpoints , i integer :: dum_i1 , ierr , str_pos character ( filename_len ) :: band_filename character ( len = 80 ) :: dummy real ( kind = dp ) :: time0 , time1 time0 = io_time () ! Check that we haven't already read in the energies if ( allocated ( band_energy )) return !Open the bands file band_unit = io_file_unit () band_filename = trim ( seedname ) // \".bands\" ! Read the header from the bands file if ( on_root ) then open ( unit = band_unit , file = band_filename , status = \"old\" , form = 'formatted' , err = 100 ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'k-points' ) read ( dummy ( str_pos + 8 :), * ) nkpoints read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'components' ) read ( dummy ( str_pos + 10 :), * ) nspins read ( band_unit , '(a)' ) dummy allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" str_pos = index ( dummy , 'electrons' ) read ( dummy ( str_pos + 10 :), * ) num_electrons (:) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'eigenvalues' ) read ( dummy ( str_pos + 11 :), * ) nbands read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'units)' ) read ( dummy ( str_pos + 6 :), '(f12.4)' ) efermi_castep read ( band_unit , '(a)' ) dummy read ( band_unit , * ) real_lattice (:, 1 ) read ( band_unit , * ) real_lattice (:, 2 ) read ( band_unit , * ) real_lattice (:, 3 ) end if call comms_bcast ( nspins , 1 ) if (. not . on_root ) then allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" end if call comms_bcast ( num_electrons ( 1 ), nspins ) call comms_bcast ( nkpoints , 1 ) call comms_bcast ( nbands , 1 ) call comms_bcast ( efermi_castep , 1 ) ! call algor_dist_array ( nkpoints , num_kpoints_on_node ) ! allocate ( band_energy ( 1 : nbands , 1 : nspins , 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_energy in read_band_energy' ) allocate ( kpoint_weight ( 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_weight in read_band_energy' ) allocate ( kpoint_r ( 1 : 3 , 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_r in read_band_energy' ) if ( on_root ) then allocate ( all_kpoints ( 1 : 3 , nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating all_kpoints in read_band_energy' ) iall_kpoints = 1 do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'K-point' ) read ( dummy ( str_pos + 7 :), * ) dum_i1 , kpoint_r ( 1 , ik ), kpoint_r ( 2 , ik ), kpoint_r ( 3 , ik ), kpoint_weight ( ik ) do i = 1 , 3 all_kpoints ( i , iall_kpoints ) = kpoint_r ( i , ik ) end do iall_kpoints = iall_kpoints + 1 do is = 1 , nspins read ( band_unit , * ) dummy do ib = 1 , nbands read ( band_unit , * ) band_energy ( ib , is , ik ) !NB spin <-> kpt swapped end do end do end do call comms_send ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( inodes ), inodes ) call comms_send ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( inodes ), inodes ) call comms_send ( kpoint_weight ( 1 ), num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'K-point' ) read ( dummy ( str_pos + 7 :), * ) dum_i1 , kpoint_r ( 1 , ik ), kpoint_r ( 2 , ik ), kpoint_r ( 3 , ik ), kpoint_weight ( ik ) do i = 1 , 3 all_kpoints ( i , iall_kpoints ) = kpoint_r ( i , ik ) end do iall_kpoints = iall_kpoints + 1 do is = 1 , nspins read ( band_unit , * ) dummy do ib = 1 , nbands read ( band_unit , * ) band_energy ( ib , is , ik ) !NB spin <-> kpt swapped end do end do end do ! Do this here so we can free up the all_kpoints memory, unless we need it to calculate ! the kpoints at the band-gap. if ( kpoint_mp_grid ( 1 ) > 0 ) then ! we must have set this manually kpoint_grid_dim = kpoint_mp_grid else call cell_find_MP_grid ( all_kpoints , nkpoints , kpoint_grid_dim ) end if if ((. not . compute_band_gap )) then deallocate ( all_kpoints , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoints in read_band_energy' ) end if end if if (. not . on_root ) then call comms_recv ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( my_node_id ), root_id ) call comms_recv ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( my_node_id ), root_id ) call comms_recv ( kpoint_weight ( 1 ), num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = band_unit ) band_energy = band_energy * H2eV efermi_castep = efermi_castep * H2eV ! Things that follow if ( nspins . lt . 2 ) then spin_polarised = . false . electrons_per_state = 2.0_dp else spin_polarised = . true . electrons_per_state = 1.0_dp end if time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read band energies  ' , time1 - time0 , ' (sec)' return 100 call io_error ( 'Error: Problem opening bands file in read_band_energy' ) end subroutine elec_read_band_energy","tags":"","loc":"proc/elec_read_band_energy.html"},{"title":"elec_read_band_energy_ordered – OptaDOS","text":"public  subroutine elec_read_band_energy_ordered() Uses od_algorithms od_parameters od_comms od_cell od_constants od_io proc~~elec_read_band_energy_ordered~~UsesGraph proc~elec_read_band_energy_ordered elec_read_band_energy_ordered module~od_algorithms od_algorithms proc~elec_read_band_energy_ordered->module~od_algorithms module~od_parameters od_parameters proc~elec_read_band_energy_ordered->module~od_parameters module~od_comms od_comms proc~elec_read_band_energy_ordered->module~od_comms module~od_constants od_constants proc~elec_read_band_energy_ordered->module~od_constants module~od_cell od_cell proc~elec_read_band_energy_ordered->module~od_cell module~od_io od_io proc~elec_read_band_energy_ordered->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_band_energy_ordered~~CallsGraph proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~io_time io_time proc~elec_read_band_energy_ordered->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_band_energy_ordered->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_read_band_energy_ordered->interface~comms_bcast proc~algor_dist_array algor_dist_array proc~elec_read_band_energy_ordered->proc~algor_dist_array proc~io_error io_error proc~elec_read_band_energy_ordered->proc~io_error interface~comms_send comms_send proc~elec_read_band_energy_ordered->interface~comms_send proc~cell_find_mp_grid cell_find_MP_grid proc~elec_read_band_energy_ordered->proc~cell_find_mp_grid interface~comms_recv comms_recv proc~elec_read_band_energy_ordered->interface~comms_recv proc~algor_dist_array->proc~io_error proc~cell_find_mp_grid->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_read_band_energy_ordered~~CalledByGraph proc~elec_read_band_energy_ordered elec_read_band_energy_ordered program~optados optados program~optados->proc~elec_read_band_energy_ordered Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_band_energy_ordered Source Code subroutine elec_read_band_energy_ordered !(band_energy,kpoint_r,kpoint_weight) !========================================================================= ! Read the .bands file in the kpoint list, kpoint weights and band energies ! also obtain, nkpoints, nspins, num_electrons(:),nbands, efermi_castep ! in the correct order. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_energy, efermi_castep, num_electrons ! spin_polarised, electrons_per_state, nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_constants , only : H2eV use od_cell , only : nkpoints , kpoint_r , kpoint_weight , cell_find_MP_grid ,& & real_lattice , kpoint_grid_dim , num_kpoints_on_node use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time ,& & io_error use od_algorithms , only : algor_dist_array use od_parameters , only : iprint , compute_band_gap , kpoint_mp_grid , pdis implicit none integer :: inodes , ik , is , ib , band_unit , iall_kpoints , i integer :: ik_bandfile , ierr , str_pos character ( filename_len ) :: band_filename character ( len = 80 ) :: dummy real ( kind = dp ) :: time0 , time1 real ( kind = dp ), allocatable :: all_band_energy (:, :, :) real ( kind = dp ) :: dummy_kpt ( 4 ) time0 = io_time () ! Check that we haven't already read in the energies if ( allocated ( band_energy )) return !Open the bands file band_unit = io_file_unit () band_filename = trim ( seedname ) // \".bands\" ! Read the header from the bands file if ( on_root ) then open ( unit = band_unit , file = band_filename , status = \"old\" , form = 'formatted' , err = 100 ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'k-points' ) read ( dummy ( str_pos + 8 :), * ) nkpoints read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'components' ) read ( dummy ( str_pos + 10 :), * ) nspins read ( band_unit , '(a)' ) dummy allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" str_pos = index ( dummy , 'electrons' ) read ( dummy ( str_pos + 10 :), * ) num_electrons (:) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'eigenvalues' ) read ( dummy ( str_pos + 11 :), * ) nbands read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'units)' ) read ( dummy ( str_pos + 6 :), '(f12.4)' ) efermi_castep read ( band_unit , '(a)' ) dummy read ( band_unit , * ) real_lattice (:, 1 ) read ( band_unit , * ) real_lattice (:, 2 ) read ( band_unit , * ) real_lattice (:, 3 ) end if call comms_bcast ( nspins , 1 ) if (. not . on_root ) then allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" end if call comms_bcast ( num_electrons ( 1 ), nspins ) call comms_bcast ( nkpoints , 1 ) call comms_bcast ( nbands , 1 ) call comms_bcast ( efermi_castep , 1 ) ! call algor_dist_array ( nkpoints , num_kpoints_on_node ) ! allocate ( band_energy ( 1 : nbands , 1 : nspins , 1 : num_kpoints_on_node ( 0 )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_energy in read_band_energy' ) allocate ( all_band_energy ( 1 : nbands , 1 : nspins , 1 : nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating all_band_energy in read_band_energy' ) allocate ( kpoint_weight ( 1 : num_kpoints_on_node ( 0 )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_weight in read_band_energy' ) allocate ( kpoint_r ( 1 : 3 , 1 : num_kpoints_on_node ( 0 )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_r in read_band_energy' ) if ( on_root ) then allocate ( all_kpoints ( 1 : 3 , nkpoints ), stat = ierr ) allocate ( all_kpoint_weight ( nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating all_kpoints in read_band_energy' ) do ik = 1 , nkpoints read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'K-point' ) dummy_kpt = 0 read ( dummy ( str_pos + 7 :), * ) ik_bandfile , dummy_kpt ( 1 ), dummy_kpt ( 2 ), dummy_kpt ( 4 ) do i = 1 , 3 all_kpoints ( i , ik_bandfile ) = dummy_kpt ( i ) end do all_kpoint_weight ( ik_bandfile ) = dummy_kpt ( 4 ) do is = 1 , nspins read ( band_unit , * ) dummy do ib = 1 , nbands read ( band_unit , * ) all_band_energy ( ib , is , ik_bandfile ) !NB spin <-> kpt swapped end do end do end do ! split bands across node-level arrays iall_kpoints = 0 do inodes = 0 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do i = 1 , 3 kpoint_r ( i , ik ) = all_kpoints ( i , ik + iall_kpoints ) end do kpoint_weight ( ik ) = all_kpoint_weight ( ik + iall_kpoints ) do is = 1 , nspins do ib = 1 , nbands band_energy ( ib , is , ik ) = all_band_energy ( ib , is , ik + iall_kpoints ) !NB spin <-> kpt swapped end do end do end do iall_kpoints = iall_kpoints + num_kpoints_on_node ( inodes ) ! distribute bands across kpoints if ( inodes /= 0 ) then call comms_send ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( 0 ), inodes ) call comms_send ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( 0 ), inodes ) call comms_send ( kpoint_weight ( 1 ), num_kpoints_on_node ( 0 ), inodes ) end if end do ! Do this here so we can free up the all_kpoints memory, unless we need it to calculate ! the kpoints at the band-gap or do a pdispersion if ( kpoint_mp_grid ( 1 ) > 0 ) then ! we must have set this manually kpoint_grid_dim = kpoint_mp_grid else call cell_find_MP_grid ( all_kpoints , nkpoints , kpoint_grid_dim ) end if if ((. not . compute_band_gap ) . and . (. not . pdis )) then deallocate ( all_kpoints , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoints in read_band_energy' ) deallocate ( all_band_energy , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_band_energy in read_band_energy' ) deallocate ( all_kpoint_weight , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoint_weight in read_band_energy' ) end if end if if (. not . on_root ) then call comms_recv ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( 0 ), root_id ) call comms_recv ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( 0 ), root_id ) call comms_recv ( kpoint_weight ( 1 ), num_kpoints_on_node ( 0 ), root_id ) end if if ( on_root ) close ( unit = band_unit ) band_energy = band_energy * H2eV efermi_castep = efermi_castep * H2eV ! Things that follow if ( nspins . lt . 2 ) then spin_polarised = . false . electrons_per_state = 2.0_dp else spin_polarised = . true . electrons_per_state = 1.0_dp end if time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read band energies  ' , time1 - time0 , ' (sec)' return 100 call io_error ( 'Error: Problem opening bands file in read_band_energy' ) end subroutine elec_read_band_energy_ordered","tags":"","loc":"proc/elec_read_band_energy_ordered.html"},{"title":"elec_read_band_gradient – OptaDOS","text":"public  subroutine elec_read_band_gradient() Uses od_algorithms od_parameters od_comms od_cell od_constants od_io proc~~elec_read_band_gradient~~UsesGraph proc~elec_read_band_gradient elec_read_band_gradient module~od_algorithms od_algorithms proc~elec_read_band_gradient->module~od_algorithms module~od_parameters od_parameters proc~elec_read_band_gradient->module~od_parameters module~od_comms od_comms proc~elec_read_band_gradient->module~od_comms module~od_constants od_constants proc~elec_read_band_gradient->module~od_constants module~od_cell od_cell proc~elec_read_band_gradient->module~od_cell module~od_io od_io proc~elec_read_band_gradient->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_band_gradient~~CallsGraph proc~elec_read_band_gradient elec_read_band_gradient interface~comms_bcast comms_bcast proc~elec_read_band_gradient->interface~comms_bcast proc~io_time io_time proc~elec_read_band_gradient->proc~io_time proc~io_error io_error proc~elec_read_band_gradient->proc~io_error proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array proc~io_file_unit io_file_unit proc~elec_read_band_gradient->proc~io_file_unit interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->interface~comms_recv proc~elec_dealloc_optical->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_read_band_gradient~~CalledByGraph proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_set_efermi dos_utils_set_efermi proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_dome_bin read_dome_bin proc~read_dome_bin->proc~elec_read_band_gradient proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~core_calculate core_calculate proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~jdos_calculate jdos_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~dos_calculate dos_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~optics_calculate optics_calculate proc~optics_calculate->proc~jdos_utils_calculate proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e program~od2od od2od program~od2od->proc~read_dome_bin program~optados optados program~optados->proc~pdos_calculate program~optados->proc~core_calculate program~optados->proc~jdos_calculate program~optados->proc~dos_calculate program~optados->proc~optics_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_band_gradient Source Code subroutine elec_read_band_gradient !========================================================================= ! Read the .cst_ome file in paralell if appropriate. These are the ! gradients of the bands at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_gradient,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send , comms_bcast use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: gradient_unit , i , ib , jb , is , ik , inodes , ierr , loop character ( filename_len ) :: gradient_filename logical :: exists real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp ! Check that we haven't already done this. if ( allocated ( band_gradient )) return ! first try to read a velocity file if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then gradient_filename = trim ( seedname ) // \".cst_vel\" else gradient_filename = trim ( seedname ) // \".dome_bin\" end if if ( on_root ) inquire ( file = gradient_filename , exist = exists ) call comms_bcast ( exists , 1 ) if ( exists ) then ! good. We are reading from a velocity file time0 = io_time () if ( on_root ) then !if (iprint > 1) write (stdout, '(a)') ' ' if ( iprint > 1 ) write ( stdout , '(a)' ) ' Reading band gradients from file: ' // trim ( gradient_filename ) gradient_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then gradient_filename = trim ( seedname ) // \".cst_vel\" open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 101 ) else gradient_filename = trim ( seedname ) // \".dome_bin\" open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( gradient_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of dome_bin file. Update optados!' ) read ( gradient_unit ) domefile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( domefile_header ) end if end if ! Figure out how many kpoint should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( band_gradient ( 1 : nbands , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_gradient in elec_read_band_gradient' ) band_gradient = 0.0_dp if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins read ( gradient_unit ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), i = 1 , 3 ) end do end do call comms_send ( band_gradient ( 1 , 1 , 1 , 1 ), nbands * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins read ( gradient_unit ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), i = 1 , 3 ) end do end do end if if (. not . on_root ) then call comms_recv ( band_gradient ( 1 , 1 , 1 , 1 ), nbands * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if !        write(*,*) \"I'm node\", my_node_id, \"k-pts:\", num_kpoints_on_node(my_node_id),\"bgarray:\", & !& size(band_gradient), \"or:\", nbands*3*nspins*num_kpoints_on_node(my_node_id) if ( on_root ) close ( unit = gradient_unit ) ! Convert all band gradients to eV Ang band_gradient = band_gradient * bohr2ang * H2eV time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a30,29x,f11.3,a8)' ) '+ Time to read band gradients ' , time1 - time0 , ' (sec) +' end if else ! lets try to get the data from the cst_ome file allocate ( band_gradient ( 1 : nbands , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_gradient (b) in elec_read_band_gradient' ) if ( allocated ( optical_mat )) then do loop = 1 , nbands band_gradient ( loop , :, :, :) = real ( optical_mat ( loop , loop , :, :, :), dp ) end do else call elec_read_optical_mat do loop = 1 , nbands band_gradient ( loop , :, :, :) = real ( optical_mat ( loop , loop , :, :, :), dp ) end do call elec_dealloc_optical ! given that it is a large matrix we'll let it go ! potentially that means reading it twice... end if end if return 101 call io_error ( 'Error: Problem opening cst_vel file in read_band_gradient' ) 102 call io_error ( 'Error: Problem opening dome_bin file in read_band_gradient' ) end subroutine elec_read_band_gradient","tags":"","loc":"proc/elec_read_band_gradient.html"},{"title":"elec_read_elnes_mat – OptaDOS","text":"public  subroutine elec_read_elnes_mat() Uses od_comms od_parameters od_io od_cell proc~~elec_read_elnes_mat~~UsesGraph proc~elec_read_elnes_mat elec_read_elnes_mat module~od_comms od_comms proc~elec_read_elnes_mat->module~od_comms module~od_parameters od_parameters proc~elec_read_elnes_mat->module~od_parameters module~od_io od_io proc~elec_read_elnes_mat->module~od_io module~od_cell od_cell proc~elec_read_elnes_mat->module~od_cell module~od_constants od_constants module~od_comms->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_io->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_elnes_mat~~CallsGraph proc~elec_read_elnes_mat elec_read_elnes_mat proc~io_time io_time proc~elec_read_elnes_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_elnes_mat->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_read_elnes_mat->interface~comms_bcast interface~comms_send comms_send proc~elec_read_elnes_mat->interface~comms_send proc~io_error io_error proc~elec_read_elnes_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_elnes_mat->interface~comms_recv proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~elec_elnes_find_channel_names->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_read_elnes_mat~~CalledByGraph proc~elec_read_elnes_mat elec_read_elnes_mat proc~read_elnes_bin read_elnes_bin proc~read_elnes_bin->proc~elec_read_elnes_mat proc~core_calculate core_calculate proc~core_calculate->proc~elec_read_elnes_mat program~od2od od2od program~od2od->proc~read_elnes_bin program~optados optados program~optados->proc~core_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_elnes_mat Source Code subroutine elec_read_elnes_mat !========================================================================= ! Read the .bands file in the kpoint list, kpoint weights and band energies ! also obtain, nkpoints, nspins, num_electrons(:),nbands, efermi_castep !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_energy, efermi_castep, num_electrons ! spin_polarised, electrons_per_state, nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_cell , only : num_kpoints_on_node use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : io_file_unit , seedname , filename_len , io_time ,& & io_error , stdout use od_parameters , only : legacy_file_format , devel_flag , iprint implicit none integer :: inodes , ik , ns , nb , indx integer :: ierr , elnes_unit , orb , loop character ( filename_len ) :: elnes_filename real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp time0 = io_time () ! Check that we haven't already read in the energies if ( allocated ( elnes_mat )) return !Open the elnes sfile if ( on_root ) then elnes_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then elnes_filename = trim ( seedname ) // \".eels_mat\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading elnes matrix elements from file: ' // trim ( elnes_filename ) open ( unit = elnes_unit , file = elnes_filename , form = 'unformatted' , err = 100 , status = 'old' ) else elnes_filename = trim ( seedname ) // \".elnes_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading elnes matrix elements from file: ' // trim ( elnes_filename ) open ( unit = elnes_unit , file = elnes_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( elnes_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of elnes_bin file. Update optados!' ) read ( elnes_unit ) elnesfile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( elnesfile_header ) end if read ( elnes_unit ) elnes_mwab % norbitals read ( elnes_unit ) elnes_mwab % nbands read ( elnes_unit ) elnes_mwab % nkpoints read ( elnes_unit ) elnes_mwab % nspins ! check these agree with band data? allocate ( elnes_orbital % ion_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%ion_no' ) allocate ( elnes_orbital % species_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%species_no' ) allocate ( elnes_orbital % rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%rank_in_species' ) allocate ( elnes_orbital % shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%shell' ) allocate ( elnes_orbital % am_channel ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel' ) allocate ( elnes_orbital % am_channel_name ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel_name' ) read ( elnes_unit ) elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) read ( elnes_unit ) elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) read ( elnes_unit ) elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) read ( elnes_unit ) elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) end if call comms_bcast ( elnes_mwab % norbitals , 1 ) call comms_bcast ( elnes_mwab % nbands , 1 ) call comms_bcast ( elnes_mwab % nkpoints , 1 ) call comms_bcast ( elnes_mwab % nspins , 1 ) if (. not . on_root ) then allocate ( elnes_orbital % ion_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%ion_no' ) allocate ( elnes_orbital % species_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%species_no' ) allocate ( elnes_orbital % rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%rank_in_species' ) allocate ( elnes_orbital % shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%shell' ) allocate ( elnes_orbital % am_channel ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel' ) allocate ( elnes_orbital % am_channel_name ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel_name' ) end if call comms_bcast ( elnes_orbital % species_no ( 1 ), elnes_mwab % norbitals ) call comms_bcast ( elnes_orbital % rank_in_species ( 1 ), elnes_mwab % norbitals ) call comms_bcast ( elnes_orbital % shell ( 1 ), elnes_mwab % norbitals ) call comms_bcast ( elnes_orbital % am_channel ( 1 ), elnes_mwab % norbitals ) ! assume same data distribution as bands allocate ( elnes_mat ( 1 : elnes_mwab % norbitals , 1 : elnes_mwab % nbands , 1 : 3 , & 1 : num_kpoints_on_node ( 0 ), 1 : elnes_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating elnes_mat in elec_read_elnes_mat' ) if ( on_root ) then if ( legacy_file_format ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do ns = 1 , elnes_mwab % nspins do orb = 1 , elnes_mwab % norbitals do nb = 1 , elnes_mwab % nbands read ( elnes_unit ) ( elnes_mat ( orb , nb , indx , ik , ns ), indx = 1 , 3 ) end do end do end do end do call comms_send ( elnes_mat ( 1 , 1 , 1 , 1 , 1 ), elnes_mwab % norbitals * elnes_mwab % nbands * 3 * & nspins * num_kpoints_on_node ( 0 ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do ns = 1 , elnes_mwab % nspins do orb = 1 , elnes_mwab % norbitals do nb = 1 , elnes_mwab % nbands read ( elnes_unit ) ( elnes_mat ( orb , nb , indx , ik , ns ), indx = 1 , 3 ) end do end do end do end do else ! sane format do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do ns = 1 , elnes_mwab % nspins read ( elnes_unit ) ((( elnes_mat ( orb , nb , indx , ik , ns ), orb = 1 , elnes_mwab % norbitals ), & nb = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do call comms_send ( elnes_mat ( 1 , 1 , 1 , 1 , 1 ), elnes_mwab % norbitals * elnes_mwab % nbands * 3 * nspins * & num_kpoints_on_node ( 0 ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do ns = 1 , elnes_mwab % nspins read ( elnes_unit ) ((( elnes_mat ( orb , nb , indx , ik , ns ), orb = 1 , elnes_mwab % norbitals ), & nb = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do end if end if if (. not . on_root ) then call comms_recv ( elnes_mat ( 1 , 1 , 1 , 1 , 1 ), elnes_mwab % norbitals * elnes_mwab % nbands * 3 * nspins * & num_kpoints_on_node ( 0 ), root_id ) end if if ( on_root ) close ( elnes_unit ) call elec_elnes_find_channel_names () time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to read Elnes Matrix Elements                     & &      ' , time1 - time0 , ' (sec) +' end if return 100 call io_error ( 'Error: Problem opening elnes file in elec_read_elnes_mat' ) 102 call io_error ( 'Error: Problem opening elnes_bin file in elec_read_elnes_mat' ) end subroutine elec_read_elnes_mat","tags":"","loc":"proc/elec_read_elnes_mat.html"},{"title":"elec_read_foptical_mat – OptaDOS","text":"public  subroutine elec_read_foptical_mat() Uses od_algorithms od_parameters od_comms od_cell od_constants od_io proc~~elec_read_foptical_mat~~UsesGraph proc~elec_read_foptical_mat elec_read_foptical_mat module~od_algorithms od_algorithms proc~elec_read_foptical_mat->module~od_algorithms module~od_parameters od_parameters proc~elec_read_foptical_mat->module~od_parameters module~od_comms od_comms proc~elec_read_foptical_mat->module~od_comms module~od_constants od_constants proc~elec_read_foptical_mat->module~od_constants module~od_cell od_cell proc~elec_read_foptical_mat->module~od_cell module~od_io od_io proc~elec_read_foptical_mat->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_foptical_mat~~CallsGraph proc~elec_read_foptical_mat elec_read_foptical_mat proc~io_time io_time proc~elec_read_foptical_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_foptical_mat->proc~io_file_unit proc~algor_dist_array algor_dist_array proc~elec_read_foptical_mat->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_foptical_mat->interface~comms_send proc~io_error io_error proc~elec_read_foptical_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_foptical_mat->interface~comms_recv interface~comms_reduce comms_reduce proc~elec_read_foptical_mat->interface~comms_reduce proc~algor_dist_array->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_read_foptical_mat~~CalledByGraph proc~elec_read_foptical_mat elec_read_foptical_mat proc~read_fem_bin read_fem_bin proc~read_fem_bin->proc~elec_read_foptical_mat program~od2od od2od program~od2od->proc~read_fem_bin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_foptical_mat Source Code subroutine elec_read_foptical_mat !========================================================================= ! Read the .fem_bin file in paralell if appropriate. These are the ! free electron matrix at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: foptical_mat,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  V Chang                                             Nov 2020 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send , comms_reduce use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints , kpoint_r use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: gradient_unit , i , ib , jb , is , ik , inodes , ierr , gam_unit = 23 , inode = 0 , ktmp character ( filename_len ) :: gradient_filename real ( kind = dp ) :: time0 , time1 , file_version , tolerance = 0.000001_dp real ( kind = dp ), parameter :: file_ver = 1.0_dp complex ( kind = dp ), dimension (:,:,:), allocatable :: foptical_mat_temp logical :: have_gamma = . False . ! Check that we haven't already done this. if ( allocated ( foptical_mat )) return time0 = io_time () if ( on_root ) then gradient_unit = io_file_unit () gradient_filename = trim ( seedname ) // \".fem_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading foptical matrix elements from file: ' // trim ( gradient_filename ) open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( gradient_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of fem_bin file. Update optados!' ) read ( gradient_unit ) femfile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( femfile_header ) end if ! Figure out how many kpoints should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( foptical_mat ( 1 : nbands + 1 , 1 : nbands + 1 , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating foptical_mat in elec_read_optical_mat' ) if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins read ( gradient_unit ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ) & , jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do call comms_send ( foptical_mat ( 1 , 1 , 1 , 1 , 1 ), ( nbands + 1 ) * ( nbands + 1 ) * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins read ( gradient_unit ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do end if if (. not . on_root ) then call comms_recv ( foptical_mat ( 1 , 1 , 1 , 1 , 1 ), ( nbands + 1 ) * ( nbands + 1 ) * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = gradient_unit ) ! Convert all band gradients to eV Ang if ( legacy_file_format ) then foptical_mat = foptical_mat * bohr2ang * bohr2ang * H2eV else foptical_mat = foptical_mat * bohr2ang * H2eV end if if ( index ( devel_flag , 'write_gam_fome' ) . gt . 0 ) then do ik = 1 , num_kpoints_on_node ( my_node_id ) if ( kpoint_r ( 1 , ik ) . lt . tolerance . and . kpoint_r ( 2 , ik ) . lt . tolerance . and . kpoint_r ( 3 , ik ) . lt . tolerance ) then inode = my_node_id ktmp = ik have_gamma = . True . write ( stdout , * ) 'node' , my_node_id , 'k#' , ktmp end if end do call comms_reduce ( inode , 1 , 'SUM' ) if ( have_gamma . and . . not . on_root ) then ! allocate the tmp array allocate ( foptical_mat_temp ( 1 : nbands + 1 , 1 : 3 , 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating foptical_mat_temp in elec_read_foptical_mat' ) ! write to tmp array foptical_mat_temp = foptical_mat (:, nbands + 1 ,:, ktmp ,:) ! send the tmp array to root node call comms_send ( foptical_mat_temp ( 1 , 1 , 1 ),( nbands + 1 ) * 3 * nspins , root_id ) ! deallocate the tmp array deallocate ( foptical_mat_temp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating foptical_mat_temp in elec_read_foptical_mat' ) end if if ( on_root ) then if ( have_gamma ) then ! Write out the fomes open ( unit = gam_unit , action = 'write' , file = trim ( seedname ) // '_gamma_fomes.dat' ) write ( gam_unit , '(1x,a28)' ) '############################' write ( gam_unit , * ) '# Free electron OMEs for' , seedname write ( gam_unit , '(1x,a28)' ) '############################' do is = 1 , nspins write ( gam_unit , * ) 'Spin Channel' , is write ( gam_unit , * ) '# bands + free electron band' , nbands + 1 do ib = 1 , nbands + 1 write ( gam_unit , '(1x, I3, 6(1x,ES24.16E2))' ) ib , ( foptical_mat ( ib , nbands + 1 , i , ktmp , is ), i = 1 , 3 ) end do end do close ( unit = gam_unit ) else ! allocate the tmp array allocate ( foptical_mat_temp ( 1 : nbands + 1 , 1 : 3 , 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating foptical_mat_temp in elec_read_foptical_mat' ) ! receive the tmp array to root node call comms_recv ( foptical_mat_temp ( 1 , 1 , 1 ),( nbands + 1 ) * 3 * nspins , inode ) ! write out the tmp array open ( unit = gam_unit , action = 'write' , file = trim ( seedname ) // '_gamma_fomes.dat' ) write ( gam_unit , '(1x,a28)' ) '############################' write ( gam_unit , * ) '# Free electron OMEs for' , seedname write ( gam_unit , '(1x,a28)' ) '############################' do is = 1 , nspins write ( gam_unit , * ) 'Spin Channel' , is write ( gam_unit , * ) '# bands + free electron band' , nbands do ib = 1 , nbands + 1 write ( gam_unit , '(1x, I3, 3(1x,ES24.16E2))' ) ib , ( foptical_mat_temp ( ib , i , is ), i = 1 , 3 ) end do end do close ( unit = gam_unit ) ! deallocate the tmp array deallocate ( foptical_mat_temp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating foptical_mat_temp in elec_read_foptical_mat' ) end if end if end if time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to read Free electron Matrix Elements                   & &      ' , time1 - time0 , ' (sec) +' end if return 102 call io_error ( 'Error: Problem opening fem_bin file in read_band_foptical_mat' ) end subroutine elec_read_foptical_mat","tags":"","loc":"proc/elec_read_foptical_mat.html"},{"title":"elec_read_optical_mat – OptaDOS","text":"public  subroutine elec_read_optical_mat() Uses od_algorithms od_parameters od_comms od_cell od_constants od_io proc~~elec_read_optical_mat~~UsesGraph proc~elec_read_optical_mat elec_read_optical_mat module~od_algorithms od_algorithms proc~elec_read_optical_mat->module~od_algorithms module~od_parameters od_parameters proc~elec_read_optical_mat->module~od_parameters module~od_comms od_comms proc~elec_read_optical_mat->module~od_comms module~od_constants od_constants proc~elec_read_optical_mat->module~od_constants module~od_cell od_cell proc~elec_read_optical_mat->module~od_cell module~od_io od_io proc~elec_read_optical_mat->module~od_io module~od_algorithms->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_comms->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~elec_read_optical_mat~~CallsGraph proc~elec_read_optical_mat elec_read_optical_mat proc~io_time io_time proc~elec_read_optical_mat->proc~io_time proc~io_file_unit io_file_unit proc~elec_read_optical_mat->proc~io_file_unit proc~algor_dist_array algor_dist_array proc~elec_read_optical_mat->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_optical_mat->interface~comms_send proc~io_error io_error proc~elec_read_optical_mat->proc~io_error interface~comms_recv comms_recv proc~elec_read_optical_mat->interface~comms_recv proc~algor_dist_array->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~elec_read_optical_mat~~CalledByGraph proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~read_ome_bin read_ome_bin proc~read_ome_bin->proc~elec_read_optical_mat proc~optics_calculate optics_calculate proc~optics_calculate->proc~elec_read_optical_mat proc~jdos_utils_calculate jdos_utils_calculate proc~optics_calculate->proc~jdos_utils_calculate proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~dos_utils_set_efermi dos_utils_set_efermi proc~optics_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~dos_utils_set_efermi program~od2od od2od program~od2od->proc~read_ome_bin proc~read_dome_bin read_dome_bin program~od2od->proc~read_dome_bin proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_dome_bin->proc~elec_read_band_gradient program~optados optados program~optados->proc~optics_calculate proc~pdos_calculate pdos_calculate program~optados->proc~pdos_calculate proc~core_calculate core_calculate program~optados->proc~core_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_read_optical_mat Source Code subroutine elec_read_optical_mat !========================================================================= ! Read the .cst_ome file in paralell if appropriate. These are the ! gradients of the bands at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_gradient,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: gradient_unit , i , ib , jb , is , ik , inodes , ierr character ( filename_len ) :: gradient_filename real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp ! Check that we haven't already done this. if ( allocated ( optical_mat )) return time0 = io_time () if ( on_root ) then gradient_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then gradient_filename = trim ( seedname ) // \".cst_ome\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading optical matrix elements from file: ' // trim ( gradient_filename ) open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 101 ) else gradient_filename = trim ( seedname ) // \".ome_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading optical matrix elements from file: ' // trim ( gradient_filename ) open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( gradient_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of ome_bin file. Update optados!' ) read ( gradient_unit ) omefile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( omefile_header ) end if end if ! Figure out how many kpoints should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( optical_mat ( 1 : nbands , 1 : nbands , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating optical_mat in elec_read_optical_mat' ) if ( legacy_file_format ) then if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins do i = 1 , 3 do jb = 1 , nbands do ib = 1 , nbands ! Read in units of Ha Bohr&#94;2 / Ang read ( gradient_unit ) optical_mat ( ib , jb , i , ik , is ) end do end do end do end do end do call comms_send ( optical_mat ( 1 , 1 , 1 , 1 , 1 ), nbands * nbands * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins do i = 1 , 3 do jb = 1 , nbands do ib = 1 , nbands ! Read in units of Ha Bohr&#94;2 / Ang read ( gradient_unit ) optical_mat ( ib , jb , i , ik , is ) end do end do end do end do end do end if else ! sane file format if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins read ( gradient_unit ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ) & , jb = 1 , nbands ), i = 1 , 3 ) end do end do call comms_send ( optical_mat ( 1 , 1 , 1 , 1 , 1 ), nbands * nbands * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins read ( gradient_unit ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), jb = 1 , nbands ), i = 1 , 3 ) end do end do end if end if if (. not . on_root ) then call comms_recv ( optical_mat ( 1 , 1 , 1 , 1 , 1 ), nbands * nbands * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = gradient_unit ) ! Convert all band gradients to eV Ang if ( legacy_file_format ) then optical_mat = optical_mat * bohr2ang * bohr2ang * H2eV else optical_mat = optical_mat * bohr2ang * H2eV end if time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to read Optical Matrix Elements                   & &      ' , time1 - time0 , ' (sec) +' end if return 101 call io_error ( 'Error: Problem opening cst_ome file in read_band_optical_mat' ) 102 call io_error ( 'Error: Problem opening ome_bin file in read_band_optical_mat' ) end subroutine elec_read_optical_mat","tags":"","loc":"proc/elec_read_optical_mat.html"},{"title":"elec_report_parameters – OptaDOS","text":"public  subroutine elec_report_parameters() Uses od_cell od_parameters od_io proc~~elec_report_parameters~~UsesGraph proc~elec_report_parameters elec_report_parameters module~od_cell od_cell proc~elec_report_parameters->module~od_cell module~od_parameters od_parameters proc~elec_report_parameters->module~od_parameters module~od_io od_io proc~elec_report_parameters->module~od_io module~od_cell->module~od_io module~od_constants od_constants module~od_cell->module~od_constants module~od_parameters->module~od_cell module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Called by proc~~elec_report_parameters~~CalledByGraph proc~elec_report_parameters elec_report_parameters program~optados optados program~optados->proc~elec_report_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code elec_report_parameters Source Code subroutine elec_report_parameters !========================================================================= ! Report the electronic properties in the calculation !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables nbands,num_electrons,nkpoints,kpoint_grid_dim !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_io , only : stdout use od_cell , only : kpoint_grid_dim , nkpoints use od_parameters , only : pdis implicit none write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+----------------------- Electronic Data ------------------------------------+' write ( stdout , '(1x,a46,i14,a18)' ) '|  Number of Bands                           :' , nbands , \"|\" if (. not . pdis ) then write ( stdout , '(1x,a46,6x,i3,1x,a1,i3,1x,a1,i3,12x,a1)' ) '|  Grid size                                 :' & , kpoint_grid_dim ( 1 ), 'x' , kpoint_grid_dim ( 2 ), 'x' , kpoint_grid_dim ( 3 ), '|' end if write ( stdout , '(1x,a46,i14,a18)' ) '|  Number of K-points                        :' , nkpoints , \"|\" if ( nspins > 1 ) then write ( stdout , '(1x,a78)' ) '|  Spin-Polarised Calculation                :           True                |' write ( stdout , '(1x,a46,f17.2,a15)' ) \"|  Number of up-spin electrons               :\" , num_electrons ( 1 ), \"|\" write ( stdout , '(1x,a46,f17.2,a15)' ) \"|  Number of down-spin electrons             :\" , num_electrons ( 2 ), \"|\" else write ( stdout , '(1x,a78)' ) '|  Spin-Polarised Calculation                :           False               |' write ( stdout , '(1x,a46,f17.2,a15)' ) \"|  Number of electrons                       :\" , num_electrons ( 1 ), \"|\" end if write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end subroutine elec_report_parameters","tags":"","loc":"proc/elec_report_parameters.html"},{"title":"io_file_unit – OptaDOS","text":"public  function io_file_unit() Arguments None Return Value integer Called by proc~~io_file_unit~~CalledByGraph proc~io_file_unit io_file_unit proc~write_loss_fn write_loss_fn proc~write_loss_fn->proc~io_file_unit proc~write_conduct write_conduct proc~write_conduct->proc~io_file_unit proc~write_absorp write_absorp proc~write_absorp->proc~io_file_unit proc~write_elnes_bin write_elnes_bin proc~write_elnes_bin->proc~io_file_unit proc~write_pdos_fmt write_pdos_fmt proc~write_pdos_fmt->proc~io_file_unit proc~cell_get_symmetry cell_get_symmetry proc~cell_get_symmetry->proc~io_file_unit proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->proc~io_file_unit proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->proc~io_file_unit proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~io_file_unit proc~cell_get_real_lattice cell_get_real_lattice proc~cell_get_real_lattice->proc~io_file_unit proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->proc~io_file_unit proc~write_pdos_bin write_pdos_bin proc~write_pdos_bin->proc~io_file_unit proc~cell_read_cell cell_read_cell proc~cell_read_cell->proc~io_file_unit proc~cell_read_cell->proc~cell_get_real_lattice proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->proc~io_file_unit proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->proc~io_file_unit program~od2od od2od program~od2od->proc~io_file_unit program~od2od->proc~write_elnes_bin program~od2od->proc~write_pdos_fmt program~od2od->proc~read_pdos_fmt program~od2od->proc~write_pdos_bin proc~write_elnes_fmt write_elnes_fmt program~od2od->proc~write_elnes_fmt proc~read_elnes_fmt read_elnes_fmt program~od2od->proc~read_elnes_fmt proc~read_dome_bin read_dome_bin program~od2od->proc~read_dome_bin proc~read_elnes_bin read_elnes_bin program~od2od->proc~read_elnes_bin proc~read_fem_bin read_fem_bin program~od2od->proc~read_fem_bin proc~get_band_energy get_band_energy program~od2od->proc~get_band_energy proc~read_pdos_bin read_pdos_bin program~od2od->proc~read_pdos_bin proc~read_ome_bin read_ome_bin program~od2od->proc~read_ome_bin program~optados optados program~optados->proc~io_file_unit program~optados->proc~elec_read_band_energy proc~elec_read_band_energy_ordered elec_read_band_energy_ordered program~optados->proc~elec_read_band_energy_ordered proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~param_read param_read program~optados->proc~param_read proc~pdis_calculate pdis_calculate program~optados->proc~pdis_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~cell_calc_lattice cell_calc_lattice program~optados->proc~cell_calc_lattice proc~core_calculate core_calculate program~optados->proc~core_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~pdos_calculate pdos_calculate program~optados->proc~pdos_calculate proc~write_elnes_fmt->proc~io_file_unit proc~elec_read_band_energy_ordered->proc~io_file_unit proc~write_dos write_dos proc~write_dos->proc~io_file_unit proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos->proc~write_dos_xmgrace proc~write_refract write_refract proc~write_refract->proc~io_file_unit proc~write_dos_xmgrace->proc~io_file_unit proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->proc~io_file_unit proc~cell_get_atoms->proc~cell_get_real_lattice proc~write_epsilon write_epsilon proc~write_epsilon->proc~io_file_unit proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->proc~io_file_unit proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->proc~io_file_unit proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->proc~io_file_unit proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~write_reflect write_reflect proc~write_reflect->proc~io_file_unit proc~read_elnes_fmt->proc~io_file_unit proc~write_jdos write_jdos proc~write_jdos->proc~io_file_unit proc~write_jdos->proc~write_jdos_xmgrace proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_set_efermi dos_utils_set_efermi proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~read_dome_bin->proc~elec_read_band_gradient proc~jdos_calculate->proc~write_jdos proc~jdos_calculate->proc~jdos_utils_calculate proc~make_weights make_weights proc~make_weights->proc~cell_get_symmetry proc~read_elnes_bin->proc~elec_read_elnes_mat proc~param_read->proc~cell_read_cell proc~read_fem_bin->proc~elec_read_foptical_mat proc~get_band_energy->proc~elec_read_band_energy proc~pdis_calculate->proc~elec_pdis_read proc~read_pdos_bin->proc~elec_pdos_read proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~elec_read_band_gradient proc~optics_calculate->proc~write_loss_fn proc~optics_calculate->proc~write_conduct proc~optics_calculate->proc~write_absorp proc~optics_calculate->proc~elec_read_optical_mat proc~optics_calculate->proc~write_refract proc~optics_calculate->proc~write_epsilon proc~optics_calculate->proc~write_reflect proc~optics_calculate->proc~jdos_utils_calculate proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~make_weights proc~optics_calculate->proc~dos_utils_set_efermi proc~read_ome_bin->proc~elec_read_optical_mat proc~cell_calc_lattice->proc~cell_get_real_lattice proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->proc~cell_get_real_lattice proc~cell_calc_kpoint_r_cart->proc~cell_calc_lattice proc~core_calculate->proc~elec_read_elnes_mat proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~dos_calculate->proc~write_dos proc~dos_calculate->proc~dos_utils_calculate proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_set_efermi proc~pdos_calculate->proc~elec_pdos_read proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~dos_utils_set_efermi->proc~dos_utils_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code io_file_unit Source Code function io_file_unit () !==================================================================! !                                                                  ! ! Returns an unused unit number                                    ! ! (so we can open a file on that unit                              ! !                                                                  ! !=================================================================== implicit none integer :: io_file_unit , unit logical :: file_open unit = 9 file_open = . true . do while ( file_open ) unit = unit + 1 inquire ( unit , OPENED = file_open ) end do io_file_unit = unit return end function io_file_unit","tags":"","loc":"proc/io_file_unit.html"},{"title":"io_time – OptaDOS","text":"public  function io_time() Uses od_constants proc~~io_time~~UsesGraph proc~io_time io_time module~od_constants od_constants proc~io_time->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Return Value real(kind=dp) Called by proc~~io_time~~CalledByGraph proc~io_time io_time proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->proc~io_time proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->proc~io_time proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->proc~io_time proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->proc~io_time proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->proc~io_time proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->proc~io_time proc~dos_calculate dos_calculate proc~dos_calculate->proc~io_time proc~dos_calculate->proc~dos_utils_compute_bandgap proc~dos_calculate->proc~dos_utils_compute_band_energies proc~dos_utils_calculate dos_utils_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_calculate->proc~dos_utils_set_efermi program~od2od od2od program~od2od->proc~io_time proc~get_band_energy get_band_energy program~od2od->proc~get_band_energy proc~read_ome_bin read_ome_bin program~od2od->proc~read_ome_bin proc~read_dome_bin read_dome_bin program~od2od->proc~read_dome_bin proc~read_fem_bin read_fem_bin program~od2od->proc~read_fem_bin proc~read_elnes_bin read_elnes_bin program~od2od->proc~read_elnes_bin proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->proc~io_time program~optados optados program~optados->proc~io_time program~optados->proc~elec_read_band_energy program~optados->proc~dos_calculate program~optados->proc~elec_read_band_energy_ordered proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~pdos_calculate pdos_calculate program~optados->proc~pdos_calculate proc~core_calculate core_calculate program~optados->proc~core_calculate proc~elec_read_band_gradient->proc~io_time proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_read_optical_mat->proc~io_time proc~jdos_calculate->proc~io_time proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~jdos_utils_calculate->proc~io_time proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~dos_utils_calculate->proc~io_time proc~dos_utils_calculate->proc~elec_read_band_gradient proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->proc~io_time proc~dos_utils_compute_dos_at_efermi->proc~io_time proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~elec_read_optical_mat proc~optics_calculate->proc~jdos_utils_calculate proc~optics_calculate->proc~dos_utils_set_efermi proc~get_band_energy->proc~elec_read_band_energy proc~read_ome_bin->proc~elec_read_optical_mat proc~read_dome_bin->proc~elec_read_band_gradient proc~read_fem_bin->proc~elec_read_foptical_mat proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~elec_read_elnes_mat proc~core_calculate->proc~dos_utils_set_efermi proc~read_elnes_bin->proc~elec_read_elnes_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code io_time Source Code function io_time () !==================================================================! !                                                                  ! ! Returns elapsed CPU time in seconds since its first call         ! ! uses standard f90 call                                           ! !                                                                  ! !=================================================================== use od_constants , only : dp implicit none real ( kind = dp ) :: io_time ! t0 contains the time of the first call ! t1 contains the present time real ( kind = dp ) :: t0 , t1 logical :: first = . true . save first , t0 ! call cpu_time ( t1 ) ! if ( first ) then t0 = t1 io_time = 0.0_dp first = . false . else io_time = t1 - t0 end if return end function io_time","tags":"","loc":"proc/io_time.html"},{"title":"io_date – OptaDOS","text":"public  subroutine io_date(cdate, ctime) Arguments Type Intent Optional Attributes Name character(len=11), intent(out) :: cdate character(len=9), intent(out) :: ctime Called by proc~~io_date~~CalledByGraph proc~io_date io_date proc~write_jdos write_jdos proc~write_jdos->proc~io_date proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos->proc~write_jdos_xmgrace proc~xmgu_setup xmgu_setup proc~xmgu_setup->proc~io_date program~od2od od2od program~od2od->proc~io_date program~optados optados program~optados->proc~io_date proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~write_dos write_dos proc~write_dos->proc~io_date proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos->proc~write_dos_xmgrace proc~jdos_calculate->proc~write_jdos proc~write_jdos_xmgrace->proc~xmgu_setup proc~dos_calculate->proc~write_dos proc~write_dos_xmgrace->proc~xmgu_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code io_date Source Code subroutine io_date ( cdate , ctime ) !==================================================================! !                                                                  ! !     Returns two strings containing the date and the time         ! !     in human-readable format. Uses a standard f90 call.          ! !                                                                  ! !=================================================================== implicit none character ( len = 11 ), intent ( out ) :: cdate character ( len = 9 ), intent ( out ) :: ctime character ( len = 3 ), dimension ( 12 ) :: months data months / 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , & 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' / integer date_time ( 8 ) ! call date_and_time ( values = date_time ) ! write ( cdate , '(i2,1x,a3,1x,i4)' ) date_time ( 3 ), months ( date_time ( 2 )), date_time ( 1 ) write ( ctime , '(i2.2,\":\",i2.2,\":\",i2.2)' ) date_time ( 5 ), date_time ( 6 ), date_time ( 7 ) end subroutine io_date","tags":"","loc":"proc/io_date.html"},{"title":"io_error – OptaDOS","text":"public  subroutine io_error(error_msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_msg Called by proc~~io_error~~CalledByGraph proc~io_error io_error proc~projection_get_string projection_get_string proc~projection_get_string->proc~io_error proc~dos_utils_deallocate dos_utils_deallocate proc~dos_utils_deallocate->proc~io_error proc~conv_get_seedname conv_get_seedname proc~conv_get_seedname->proc~io_error proc~cell_find_mp_grid cell_find_MP_grid proc~cell_find_mp_grid->proc~io_error proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->proc~io_error proc~algor_dist_array algor_dist_array proc~elec_read_optical_mat->proc~algor_dist_array proc~cell_get_symmetry cell_get_symmetry proc~cell_get_symmetry->proc~io_error proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->proc~io_error proc~param_dist param_dist proc~param_dist->proc~io_error proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->proc~io_error proc~calculate_jdos calculate_jdos proc~jdos_utils_calculate->proc~calculate_jdos proc~dos_utils_set_efermi dos_utils_set_efermi proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~elec_read_band_gradient elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~setup_energy_scale setup_energy_scale proc~jdos_utils_calculate->proc~setup_energy_scale proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->proc~io_error proc~allocate_jdos allocate_jdos proc~allocate_jdos->proc~io_error proc~param_read param_read proc~param_read->proc~io_error proc~cell_read_cell cell_read_cell proc~param_read->proc~cell_read_cell proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->proc~io_error proc~xmgu_data xmgu_data proc~write_jdos_xmgrace->proc~xmgu_data proc~projection_merge projection_merge proc~projection_merge->proc~io_error proc~xmgu_data->proc~io_error proc~projection_analyse_orbitals projection_analyse_orbitals proc~projection_analyse_orbitals->proc~io_error proc~calculate_jdos->proc~io_error proc~calculate_jdos->proc~allocate_jdos proc~elec_dealloc_optical elec_dealloc_optical proc~elec_dealloc_optical->proc~io_error proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->proc~io_error proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~cell_read_cell->proc~io_error proc~make_weights make_weights proc~make_weights->proc~io_error proc~make_weights->proc~cell_get_symmetry proc~algor_dist_array->proc~io_error program~od2od od2od program~od2od->proc~io_error program~od2od->proc~conv_get_seedname program~od2od->proc~read_pdos_fmt proc~read_elnes_fmt read_elnes_fmt program~od2od->proc~read_elnes_fmt proc~write_elnes_bin write_elnes_bin program~od2od->proc~write_elnes_bin proc~read_pdos_bin read_pdos_bin program~od2od->proc~read_pdos_bin proc~write_elnes_fmt write_elnes_fmt program~od2od->proc~write_elnes_fmt proc~read_dome_bin read_dome_bin program~od2od->proc~read_dome_bin proc~read_elnes_bin read_elnes_bin program~od2od->proc~read_elnes_bin proc~read_ome_bin read_ome_bin program~od2od->proc~read_ome_bin proc~read_fem_bin read_fem_bin program~od2od->proc~read_fem_bin proc~get_band_energy get_band_energy program~od2od->proc~get_band_energy proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->proc~io_error proc~elec_read_band_energy_ordered->proc~cell_find_mp_grid proc~elec_read_band_energy_ordered->proc~algor_dist_array proc~elec_dealloc_band_gradient elec_dealloc_band_gradient proc~elec_dealloc_band_gradient->proc~io_error proc~cell_dist cell_dist proc~cell_dist->proc~io_error proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->proc~io_error proc~elec_read_foptical_mat->proc~algor_dist_array proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->proc~io_error proc~write_dos_xmgrace->proc~xmgu_data proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_elnes_find_channel_names->proc~io_error proc~write_dos write_dos proc~write_dos->proc~io_error proc~write_dos->proc~write_dos_xmgrace proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->proc~io_error proc~elec_read_band_energy->proc~cell_find_mp_grid proc~elec_read_band_energy->proc~algor_dist_array proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->proc~io_error proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~elec_elnes_find_channel_numbers->proc~io_error proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->proc~io_error proc~elec_dealloc_pdos elec_dealloc_pdos proc~elec_dealloc_pdos->proc~io_error proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->proc~io_error proc~elec_read_band_curvature->proc~algor_dist_array proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->proc~io_error proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->proc~io_error proc~dos_utils_calculate->proc~elec_read_band_gradient proc~jdos_deallocate jdos_deallocate proc~jdos_deallocate->proc~io_error proc~elec_dealloc_elnes elec_dealloc_elnes proc~elec_dealloc_elnes->proc~io_error proc~dos_utils_set_efermi->proc~io_error proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->proc~io_error proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->proc~io_error proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~read_elnes_fmt->proc~io_error proc~read_elnes_fmt->proc~elec_elnes_find_channel_names proc~write_jdos write_jdos proc~write_jdos->proc~io_error proc~write_jdos->proc~write_jdos_xmgrace proc~setup_energy_scale->proc~io_error proc~write_elnes_bin->proc~elec_elnes_find_channel_numbers proc~read_pdos_bin->proc~elec_pdos_read proc~write_elnes_fmt->proc~elec_elnes_find_channel_numbers proc~core_calculate core_calculate proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~core_calculate->proc~elec_read_elnes_mat proc~read_dome_bin->proc~elec_read_band_gradient proc~read_elnes_bin->proc~elec_read_elnes_mat proc~pdos_calculate pdos_calculate proc~pdos_calculate->proc~projection_get_string proc~pdos_calculate->proc~projection_merge proc~pdos_calculate->proc~projection_analyse_orbitals proc~pdos_calculate->proc~elec_pdos_read proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~read_ome_bin->proc~elec_read_optical_mat program~optados optados program~optados->proc~param_dist program~optados->proc~param_read program~optados->proc~elec_read_band_energy_ordered program~optados->proc~cell_dist program~optados->proc~elec_read_band_energy program~optados->proc~core_calculate program~optados->proc~pdos_calculate proc~pdis_calculate pdis_calculate program~optados->proc~pdis_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~pdis_calculate->proc~projection_get_string proc~pdis_calculate->proc~projection_merge proc~pdis_calculate->proc~projection_analyse_orbitals proc~pdis_calculate->proc~elec_pdis_read proc~optics_calculate->proc~elec_read_optical_mat proc~optics_calculate->proc~jdos_utils_calculate proc~optics_calculate->proc~elec_dealloc_optical proc~optics_calculate->proc~dos_utils_calculate_at_e proc~optics_calculate->proc~make_weights proc~optics_calculate->proc~dos_utils_set_efermi proc~jdos_calculate->proc~jdos_utils_calculate proc~jdos_calculate->proc~write_jdos proc~dos_calculate->proc~dos_utils_compute_bandgap proc~dos_calculate->proc~write_dos proc~dos_calculate->proc~dos_utils_calculate proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~read_fem_bin->proc~elec_read_foptical_mat proc~get_band_energy->proc~elec_read_band_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code io_error Source Code subroutine io_error ( error_msg ) !==================================================================! !                                                                  ! ! Aborts giving error message                                      ! !                                                                  ! !=================================================================== implicit none character ( len =* ), intent ( in ) :: error_msg write ( stderr , * ) 'Exiting.......' write ( stderr , '(1x,a)' ) trim ( error_msg ) close ( stderr ) error stop \"Optados error: examine the output/error file for details\" end subroutine io_error","tags":"","loc":"proc/io_error.html"},{"title":"io_get_seedname – OptaDOS","text":"public  subroutine io_get_seedname() Arguments None Called by proc~~io_get_seedname~~CalledByGraph proc~io_get_seedname io_get_seedname program~optados optados program~optados->proc~io_get_seedname Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code io_get_seedname Source Code subroutine io_get_seedname () !==================================================================! !                                                                  ! ! Get the seedname from the commandline                            ! ! Note iargc and getarg are not standard                           ! ! Some platforms require them to be external or provide            ! ! equivalent routines. Not a problem in f2003!                     ! !=================================================================== implicit none integer :: num_arg num_arg = command_argument_count () if ( num_arg == 0 ) then seedname = '--help' elseif ( num_arg == 1 ) then call get_command_argument ( 1 , seedname ) ! Added by F. Mildner to allow for multi_output runs elseif ( num_arg == 3 ) then call get_command_argument ( 1 , options ) call get_command_argument ( 2 , temp_dir ) call get_command_argument ( 3 , seedname ) else call get_command_argument ( 1 , seedname ) !do something else end if ! If on the command line the whole seedname.odi was passed, I strip the last \".win\" if ( len ( trim ( seedname )) . ge . 5 ) then if ( seedname ( len ( trim ( seedname )) - 4 + 1 :) . eq . \".odi\" ) then seedname = seedname (: len ( trim ( seedname )) - 4 ) end if end if end subroutine io_get_seedname","tags":"","loc":"proc/io_get_seedname.html"},{"title":"pdis_calculate – OptaDOS","text":"public  subroutine pdis_calculate() Uses od_parameters od_comms od_electronic od_projection_utils od_io proc~~pdis_calculate~~UsesGraph proc~pdis_calculate pdis_calculate module~od_parameters od_parameters proc~pdis_calculate->module~od_parameters module~od_comms od_comms proc~pdis_calculate->module~od_comms module~od_io od_io proc~pdis_calculate->module~od_io module~od_projection_utils od_projection_utils proc~pdis_calculate->module~od_projection_utils module~od_electronic od_electronic proc~pdis_calculate->module~od_electronic module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_comms->module~od_constants module~od_io->module~od_constants module~od_projection_utils->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments None Calls proc~~pdis_calculate~~CallsGraph proc~pdis_calculate pdis_calculate proc~elec_pdis_read elec_pdis_read proc~pdis_calculate->proc~elec_pdis_read proc~projection_get_string projection_get_string proc~pdis_calculate->proc~projection_get_string proc~projection_analyse_orbitals projection_analyse_orbitals proc~pdis_calculate->proc~projection_analyse_orbitals proc~projection_merge projection_merge proc~pdis_calculate->proc~projection_merge proc~io_file_unit io_file_unit proc~elec_pdis_read->proc~io_file_unit interface~comms_bcast comms_bcast proc~elec_pdis_read->interface~comms_bcast proc~io_error io_error proc~elec_pdis_read->proc~io_error proc~projection_get_string->proc~io_error proc~projection_analyse_orbitals->proc~io_error proc~projection_merge->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pdis_calculate~~CalledByGraph proc~pdis_calculate pdis_calculate program~optados optados program~optados->proc~pdis_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pdis_calculate Source Code subroutine pdis_calculate use od_electronic , only : elec_pdis_read , efermi_castep , efermi use od_projection_utils , only : projection_merge , projection_get_string , projection_analyse_orbitals use od_comms , only : on_root use od_parameters , only : set_efermi_zero , iprint use od_io , only : stdout implicit none if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                 Projected Dispersion Curve Calculation                     +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) end if ! read in the pdos weights call elec_pdis_read ! look at the orbitals and figure out which atoms / states we have call projection_analyse_orbitals ! parse the pdis string to see what we want call projection_get_string ! form the right matrix elements call projection_merge ! set efermi if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Set fermi energy from file : \" , efermi_castep , \" eV\" , \"  <- EfC\" efermi = efermi_castep ! write everything out if ( on_root . and . ( iprint > 2 )) then call pdis_report_projectors end if if ( on_root ) then call pdis_write end if end subroutine pdis_calculate","tags":"","loc":"proc/pdis_calculate.html"},{"title":"dos_calculate – OptaDOS","text":"public  subroutine dos_calculate() Uses od_parameters od_dos_utils od_comms od_electronic od_io proc~~dos_calculate~~UsesGraph proc~dos_calculate dos_calculate module~od_parameters od_parameters proc~dos_calculate->module~od_parameters module~od_dos_utils od_dos_utils proc~dos_calculate->module~od_dos_utils module~od_io od_io proc~dos_calculate->module~od_io module~od_comms od_comms proc~dos_calculate->module~od_comms module~od_electronic od_electronic proc~dos_calculate->module~od_electronic module~od_parameters->module~od_io module~od_cell od_cell module~od_parameters->module~od_cell module~od_constants od_constants module~od_parameters->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_io->module~od_constants module~od_comms->module~od_constants module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. $\n$    unshifted_efermi=efermi\n$\n$    if(set_efermi_zero) then\n$       if(on_root) then\n$          write(stdout,*)\n$          write(stdout,'(1x,a71)')  '+----------------------- Shift Fermi Energy --------------------------+'\n$          write(stdout,'(1x,a1,a46,a24)')\"|\", \" Setting Fermi energy to 0 : \",\"|\"\n$       endif\n$       E(:)=E(:)-efermi\n$       band_energy(:,:,:) = band_energy(:,:,:) - efermi\n$       efermi=0.0_dp\n$    endif\n$\n$    if(on_root) then\n$       write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)')\"|\", \" Fermi energy used : \", unshifted_efermi,\"eV\",\"| <- Ef \"\n$       write(stdout,'(1x,a71)')  '+---------------------------------------------------------------------+'\n$\n$       time1=io_time()\n$       write(stdout,'(1x,a40,f11.3,a)') 'Time to perfom analysis ',time1-time0,' (sec)'\n$       !-------------------------------------------------------------------------------\n$    end if Arguments None Calls proc~~dos_calculate~~CallsGraph proc~dos_calculate dos_calculate proc~dos_utils_calculate dos_utils_calculate proc~dos_calculate->proc~dos_utils_calculate proc~io_time io_time proc~dos_calculate->proc~io_time proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_calculate->proc~dos_utils_compute_bandgap proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_calculate->proc~dos_utils_compute_band_energies proc~write_dos write_dos proc~dos_calculate->proc~write_dos proc~dos_utils_calculate->proc~io_time proc~io_error io_error proc~dos_utils_calculate->proc~io_error proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge interface~comms_bcast comms_bcast proc~dos_utils_calculate->interface~comms_bcast proc~elec_read_band_gradient elec_read_band_gradient proc~dos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_set_efermi->proc~dos_utils_calculate proc~dos_utils_set_efermi->proc~io_error proc~dos_utils_set_efermi->interface~comms_bcast interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_compute_bandgap->proc~io_time proc~dos_utils_compute_bandgap->proc~io_error interface~comms_recv comms_recv proc~dos_utils_compute_bandgap->interface~comms_recv interface~comms_send comms_send proc~dos_utils_compute_bandgap->interface~comms_send proc~dos_utils_compute_dos_at_efermi->proc~io_time proc~dos_utils_compute_dos_at_efermi->interface~comms_bcast proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~dos_utils_compute_band_energies->proc~io_time proc~dos_utils_compute_band_energies->interface~comms_reduce proc~write_dos->proc~io_error proc~io_date io_date proc~write_dos->proc~io_date proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos->proc~write_dos_xmgrace proc~io_file_unit io_file_unit proc~write_dos->proc~io_file_unit proc~dos_utils_merge->interface~comms_reduce proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->interface~comms_recv proc~elec_read_band_gradient->interface~comms_send proc~elec_read_band_gradient->proc~io_file_unit proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~dos_utils_calculate_at_e->proc~io_time proc~dos_utils_calculate_at_e->proc~io_error proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~write_dos_xmgrace->proc~io_error proc~write_dos_xmgrace->proc~io_file_unit proc~xmgu_setup xmgu_setup proc~write_dos_xmgrace->proc~xmgu_setup proc~xmgu_legend xmgu_legend proc~write_dos_xmgrace->proc~xmgu_legend proc~xmgu_title xmgu_title proc~write_dos_xmgrace->proc~xmgu_title proc~xmgu_subtitle xmgu_subtitle proc~write_dos_xmgrace->proc~xmgu_subtitle proc~xmgu_axis xmgu_axis proc~write_dos_xmgrace->proc~xmgu_axis proc~xmgu_vertical_line xmgu_vertical_line proc~write_dos_xmgrace->proc~xmgu_vertical_line proc~xmgu_data_header xmgu_data_header proc~write_dos_xmgrace->proc~xmgu_data_header proc~xmgu_data xmgu_data proc~write_dos_xmgrace->proc~xmgu_data proc~algor_dist_array->proc~io_error proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->proc~algor_dist_array proc~xmgu_setup->proc~io_date proc~elec_dealloc_optical->proc~io_error proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dos_calculate~~CalledByGraph proc~dos_calculate dos_calculate program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dos_calculate Source Code subroutine dos_calculate !=============================================================================== ! Main routine in dos module, drives the calculation of density of states for ! both task : dos and also if it is required elsewhere. !------------------------------------------------------------------------------- ! Arguments: matrix_weigths (in) (opt) : LCAO or other weightings for DOS !            weighted_dos   (out)(opt) : Output DOS weigthed by matrix_weights !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw, E, dos_adaptive, dos_fixed, dos_linear ! intdos_adaptive, intdos_fixed, intdos_linear, efermi_fixed, efermi_adaptive ! efermi_linear, delta_bins, calc_weighted_dos !------------------------------------------------------------------------------- ! Modules Used: see below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: One of linear, adaptive or fixed must be .true. !------------------------------------------------------------------------------- ! Known Worries: (1) If more than one of linear, adaptive or fixed are set it ! uses the most complicated method. ! (2) It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_io , only : stdout , io_time use od_dos_utils , only : E , dos_fixed , intdos_fixed , dos_adaptive , & & intdos_adaptive , dos_linear , intdos_linear , dos_utils_calculate ,& & dos_utils_compute_dos_at_efermi , dos_utils_compute_bandgap ,& & dos_utils_compute_band_energies , dos_utils_set_efermi use od_parameters , only : fixed , adaptive , linear , compute_band_gap ,& & compute_band_energy , set_efermi_zero , iprint use od_comms , only : on_root use od_electronic , only : nspins , efermi , band_energy , efermi_set real ( dp ) :: time0 , time1 , unshifted_efermi if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                              Density of States                             +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) end if call dos_utils_calculate ! Will return if this has already been done. if (. not . efermi_set ) call dos_utils_set_efermi time0 = io_time () !------------------------------------------------------------------------------- ! D O S   A T   F E R M I  L E V E L   A N A L Y S I S call dos_utils_compute_dos_at_efermi !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! B A N D  G A P  A N A L Y S I S ! The compute_dos_at_efermi routine may have set compute_band_gap to true if ( compute_band_gap ) call dos_utils_compute_bandgap !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! B A N D   E N E R G Y   A N A L Y S I S ! Now for a bit of crosschecking  band energies ! These should all converge to the same number as the number of bins is increased if ( compute_band_energy ) call dos_utils_compute_band_energies !------------------------------------------------------------------------------- !!$ !!$    unshifted_efermi=efermi !!$ !!$    if(set_efermi_zero) then !!$       if(on_root) then !!$          write(stdout,*) !!$          write(stdout,'(1x,a71)')  '+----------------------- Shift Fermi Energy --------------------------+' !!$          write(stdout,'(1x,a1,a46,a24)')\"|\", \" Setting Fermi energy to 0 : \",\"|\" !!$       endif !!$       E(:)=E(:)-efermi !!$       band_energy(:,:,:) = band_energy(:,:,:) - efermi !!$       efermi=0.0_dp !!$    endif !!$ !!$    if(on_root) then !!$       write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)')\"|\", \" Fermi energy used : \", unshifted_efermi,\"eV\",\"| <- Ef \" !!$       write(stdout,'(1x,a71)')  '+---------------------------------------------------------------------+' !!$ !!$       time1=io_time() !!$       write(stdout,'(1x,a40,f11.3,a)') 'Time to perfom analysis ',time1-time0,' (sec)' !!$       !------------------------------------------------------------------------------- !!$    end if ! W R I T E   O U T   D O S time0 = io_time () ! Otherwise we have written to wdos and dos, so they can be called ! by whatever. if ( on_root ) then if ( fixed ) call write_dos ( E , dos_fixed , intdos_fixed , \"fixed\" ) if ( adaptive ) call write_dos ( E , dos_adaptive , intdos_adaptive , \"adaptive\" ) if ( linear ) call write_dos ( E , dos_linear , intdos_linear , \"linear\" ) !if(quad)    call write_dos(E, dos_quad, intdos_quad, \"quad\") end if time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to write DOS to disk                              & &      ' , time1 - time0 , ' (sec) +' end if !------------------------------------------------------------------------------- end subroutine dos_calculate","tags":"","loc":"proc/dos_calculate.html"},{"title":"write_dos – OptaDOS","text":"public  subroutine write_dos(E, dos, intdos, dos_name) Uses od_electronic od_io od_parameters od_dos_utils proc~~write_dos~~UsesGraph proc~write_dos write_dos module~od_electronic od_electronic proc~write_dos->module~od_electronic module~od_parameters od_parameters proc~write_dos->module~od_parameters module~od_io od_io proc~write_dos->module~od_io module~od_dos_utils od_dos_utils proc~write_dos->module~od_dos_utils module~od_constants od_constants module~od_electronic->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_io->module~od_constants module~od_dos_utils->module~od_electronic module~od_dos_utils->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: E (dos_nbins) real(kind=dp), intent(in) :: dos (dos_nbins,nspins) real(kind=dp), intent(in) :: intdos (dos_nbins,nspins) character(len=*), intent(in) :: dos_name Calls proc~~write_dos~~CallsGraph proc~write_dos write_dos proc~io_error io_error proc~write_dos->proc~io_error proc~io_date io_date proc~write_dos->proc~io_date proc~io_file_unit io_file_unit proc~write_dos->proc~io_file_unit proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos->proc~write_dos_xmgrace proc~write_dos_xmgrace->proc~io_error proc~write_dos_xmgrace->proc~io_file_unit proc~xmgu_legend xmgu_legend proc~write_dos_xmgrace->proc~xmgu_legend proc~xmgu_subtitle xmgu_subtitle proc~write_dos_xmgrace->proc~xmgu_subtitle proc~xmgu_title xmgu_title proc~write_dos_xmgrace->proc~xmgu_title proc~xmgu_axis xmgu_axis proc~write_dos_xmgrace->proc~xmgu_axis proc~xmgu_setup xmgu_setup proc~write_dos_xmgrace->proc~xmgu_setup proc~xmgu_vertical_line xmgu_vertical_line proc~write_dos_xmgrace->proc~xmgu_vertical_line proc~xmgu_data_header xmgu_data_header proc~write_dos_xmgrace->proc~xmgu_data_header proc~xmgu_data xmgu_data proc~write_dos_xmgrace->proc~xmgu_data proc~xmgu_setup->proc~io_date proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_dos~~CalledByGraph proc~write_dos write_dos proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_dos Source Code subroutine write_dos ( E , dos , intdos , dos_name ) !=============================================================================== ! This routine receives an energy scale, a density of states and a file name ! and writes out the DOS to disk !------------------------------------------------------------------------------- ! Arguments: E       (in) : The energy scale !            dos     (in) : The density of states !            intdos  (in) : The integrated DOS !            dos_name(in) : Name of the output file !------------------------------------------------------------------------------- ! Parent Module Varables Used: None !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_electronic , only : nspins , efermi , efermi_set use od_parameters , only : dos_nbins , dos_per_volume , output_format , set_efermi_zero use od_io , only : seedname , io_file_unit , io_date , io_error , stdout use od_dos_utils , only : dos_utils_set_efermi implicit none real ( dp ), intent ( in ) :: E ( dos_nbins ) real ( dp ), intent ( in ) :: dos ( dos_nbins , nspins ) real ( dp ), intent ( in ) :: intdos ( dos_nbins , nspins ) character ( len =* ), intent ( in ) :: dos_name integer :: i , dos_file , ierr character ( len = 11 ) :: cdate character ( len = 9 ) :: ctime character ( len = 22 ) :: dos_units , intdos_units real ( kind = dp ), allocatable :: E_shift (:) allocate ( E_shift ( dos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating E_shift in write_dos' ) if ( set_efermi_zero ) then E_shift = E - efermi else E_shift = E end if dos_file = io_file_unit () open ( unit = dos_file , file = trim ( seedname ) // '.' // trim ( dos_name ) // '.dat' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open output file in dos: write_dos\" ) dos_units = \"(electrons per eV)\" ; intdos_units = \"(electrons)\" if ( dos_per_volume ) then dos_units = \"(electrons per eV/A&#94;3)\" intdos_units = \"(electrons per A&#94;3)\" end if write ( dos_file , * ) \"##############################################################################\" write ( dos_file , * ) \"#\" write ( dos_file , * ) \"#                  O p t a D O S   o u t p u t   f i l e \" write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , * ) \"#    Density of States using \" , trim ( dos_name ), \" broadening\" call io_date ( cdate , ctime ) write ( dos_file , * ) '#  Generated on ' , cdate , ' at ' , ctime write ( dos_file , * ) \"# Column        Data\" write ( dos_file , * ) \"#    1        Energy (eV)\" if ( nspins > 1 ) then write ( dos_file , * ) \"#    2        Up-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Down-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    4        Up-spin Integrated DOS \" , trim ( intdos_units ) write ( dos_file , * ) \"#    5        Down-spin Integrated DOS \" , trim ( intdos_units ) else write ( dos_file , * ) \"#    2        DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Integrated DOS \" , trim ( intdos_units ) end if write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , '(1x,a78)' ) \"##############################################################################\" if ( nspins > 1 ) then do i = 1 , dos_nbins write ( dos_file , '(5(E21.13,2x))' ) E_shift ( i ), dos ( i , 1 ), - dos ( i , 2 ), intdos ( i , 1 ), - intdos ( i , 2 ) end do else do i = 1 , dos_nbins write ( dos_file , '(3(E21.13,2x))' ) E_shift ( i ), dos ( i , 1 ), intdos ( i , 1 ) end do end if close ( dos_file ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_dos_xmgrace ( dos_name , E_shift , dos ) elseif ( trim ( output_format ) == \"gnuplot\" ) then write ( stdout , * ) \" WARNING: GNUPLOT output not yet available, calling xmgrace\" call write_dos_xmgrace ( dos_name , E_shift , dos ) !     call write_dos_gnuplot(dos_name,E,dos) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if deallocate ( E_shift , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating E_shift in write_dos' ) end subroutine write_dos","tags":"","loc":"proc/write_dos.html"},{"title":"write_dos_xmgrace – OptaDOS","text":"public  subroutine write_dos_xmgrace(dos_name, E, dos) Uses od_io od_electronic od_parameters xmgrace_utils proc~~write_dos_xmgrace~~UsesGraph proc~write_dos_xmgrace write_dos_xmgrace module~od_io od_io proc~write_dos_xmgrace->module~od_io module~od_parameters od_parameters proc~write_dos_xmgrace->module~od_parameters module~xmgrace_utils xmgrace_utils proc~write_dos_xmgrace->module~xmgrace_utils module~od_electronic od_electronic proc~write_dos_xmgrace->module~od_electronic module~od_constants od_constants module~od_io->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dos_name real(kind=dp), intent(in) :: E (dos_nbins) real(kind=dp), intent(in) :: dos (dos_nbins,nspins) Calls proc~~write_dos_xmgrace~~CallsGraph proc~write_dos_xmgrace write_dos_xmgrace proc~io_file_unit io_file_unit proc~write_dos_xmgrace->proc~io_file_unit proc~xmgu_legend xmgu_legend proc~write_dos_xmgrace->proc~xmgu_legend proc~io_error io_error proc~write_dos_xmgrace->proc~io_error proc~xmgu_title xmgu_title proc~write_dos_xmgrace->proc~xmgu_title proc~xmgu_setup xmgu_setup proc~write_dos_xmgrace->proc~xmgu_setup proc~xmgu_subtitle xmgu_subtitle proc~write_dos_xmgrace->proc~xmgu_subtitle proc~xmgu_axis xmgu_axis proc~write_dos_xmgrace->proc~xmgu_axis proc~xmgu_vertical_line xmgu_vertical_line proc~write_dos_xmgrace->proc~xmgu_vertical_line proc~xmgu_data_header xmgu_data_header proc~write_dos_xmgrace->proc~xmgu_data_header proc~xmgu_data xmgu_data proc~write_dos_xmgrace->proc~xmgu_data proc~io_date io_date proc~xmgu_setup->proc~io_date proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_dos_xmgrace~~CalledByGraph proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos write_dos proc~write_dos->proc~write_dos_xmgrace proc~dos_calculate dos_calculate proc~dos_calculate->proc~write_dos program~optados optados program~optados->proc~dos_calculate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_dos_xmgrace Source Code subroutine write_dos_xmgrace ( dos_name , E , dos ) !=============================================================================== use xmgrace_utils use od_parameters , only : dos_nbins , set_efermi_zero use od_electronic , only : nspins , efermi , efermi_set use od_io , only : io_file_unit , io_error , seedname implicit none real ( dp ), intent ( in ) :: E ( dos_nbins ) real ( dp ), intent ( in ) :: dos ( dos_nbins , nspins ) real ( dp ) :: min_x , max_x , min_y , max_y integer :: batch_file , ierr character ( len =* ), intent ( in ) :: dos_name batch_file = io_file_unit () open ( unit = batch_file , file = trim ( seedname ) // '.' // trim ( dos_name ) // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in dos: write_dos_xmgrace\" ) min_x = minval ( E ) max_x = maxval ( E ) min_y = 0 max_y = maxval ( dos ) if ( nspins > 1 ) then min_y = - max_y end if call xmgu_setup ( batch_file ) call xmgu_legend ( batch_file ) call xmgu_title ( batch_file , min_x , max_x , min_y , max_y , \"Electronic Density of States\" ) call xmgu_subtitle ( batch_file , \"Generated by OptaDOS\" ) call xmgu_axis ( batch_file , \"x\" , \"Energy eV\" ) call xmgu_axis ( batch_file , \"y\" , \"eDOS\" ) if ( set_efermi_zero ) then call xmgu_vertical_line ( batch_file , 0.0_dp , max_y , min_y ) else if ( efermi_set ) call xmgu_vertical_line ( batch_file , efermi , max_y , min_y ) end if if ( nspins > 1 ) then call xmgu_data_header ( batch_file , 0 , 1 , \"up-spin channel\" ) call xmgu_data_header ( batch_file , 1 , 2 , \"down-spin channel\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) call xmgu_data ( batch_file , 1 , E (:), - dos (:, 2 )) else call xmgu_data_header ( batch_file , 0 , 1 , \"Total DOS\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) end if close ( batch_file ) end subroutine write_dos_xmgrace","tags":"","loc":"proc/write_dos_xmgrace.html"},{"title":"od_pdos – OptaDOS","text":"$!===============================================================================\n$ subroutine count_atoms(orbital,num_orbitals,num_atoms)\n$!===============================================================================\n$! From the program LinDOS (AJM)\n$! Take the orbial information and work out the number of atoms that the LCAO\n$! describe\n$!===============================================================================\n$   use od_io, only : io_error\n$   implicit none\n$   integer, intent(in)            :: num_orbitals\n$   type(orbitals), intent(inout)  :: orbital(1:num_orbitals) ! sepcies, ! num of each species ! l channel\n$   integer, intent(out)           :: num_atoms\n$\n$   integer, allocatable           :: species_count(:)\n$   integer                        :: num_species, ion_count\n$   integer                        :: i, ierr\n$\n$   num_species=maxval(orbital(:)%species_no)  ! The maximum value is the highest species rank\n$\n$   allocate(species_count(1:num_species), stat=ierr)\n$   if(ierr/=0) call io_error( \" Error : cannot allocate species_count\")\n$\n$   species_count=0\n$   ion_count=0\n$\n$   do i=1,num_orbitals\n$    ! If the species number is greater than the number we have for that species then use this\n$    ! new number instead\n$    ! NB I'm using data from the array orbital to index species count! :S\n$    if(orbital(i)%rank_in_species>species_count(orbital(i)%species_no)) then\n$      species_count(orbital(i)%species_no)=orbital(i)%rank_in_species\n$      ion_count=ion_count+1\n$    endif\n$    orbital(i)%ion_no=ion_count\n$   enddo\n$\n$   num_atoms=sum(species_count(:))\n$\n$   if(allocated(species_count)) then\n$     deallocate(species_count, stat=ierr)\n$     if(ierr/=0) stop \" Error : cannot deallocate  species_count\"\n$   endif\n$  end subroutine count_atoms $  subroutine general_write_pdos\n$    !===============================================================================\n$    ! Write out the pdos that was requested. Make a pretty header so that the user\n$    ! knows what each column means\n$    !===============================================================================\n$    use od_dos_utils,       only : E\n$    use od_parameters,only : dos_nbins\n$    use od_algorithms, only : channel_to_am\n$    use od_electronic, only         : pdos_mwab\n$    use od_cell, only : atoms_species_num, num_species\n$    use od_io, only : io_file_unit, seedname, io_error, io_date\n$\n$    implicit none\n$\n$   character(len=11) :: cdate\n$   character(len=9) :: ctime\n$    character(len=20) :: string, filename\n$    integer :: iproj, iam, ispecies_num, ispecies, species, species_num\n$    integer :: last_species, last_species_num\n$    integer :: idos, i, pdos_file,ierr, start_proj\n$\n$    logical :: projector_to_file\n$\n$\n$    write(string,'(I4,\"(x,es14.7)\")') pdos_mwab%norbitals\n$\n$    start_proj=1\n$    projectors: do iproj=1,num_proj\n$       projector_to_file=.false.\n$\n$       ! Are we writing .pdos.projX.dat or .pdos.AtomAtomNo.dat?\n$       ! does this projector contain more than one atom?\n$       do iam=1,max_am\n$          if(sum(projection_array(:,:,iam,iproj))>1) then\n$             ! Yes it does contain more than one atom\n$             projector_to_file=.true.\n$          endif\n$       enddo\n$\n$       if(projector_to_file) then\n$          ! Then let's write out this projector and move on to the next one\n$\n$          ! Must first check whether this isn't the last one in a previous projector group\n$          if(start_proj.ne.iproj) then ! Yes it is.\n$             write(string,'(I20)') last_species_num\n$             filename=proj_symbol(last_species)//adjustl(string)\n$             write( , ) \"So write out Projectors \", start_proj,\" to \", iproj, \" to file \", &\n$                  & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\"\n$             call write_proj_to_file(start_proj, iproj, filename)\n$             start_proj=iproj+1 ! Reset start counter, and we've written the current one.\n$             cycle projectors\n$          endif\n$\n$          write( , ) \"For proj:\", iproj, \"there is more than one atom\"\n$          write( , ) \"Hence we're writing projectors to files\"\n$          write(string,'(I20)') iproj\n$          filename=\"proj\"//adjustl(string)\n$          write( , ) \"So write out Projectors \", start_proj,\" to \", iproj, \" to file \", &\n$               & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\"\n$          call write_proj_to_file(iproj,iproj,filename)\n$          start_proj=iproj+1 ! Reset start counter, and we've written the current one.\n$          cycle projectors\n$       endif\n$\n$       ! Since we're not writing just one projector to the file, we're going to have to work out\n$       ! how many projectors there are going to be in this file.\n$       ! Work out the species and species_rank of this projector\n$       scan: do iam=1,max_am\n$          do ispecies_num=1,maxval(atoms_species_num)\n$             do  ispecies=1,num_species\n$                if(projection_array(ispecies,ispecies_num,iam,iproj)==1) then\n$                   species=ispecies\n$                   species_num=ispecies_num\n$                   write( , ) \"Projector \",iproj,\" is Species \", ispecies, \" Rank \", ispecies_num\n$                   exit scan\n$                endif\n$             enddo\n$          enddo\n$       enddo scan\n$\n$       ! First time through we just put the info about this projector into the registry\n$       if(iproj==start_proj) then\n$          write( , ) \"Skipping over projector:\", iproj,\" as we've nothing to compare it against yet\"\n$          last_species=species\n$          last_species_num=species_num\n$          start_proj=iproj\n$       ! If this is the same species as the last one. We go around again.\n$       elseif((species==last_species).and.(species_num==last_species_num)) then\n$          write( , ) \"Projector \", iproj, \" has the same Species and Rank as \", start_proj\n$          last_species=species\n$          last_species_num=species_num\n$       else ! We've come to the end of the projector group, so need to write out all the old ones.\n$          write( , ) \"Projector \", iproj, \" has different Species and Rank to \", start_proj\n$          write(string,'(I20)') iproj\n$          filename=trim(proj_symbol(species))//adjustl(string)\n$          write( , ) \"So write out Projectors \", start_proj,\" to \", iproj-1, \" to file \", &\n$               & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\"\n$          call write_proj_to_file(start_proj, iproj-1,filename)\n$          start_proj=iproj ! Since we haven't written the current projector yet\n$          last_species=species\n$          last_species_num=species_num\n$       endif\n$\n$       ! If this is our last loop, then we'd better write the last on out too.\n$       if(iproj==num_proj) then\n$          write( , ) \"Last Projector group \", start_proj, \" to \", iproj\n$          write(string,'(I20)') iproj\n$          filename=trim(proj_symbol(species))//adjustl(string)\n$          write( , ) \"So write out Projectors \", start_proj,\" to \", iproj, \" to file \",&\n$               & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\"\n$          call write_proj_to_file(start_proj, iproj, filename)\n$       endif\n$\n$    enddo projectors\n$    return\n$  end subroutine general_write_pdos Uses od_projection_utils od_constants module~~od_pdos~~UsesGraph module~od_pdos od_pdos module~od_projection_utils od_projection_utils module~od_pdos->module~od_projection_utils module~od_constants od_constants module~od_pdos->module~od_constants module~od_projection_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_pdos~~UsedByGraph module~od_pdos od_pdos program~optados optados program~optados->module~od_pdos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dos_partial Subroutines pdos_calculate Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, save :: dos_partial (:,:,:) Subroutines public  subroutine pdos_calculate () Arguments None","tags":"","loc":"module/od_pdos.html"},{"title":"od_projection_utils – OptaDOS","text":"Uses od_constants module~~od_projection_utils~~UsesGraph module~od_projection_utils od_projection_utils module~od_constants od_constants module~od_projection_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_projection_utils~~UsedByGraph module~od_projection_utils od_projection_utils proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_projection_utils module~od_pdos od_pdos module~od_pdos->module~od_projection_utils module~od_pdis od_pdis module~od_pdis->module~od_projection_utils proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_projection_utils program~optados optados program~optados->module~od_pdos program~optados->module~od_pdis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables matrix_weights max_am num_proj proj_am proj_sites proj_symbol projection_array shortcut Subroutines projection_analyse_orbitals projection_get_string projection_merge Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:, :, :, :) :: matrix_weights integer, public, parameter :: max_am = 4 integer, public :: num_proj integer, public, allocatable :: proj_am (:,:) integer, public, allocatable :: proj_sites (:) character(len=3), public, allocatable :: proj_symbol (:) integer, public, allocatable :: projection_array (:,:,:,:) logical, public :: shortcut Subroutines public  subroutine projection_analyse_orbitals () Arguments None public  subroutine projection_get_string () Arguments None public  subroutine projection_merge () Arguments None","tags":"","loc":"module/od_projection_utils.html"},{"title":"od_algorithms – OptaDOS","text":"Uses od_constants module~~od_algorithms~~UsesGraph module~od_algorithms od_algorithms module~od_constants od_constants module~od_algorithms->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_algorithms~~UsedByGraph module~od_algorithms od_algorithms proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->module~od_algorithms proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->module~od_algorithms proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->module~od_algorithms proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~doslin_sub_cell_corners->module~od_algorithms proc~cell_read_cell cell_read_cell proc~cell_read_cell->module~od_algorithms proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->module~od_algorithms proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_algorithms proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->module~od_algorithms proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->module~od_algorithms proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->module~od_algorithms proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->module~od_algorithms Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions algorithms_erf channel_to_am gaussian utility_lowercase Subroutines algor_dist_array heap_sort utility_cart_to_frac utility_frac_to_cart utility_reciprocal_cart_to_frac utility_reciprocal_frac_to_cart Functions public  function algorithms_erf (x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public  function channel_to_am (no) Arguments Type Intent Optional Attributes Name integer, intent(in) :: no Return Value character(len=1) public  function gaussian (m, w, x) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: m real(kind=dp), intent(in) :: w real(kind=dp), intent(in) :: x Return Value real(kind=dp) public  function utility_lowercase (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=maxlen) Subroutines public  subroutine algor_dist_array (num_elements, elements_per_node) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_elements integer, intent(out), allocatable :: elements_per_node (:) public  subroutine heap_sort (num_items, weight) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_items real(kind=dp), intent(inout), dimension(num_items) :: weight public  subroutine utility_cart_to_frac (cart, frac, recip_lat) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: cart (3) real(kind=dp), intent(out) :: frac (3) real(kind=dp), intent(in) :: recip_lat (3,3) public  subroutine utility_frac_to_cart (frac, cart, real_lat) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frac (3) real(kind=dp), intent(out) :: cart (3) real(kind=dp), intent(in) :: real_lat (3,3) public  subroutine utility_reciprocal_cart_to_frac (cart, frac, real_lattice) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: cart (3) real(kind=dp), intent(out) :: frac (3) real(kind=dp), intent(in) :: real_lattice (3,3) public  subroutine utility_reciprocal_frac_to_cart (frac_rec, cart_rec, recip_lattice) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frac_rec (3) real(kind=dp), intent(out) :: cart_rec (3) real(kind=dp), intent(in) :: recip_lattice (3,3)","tags":"","loc":"module/od_algorithms.html"},{"title":"od_jdos – OptaDOS","text":"Uses od_constants module~~od_jdos~~UsesGraph module~od_jdos od_jdos module~od_constants od_constants module~od_jdos->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_jdos~~UsedByGraph module~od_jdos od_jdos program~optados optados program~optados->module~od_jdos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines jdos_calculate write_jdos write_jdos_xmgrace Subroutines public  subroutine jdos_calculate () Arguments None public  subroutine write_jdos (E, dos, dos_name) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: E (jdos_nbins) real(kind=dp), intent(in) :: dos (jdos_nbins,nspins) character(len=*), intent(in) :: dos_name public  subroutine write_jdos_xmgrace (dos_name, E, dos) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dos_name real(kind=dp), intent(in) :: E (jdos_nbins) real(kind=dp), intent(in) :: dos (jdos_nbins,nspins)","tags":"","loc":"module/od_jdos.html"},{"title":"od_dos_utils – OptaDOS","text":"Uses od_electronic od_constants module~~od_dos_utils~~UsesGraph module~od_dos_utils od_dos_utils module~od_electronic od_electronic module~od_dos_utils->module~od_electronic module~od_constants od_constants module~od_dos_utils->module~od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_dos_utils~~UsedByGraph module~od_dos_utils od_dos_utils proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_dos_utils proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_dos_utils proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_dos_utils proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_dos_utils proc~core_calculate core_calculate proc~core_calculate->module~od_dos_utils proc~optics_calculate optics_calculate proc~optics_calculate->module~od_dos_utils proc~dos_calculate dos_calculate proc~dos_calculate->module~od_dos_utils proc~write_dos write_dos proc~write_dos->module~od_dos_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables E cbm_energy dos_adaptive dos_fixed dos_linear efermi_adaptive efermi_fixed efermi_linear intdos_adaptive intdos_fixed intdos_linear vbm_energy Functions doslin Subroutines dos_utils_calculate dos_utils_calculate_at_e dos_utils_compute_band_energies dos_utils_compute_bandgap dos_utils_compute_dos_at_efermi dos_utils_deallocate dos_utils_merge dos_utils_set_efermi doslin_sub_cell_corners Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, save :: E (:) real(kind=dp), public, save :: cbm_energy = 0.0_dp real(kind=dp), public, allocatable, save :: dos_adaptive (:,:) real(kind=dp), public, allocatable, save :: dos_fixed (:,:) real(kind=dp), public, allocatable, save :: dos_linear (:,:) real(kind=dp), public, save :: efermi_adaptive real(kind=dp), public, save :: efermi_fixed real(kind=dp), public, save :: efermi_linear real(kind=dp), public, allocatable, save :: intdos_adaptive (:,:) real(kind=dp), public, allocatable, save :: intdos_fixed (:,:) real(kind=dp), public, allocatable, save :: intdos_linear (:,:) real(kind=dp), public, save :: vbm_energy = 0.0_dp Functions public  function doslin (e0, e1, e2, e3, e4, e, int) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: e0 real(kind=dp), intent(in) :: e1 real(kind=dp), intent(in) :: e2 real(kind=dp), intent(in) :: e3 real(kind=dp), intent(in) :: e4 real(kind=dp), intent(in) :: e real(kind=dp), intent(out) :: int Return Value real(kind=dp) Subroutines public  subroutine dos_utils_calculate (matrix_weights, weighted_dos) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional, allocatable :: matrix_weights (:,:,:,:) real(kind=dp), intent(out), optional, allocatable :: weighted_dos (:,:,:) public  subroutine dos_utils_calculate_at_e (energy, dos_at_e, matrix_weights, weighted_dos_at_e) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: energy real(kind=dp), intent(out) :: dos_at_e (1:3,nspins) real(kind=dp), intent(in), optional, allocatable :: matrix_weights (:,:,:,:) real(kind=dp), intent(out), optional :: weighted_dos_at_e (:,:) public  subroutine dos_utils_compute_band_energies () Arguments None public  subroutine dos_utils_compute_bandgap () Arguments None public  subroutine dos_utils_compute_dos_at_efermi () Arguments None public  subroutine dos_utils_deallocate () Arguments None public  subroutine dos_utils_merge (dos, weighted_dos) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: dos (:,:) real(kind=dp), intent(inout), optional, allocatable :: weighted_dos (:,:,:) public  subroutine dos_utils_set_efermi () Arguments None public  subroutine doslin_sub_cell_corners (grad, step, energy, EigenV) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: grad (1:3) real(kind=dp), intent(in) :: step (1:3) real(kind=dp), intent(in) :: energy real(kind=dp), intent(out) :: EigenV (0:4)","tags":"","loc":"module/od_dos_utils.html"},{"title":"od_parameters – OptaDOS","text":"Uses od_cell od_io od_constants module~~od_parameters~~UsesGraph module~od_parameters od_parameters module~od_cell od_cell module~od_parameters->module~od_cell module~od_io od_io module~od_parameters->module~od_io module~od_constants od_constants module~od_parameters->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_parameters~~UsedByGraph module~od_parameters od_parameters proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->module~od_parameters proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_parameters proc~jdos_calculate jdos_calculate proc~jdos_calculate->module~od_parameters proc~elec_report_parameters elec_report_parameters proc~elec_report_parameters->module~od_parameters proc~allocate_jdos allocate_jdos proc~allocate_jdos->module~od_parameters proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->module~od_parameters proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->module~od_parameters proc~projection_get_string projection_get_string proc~projection_get_string->module~od_parameters proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->module~od_parameters proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->module~od_parameters proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_parameters proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->module~od_parameters proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->module~od_parameters proc~make_weights make_weights proc~make_weights->module~od_parameters proc~write_conduct write_conduct proc~write_conduct->module~od_parameters proc~core_calculate core_calculate proc~core_calculate->module~od_parameters proc~write_dos write_dos proc~write_dos->module~od_parameters proc~write_absorp write_absorp proc~write_absorp->module~od_parameters proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->module~od_parameters proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->module~od_parameters proc~calc_refract calc_refract proc~calc_refract->module~od_parameters proc~calc_conduct calc_conduct proc~calc_conduct->module~od_parameters program~optados optados program~optados->module~od_parameters proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->module~od_parameters proc~write_refract write_refract proc~write_refract->module~od_parameters proc~write_epsilon write_epsilon proc~write_epsilon->module~od_parameters proc~write_loss_fn write_loss_fn proc~write_loss_fn->module~od_parameters proc~optics_calculate optics_calculate proc~optics_calculate->module~od_parameters module~od_conv od_conv module~od_conv->module~od_parameters proc~dos_calculate dos_calculate proc~dos_calculate->module~od_parameters proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->module~od_parameters proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->module~od_parameters proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_parameters proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->module~od_parameters proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->module~od_parameters proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->module~od_parameters proc~calc_epsilon_1 calc_epsilon_1 proc~calc_epsilon_1->module~od_parameters proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->module~od_parameters proc~calc_loss_fn calc_loss_fn proc~calc_loss_fn->module~od_parameters proc~write_jdos write_jdos proc~write_jdos->module~od_parameters proc~write_reflect write_reflect proc~write_reflect->module~od_parameters proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_parameters proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_parameters proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->module~od_parameters proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_parameters proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->module~od_parameters program~od2od od2od program~od2od->module~od_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables LAI_gaussian LAI_gaussian_width LAI_lorentzian LAI_lorentzian_offset LAI_lorentzian_scale LAI_lorentzian_width adaptive adaptive_smearing compare_dos compare_jdos compute_band_energy compute_band_gap core core_LAI_broadening core_chemical_shift core_geom core_qdir core_type devel_flag dos dos_max_energy dos_min_energy dos_nbins dos_per_volume dos_spacing efermi_choice efermi_user energy_unit exclude_bands finite_bin_correction fixed fixed_smearing hybrid_linear hybrid_linear_grad_tol iprint jdos jdos_max_energy jdos_spacing kpoint_mp_grid legacy_file_format lenconfac length_unit linear linear_smearing num_exclude_bands numerical_intdos optics optics_drude_broadening optics_geom optics_intraband optics_lossfn_broadening optics_lossfn_gaussian optics_qdir output_format pdis pdos photo photo_bulk_cutoff photo_elec_field photo_imfp_const photo_layer_choice photo_len_imfp_const photo_max_layer photo_model photo_momentum photo_phi_lower photo_phi_upper photo_photon_energy photo_photon_max photo_photon_min photo_photon_sweep photo_remove_box_states photo_slab_max photo_slab_min photo_temperature photo_theta_lower photo_theta_upper photo_work_function projectors_string quad scissor_op set_efermi_zero write_photo_output Subroutines param_dealloc param_dist param_read param_write param_write_atomic_coord param_write_header Variables Type Visibility Attributes Name Initial logical, public, save :: LAI_gaussian real(kind=dp), public, save :: LAI_gaussian_width logical, public, save :: LAI_lorentzian real(kind=dp), public, save :: LAI_lorentzian_offset real(kind=dp), public, save :: LAI_lorentzian_scale real(kind=dp), public, save :: LAI_lorentzian_width logical, public, save :: adaptive real(kind=dp), public, save :: adaptive_smearing logical, public, save :: compare_dos logical, public, save :: compare_jdos logical, public, save :: compute_band_energy logical, public, save :: compute_band_gap logical, public, save :: core logical, public, save :: core_LAI_broadening real(kind=dp), public, save :: core_chemical_shift character(len=20), public, save :: core_geom real(kind=dp), public, save :: core_qdir (3) character(len=20), public, save :: core_type character(len=100), public, save :: devel_flag logical, public, save :: dos real(kind=dp), public, save :: dos_max_energy real(kind=dp), public, save :: dos_min_energy integer, public, save :: dos_nbins logical, public, save :: dos_per_volume real(kind=dp), public, save :: dos_spacing character(len=20), public, save :: efermi_choice real(kind=dp), public, save :: efermi_user character(len=20), public, save :: energy_unit integer, public, allocatable, save :: exclude_bands (:) logical, public, save :: finite_bin_correction logical, public, save :: fixed real(kind=dp), public, save :: fixed_smearing logical, public, save :: hybrid_linear real(kind=dp), public, save :: hybrid_linear_grad_tol integer, public, save :: iprint logical, public, save :: jdos real(kind=dp), public, save :: jdos_max_energy real(kind=dp), public, save :: jdos_spacing integer, public, save :: kpoint_mp_grid (3) logical, public, save :: legacy_file_format real(kind=dp), public, save :: lenconfac character(len=20), public, save :: length_unit logical, public, save :: linear real(kind=dp), public, save :: linear_smearing integer, public, save :: num_exclude_bands logical, public, save :: numerical_intdos logical, public, save :: optics real(kind=dp), public, save :: optics_drude_broadening character(len=20), public, save :: optics_geom logical, public, save :: optics_intraband logical, public, save :: optics_lossfn_broadening real(kind=dp), public, save :: optics_lossfn_gaussian real(kind=dp), public, save :: optics_qdir (3) character(len=20), public, save :: output_format logical, public, save :: pdis logical, public, save :: pdos logical, public, save :: photo real(kind=dp), public, save :: photo_bulk_cutoff real(kind=dp), public, save :: photo_elec_field real(kind=dp), public, dimension(:), allocatable, save :: photo_imfp_const character(len=20), public, save :: photo_layer_choice integer, public, save :: photo_len_imfp_const integer, public, save :: photo_max_layer character(len=20), public, save :: photo_model character(len=20), public, save :: photo_momentum real(kind=dp), public, save :: photo_phi_lower real(kind=dp), public, save :: photo_phi_upper real(kind=dp), public, save :: photo_photon_energy real(kind=dp), public, save :: photo_photon_max real(kind=dp), public, save :: photo_photon_min logical, public, save :: photo_photon_sweep logical, public, save :: photo_remove_box_states real(kind=dp), public, save :: photo_slab_max real(kind=dp), public, save :: photo_slab_min real(kind=dp), public, save :: photo_temperature real(kind=dp), public, save :: photo_theta_lower real(kind=dp), public, save :: photo_theta_upper real(kind=dp), public, save :: photo_work_function character(len=maxlen), public, save :: projectors_string logical, public, save :: quad real(kind=dp), public, save :: scissor_op logical, public, save :: set_efermi_zero character(len=20), public, save :: write_photo_output Subroutines public  subroutine param_dealloc () Arguments None public  subroutine param_dist () Arguments None public  subroutine param_read () change\nchange\nchange Arguments None public  subroutine param_write () Arguments None public  subroutine param_write_atomic_coord () Arguments None public  subroutine param_write_header () Arguments None","tags":"","loc":"module/od_parameters.html"},{"title":"od_build – OptaDOS","text":"Used by module~~od_build~~UsedByGraph module~od_build od_build proc~version_output version_output proc~version_output->module~od_build program~optados optados program~optados->module~od_build Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables build_info Derived Types build_info_type Variables Type Visibility Attributes Name Initial type( build_info_type ), public, save :: build_info Derived Types type, public :: build_info_type Components Type Visibility Attributes Name Initial character(len=20), public :: build = '' character(len=20), public :: build_type = 'debug' character(len=20), public :: comms_arch = 'serial' character(len=20), public :: compile_date = 'Mon 28 Aug 2023' character(len=20), public :: compile_time = '16:49 BST' character(len=20), public :: compiler = 'gfortran' character(len=20), public :: source_date = 'Mon 28 Aug 2023' character(len=20), public :: source_time = '16:47:50'","tags":"","loc":"module/od_build.html"},{"title":"od_conv – OptaDOS","text":"Helper module for od2od used for file conversions. Uses od_io od_electronic od_parameters od_constants module~~od_conv~~UsesGraph module~od_conv od_conv module~od_io od_io module~od_conv->module~od_io module~od_parameters od_parameters module~od_conv->module~od_parameters module~od_constants od_constants module~od_conv->module~od_constants module~od_electronic od_electronic module~od_conv->module~od_electronic module~od_io->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_conv~~UsedByGraph module~od_conv od_conv program~od2od od2od program~od2od->module~od_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables format_precision infile outfile outseedname Subroutines conv_get_seedname get_band_energy pad_an_ome print_usage read_dome_bin read_dome_fmt read_elnes_bin read_elnes_fmt read_fem_bin read_fem_fmt read_ome_bin read_ome_fmt read_pdos_bin read_pdos_fmt report_arraysize slice_an_ome write_dome_bin write_dome_fmt write_elnes_bin write_elnes_fmt write_fem_bin write_fem_fmt write_ome_bin write_ome_fmt write_pdos_bin write_pdos_fmt write_read_file Variables Type Visibility Attributes Name Initial character(len=10), public, save :: format_precision = \"es23.10\" Things get messy below 10 s.f. between bin files and fmt files character(len=80), public, save :: infile Type of file to convert from. character(len=80), public, save :: outfile Type of file to convert to. character(len=80), public, save :: outseedname It's conceivable that you might not\n want to write over what you already have. Subroutines public  subroutine conv_get_seedname () Set the seedname from the command line\nset to optados until proven otherwise\nEnd of flags\nWe've already set the seedname so it can't be that again! Arguments None public  subroutine get_band_energy () Read the band file info which is prerequisite to know about k-points\nbands etc.\nIt would be nice for od2od to work this out for itself. But at least this\nway it is consistent.  The problem is that to convert, say a ome to a ome\none also requires a .bands file. Arguments None public  subroutine pad_an_ome () This routine takes OptaDOS's internal representation of an dome file, and\nuses it to construct an ome file, where the off diagonal elements are\npadded with zeros.\nIt might be helpful if we're reading in other codes' input files.\nIt might also be useful for testing OptaDOS itself. Arguments None public  subroutine print_usage () Writes the usage of the program to stdout Arguments None public  subroutine read_dome_bin () Read a diagonal ome file. Wrapper to keep the naming scheme tidy. Arguments None public  subroutine read_dome_fmt () Read a diagonal ome formatted file. Arguments None public  subroutine read_elnes_bin () Wrapper to read a binary elnes file. The wrapping allows us to have\nconsistent names within the module, which makes life easier. Arguments None public  subroutine read_elnes_fmt () Read a formatted elnes file. Arguments None public  subroutine read_fem_bin () Read a binary ome file. Wrapper to keep the naming tidy. Arguments None public  subroutine read_fem_fmt () Read a formatted Optical Matrix Elements file. Arguments None public  subroutine read_ome_bin () Read a binary ome file. Wrapper to keep the naming tidy. Arguments None public  subroutine read_ome_fmt () Read a formatted Optical Matrix Elements file. Arguments None public  subroutine read_pdos_bin () Wrapper to read a pdos binary file. Useful to keep the code tidy. Arguments None public  subroutine read_pdos_fmt () Read a formatted pdos file. Arguments None public  subroutine report_arraysize () Write to stdout some info on the size of the arrays we're using. These\nare normally found in the .bands file. Arguments None public  subroutine slice_an_ome () This routine takes OptaDOS's internal representation of an ome and\nputs its diagonal into its internal representation of a dome.\nIt's useful for testing. Arguments None public  subroutine write_dome_bin () Write a diagonal ome file. Arguments None public  subroutine write_dome_fmt () Write a diagonal ome formatted file. Arguments None public  subroutine write_elnes_bin () Writes a binary elnes file. Arguments None public  subroutine write_elnes_fmt () Soubroute to write a formatted elnes file. Arguments None public  subroutine write_fem_bin () Write a binary ome file. Arguments None public  subroutine write_fem_fmt () Write a formatted ome file. Arguments None public  subroutine write_ome_bin () Write a binary ome file. Arguments None public  subroutine write_ome_fmt () Write a formatted ome file. Arguments None public  subroutine write_pdos_bin () Write a binary pdos file Arguments None public  subroutine write_pdos_fmt () Write a formatted pdos file. Arguments None public  subroutine write_read_file () Noddy routine to prettify output Arguments None","tags":"","loc":"module/od_conv.html"},{"title":"od_core – OptaDOS","text":"$\n$  !===============================================================================\n$  subroutine write_core_gnuplot(label,E,column1,column2,column3)\n$    !===============================================================================\n$    use od_io,         only : io_file_unit,io_error,seedname\n$    implicit none\n$\n$    type(graph_labels),intent(in) :: label\n$\n$    real(dp),  intent(in) :: E(:)\n$    real(dp),  intent(in)  :: column1(:)\n$    real(dp),  optional, intent(in) :: column2(:)\n$    real(dp),  optional, intent(in) :: column3(:)\n$\n$    integer :: gnu_unit,ierr\n$\n$    gnu_unit=io_file_unit()\n$    open(unit=gnu_unit,file=trim(seedname)//' '//trim(label%name)//'.gnu',iostat=ierr)\n$    if(ierr.ne.0) call io_error(\" ERROR: Cannot open gnuplot batch file in optics: write_optics_gnupot\")\n$\n$    gnu_unit = io_file_unit()\n$    open(unit=gnu_unit,action='write',file=trim(seedname)//' '//trim(label%name)//'.gnu')\n$    write(gnu_unit, ) 'set xlabel ','\"'//trim(label%x_label)//'\"'\n$    write(gnu_unit, ) 'set ylabel ','\"'//trim(label%y_label)//'\"'\n$    write(gnu_unit, ) 'set title ','\"'//trim(label%title)//'\"'\n$    if(present(column3)) then\n$       write(gnu_unit, ) 'plot ','\"'//trim(seedname)//' '//trim(label%name)//'.dat'//'\"',' u 1:2 t ','\"'//trim(label%legend_a)//'\"',' w l, \\'\n$       write(gnu_unit, ) '       \"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:3 t ','\"'//trim(label%legend_b)//'\"',' w l, \\'\n$       write(gnu_unit, ) '       \"'//trim(seedname)//' '//trim(label%name)//'.dat'//'\"',' u 1:4 t ','\"'//trim(label%legend_c)//'\"',' w l'\n$    elseif(present(column2)) then\n$       write(gnu_unit, ) 'plot ','\"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:2 t ','\"'//trim(label%legend_a)//'\"',' w l, \\'\n$       write(gnu_unit, ) '       \"'//trim(seedname)//' '//trim(label%name)//'.dat'//'\"',' u 1:3 t ','\"'//trim(label%legend_b)//'\"',' w l'\n$    else\n$       write(gnu_unit,*) 'plot ','\"'//trim(seedname)//' '//trim(label%name)//'.dat'//'\"',' u 1:2 t ','\"'//trim(label%legend_a)//'\"',' w l'\n$    endif\n$    close(gnu_unit)\n$\n$  end subroutine write_optics_gnuplot\n$ Uses od_constants module~~od_core~~UsesGraph module~od_core od_core module~od_constants od_constants module~od_core->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_core~~UsedByGraph module~od_core od_core program~optados optados program~optados->module~od_core Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables matrix_weights weighted_dos weighted_dos_broadened Subroutines core_calculate Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:, :, :, :) :: matrix_weights real(kind=dp), public, allocatable, dimension(:, :, :) :: weighted_dos real(kind=dp), public, allocatable, dimension(:, :, :) :: weighted_dos_broadened Subroutines public  subroutine core_calculate () Arguments None","tags":"","loc":"module/od_core.html"},{"title":"xmgrace_utils – OptaDOS","text":"Used by module~~xmgrace_utils~~UsedByGraph module~xmgrace_utils xmgrace_utils proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->module~xmgrace_utils proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->module~xmgrace_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines xmgu_axis xmgu_data xmgu_data_header xmgu_legend xmgu_setup xmgu_subtitle xmgu_title xmgu_vertical_line Subroutines public  subroutine xmgu_axis (unit, axis, label) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character, intent(in) :: axis character, intent(in) :: label public  subroutine xmgu_data (unit, field, x_data, y_data) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: field real(kind=dp), intent(in) :: x_data (:) real(kind=dp), intent(in) :: y_data (:) public  subroutine xmgu_data_header (unit, field, colour, legend) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(in) :: field integer, intent(in) :: colour character, intent(in) :: legend public  subroutine xmgu_legend (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit public  subroutine xmgu_setup (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit public  subroutine xmgu_subtitle (unit, subtitle) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character, intent(in) :: subtitle public  subroutine xmgu_title (unit, min_x, max_x, min_y, max_y, title) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit real(kind=dp), intent(in) :: min_x real(kind=dp), intent(in) :: max_x real(kind=dp), intent(in) :: min_y real(kind=dp), intent(in) :: max_y character, intent(in) :: title public  subroutine xmgu_vertical_line (unit, x_coord, y_max, y_min) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit real(kind=dp), intent(in) :: x_coord real(kind=dp), intent(in) :: y_max real(kind=dp), intent(in) :: y_min","tags":"","loc":"module/xmgrace_utils.html"},{"title":"od_cell – OptaDOS","text":"Uses od_io od_constants module~~od_cell~~UsesGraph module~od_cell od_cell module~od_io od_io module~od_cell->module~od_io module~od_constants od_constants module~od_cell->module~od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_cell~~UsedByGraph module~od_cell od_cell module~od_parameters od_parameters module~od_parameters->module~od_cell proc~projection_get_string projection_get_string proc~projection_get_string->module~od_cell proc~projection_get_string->module~od_parameters proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_cell proc~jdos_utils_calculate->module~od_parameters proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->module~od_cell proc~elec_read_optical_mat->module~od_parameters proc~write_fem_bin write_fem_bin proc~write_fem_bin->module~od_cell proc~write_pdos_fmt write_pdos_fmt proc~write_pdos_fmt->module~od_cell proc~elec_report_parameters elec_report_parameters proc~elec_report_parameters->module~od_cell proc~elec_report_parameters->module~od_parameters proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->module~od_cell proc~dos_utils_compute_bandgap->module~od_parameters proc~param_read param_read proc~param_read->module~od_cell proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->module~od_cell proc~dos_utils_calculate_at_e->module~od_parameters proc~projection_merge projection_merge proc~projection_merge->module~od_cell proc~projection_analyse_orbitals projection_analyse_orbitals proc~projection_analyse_orbitals->module~od_cell proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_cell proc~calculate_jdos->module~od_parameters proc~write_pdos_bin write_pdos_bin proc~write_pdos_bin->module~od_cell proc~pad_an_ome pad_an_ome proc~pad_an_ome->module~od_cell proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->module~od_cell proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->module~od_cell proc~dos_utils_compute_band_energies->module~od_parameters proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~doslin_sub_cell_corners->module~od_cell proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->module~od_cell proc~elec_read_foptical_mat->module~od_parameters proc~make_weights make_weights proc~make_weights->module~od_cell proc~make_weights->module~od_parameters proc~write_conduct write_conduct proc~write_conduct->module~od_cell proc~write_conduct->module~od_parameters proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->module~od_cell proc~elec_pdos_read->module~od_parameters proc~write_absorp write_absorp proc~write_absorp->module~od_cell proc~write_absorp->module~od_parameters proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->module~od_cell proc~elec_read_band_energy->module~od_parameters proc~write_refract write_refract proc~write_refract->module~od_cell proc~write_refract->module~od_parameters proc~write_epsilon write_epsilon proc~write_epsilon->module~od_cell proc~write_epsilon->module~od_parameters proc~optics_calculate optics_calculate proc~optics_calculate->module~od_cell proc~optics_calculate->module~od_parameters proc~read_ome_fmt read_ome_fmt proc~read_ome_fmt->module~od_cell proc~write_loss_fn write_loss_fn proc~write_loss_fn->module~od_cell proc~write_loss_fn->module~od_parameters proc~report_arraysize report_arraysize proc~report_arraysize->module~od_cell proc~write_dome_fmt write_dome_fmt proc~write_dome_fmt->module~od_cell program~optados optados program~optados->module~od_cell program~optados->module~od_parameters proc~slice_an_ome slice_an_ome proc~slice_an_ome->module~od_cell proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->module~od_cell proc~elec_read_band_energy_ordered->module~od_parameters proc~write_fem_fmt write_fem_fmt proc~write_fem_fmt->module~od_cell proc~write_ome_bin write_ome_bin proc~write_ome_bin->module~od_cell proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->module~od_cell proc~elec_pdis_read->module~od_parameters proc~write_dome_bin write_dome_bin proc~write_dome_bin->module~od_cell proc~write_elnes_bin write_elnes_bin proc~write_elnes_bin->module~od_cell proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->module~od_cell proc~elec_read_band_curvature->module~od_parameters proc~write_elnes_fmt write_elnes_fmt proc~write_elnes_fmt->module~od_cell proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->module~od_cell proc~dos_utils_calculate->module~od_parameters proc~write_ome_fmt write_ome_fmt proc~write_ome_fmt->module~od_cell proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->module~od_cell proc~dos_utils_set_efermi->module~od_parameters proc~read_dome_fmt read_dome_fmt proc~read_dome_fmt->module~od_cell proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->module~od_cell proc~elec_read_band_gradient->module~od_parameters proc~calc_loss_fn calc_loss_fn proc~calc_loss_fn->module~od_cell proc~calc_loss_fn->module~od_parameters proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->module~od_cell proc~elec_read_elnes_mat->module~od_parameters proc~write_reflect write_reflect proc~write_reflect->module~od_cell proc~write_reflect->module~od_parameters proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_cell proc~calc_epsilon_2->module~od_parameters proc~read_elnes_fmt read_elnes_fmt proc~read_elnes_fmt->module~od_cell proc~read_fem_fmt read_fem_fmt proc~read_fem_fmt->module~od_cell proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->module~od_parameters proc~calc_refract calc_refract proc~calc_refract->module~od_parameters proc~calc_epsilon_1 calc_epsilon_1 proc~calc_epsilon_1->module~od_parameters proc~allocate_jdos allocate_jdos proc~allocate_jdos->module~od_parameters proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->module~od_parameters proc~jdos_calculate jdos_calculate proc~jdos_calculate->module~od_parameters proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_parameters module~od_conv od_conv module~od_conv->module~od_parameters proc~calc_conduct calc_conduct proc~calc_conduct->module~od_parameters proc~dos_calculate dos_calculate proc~dos_calculate->module~od_parameters proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->module~od_parameters proc~core_calculate core_calculate proc~core_calculate->module~od_parameters proc~write_dos write_dos proc~write_dos->module~od_parameters proc~write_jdos write_jdos proc~write_jdos->module~od_parameters proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->module~od_parameters proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_parameters proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_parameters program~od2od od2od program~od2od->module~od_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables atoms_label atoms_label_tmp atoms_pos_cart atoms_pos_cart_photo atoms_pos_frac atoms_species_num atoms_symbol cell_volume crystal_symmetry_disps crystal_symmetry_operations kpoint_grid_dim kpoint_r kpoint_r_cart kpoint_weight nkpoints num_atoms num_crystal_symmetry_operations num_kpoints_on_node num_species real_lattice recip_lattice Subroutines cell_calc_kpoint_r_cart cell_calc_lattice cell_dist cell_find_MP_grid cell_get_atoms cell_get_real_lattice cell_get_symmetry cell_read_cell cell_report_parameters Variables Type Visibility Attributes Name Initial character(len=maxlen), public, allocatable, save :: atoms_label (:) character(len=maxlen), public, allocatable, save :: atoms_label_tmp (:) real(kind=dp), public, allocatable, save :: atoms_pos_cart (:,:,:) real(kind=dp), public, allocatable, save :: atoms_pos_cart_photo (:,:) real(kind=dp), public, allocatable, save :: atoms_pos_frac (:,:,:) integer, public, allocatable, save :: atoms_species_num (:) character(len=2), public, allocatable, save :: atoms_symbol (:) real(kind=dp), public, save :: cell_volume real(kind=dp), public, allocatable, save :: crystal_symmetry_disps (:,:) real(kind=dp), public, allocatable, save :: crystal_symmetry_operations (:,:,:) integer, public, save :: kpoint_grid_dim (3) real(kind=dp), public, allocatable, save :: kpoint_r (:,:) real(kind=dp), public, allocatable, save :: kpoint_r_cart (:,:) real(kind=dp), public, allocatable, save :: kpoint_weight (:) integer, public, save :: nkpoints integer, public, save :: num_atoms integer, public, save :: num_crystal_symmetry_operations integer, public, allocatable, save :: num_kpoints_on_node (:) integer, public, save :: num_species real(kind=dp), public, save :: real_lattice (1:3,1:3) real(kind=dp), public, save :: recip_lattice (1:3,1:3) Subroutines public  subroutine cell_calc_kpoint_r_cart () Arguments None public  subroutine cell_calc_lattice () Arguments None public  subroutine cell_dist () Arguments None public  subroutine cell_find_MP_grid (kpoints, num_kpts, kpoint_grid_dim, kpoint_offset) AJM COMMENTED OUT AS A TEST AGAINST\nHEXAGONAL CELLS Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: kpoints (1:3,1:num_kpts) integer, intent(in) :: num_kpts integer, intent(out) :: kpoint_grid_dim (1:3) real(kind=dp), intent(out), optional :: kpoint_offset (1:3) public  subroutine cell_get_atoms () Arguments None public  subroutine cell_get_real_lattice () Arguments None public  subroutine cell_get_symmetry () Arguments None public  subroutine cell_read_cell () Arguments None public  subroutine cell_report_parameters () Arguments None","tags":"","loc":"module/od_cell.html"},{"title":"od_jdos_utils – OptaDOS","text":"Uses od_constants module~~od_jdos_utils~~UsesGraph module~od_jdos_utils od_jdos_utils module~od_constants od_constants module~od_jdos_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_jdos_utils~~UsedByGraph module~od_jdos_utils od_jdos_utils proc~calc_conduct calc_conduct proc~calc_conduct->module~od_jdos_utils proc~calc_epsilon_1 calc_epsilon_1 proc~calc_epsilon_1->module~od_jdos_utils proc~calc_refract calc_refract proc~calc_refract->module~od_jdos_utils proc~calc_loss_fn calc_loss_fn proc~calc_loss_fn->module~od_jdos_utils proc~write_epsilon write_epsilon proc~write_epsilon->module~od_jdos_utils proc~write_absorp write_absorp proc~write_absorp->module~od_jdos_utils proc~write_refract write_refract proc~write_refract->module~od_jdos_utils proc~write_conduct write_conduct proc~write_conduct->module~od_jdos_utils proc~optics_calculate optics_calculate proc~optics_calculate->module~od_jdos_utils proc~write_loss_fn write_loss_fn proc~write_loss_fn->module~od_jdos_utils proc~jdos_calculate jdos_calculate proc~jdos_calculate->module~od_jdos_utils proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->module~od_jdos_utils proc~write_jdos write_jdos proc~write_jdos->module~od_jdos_utils proc~calc_absorp calc_absorp proc~calc_absorp->module~od_jdos_utils proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_jdos_utils proc~write_reflect write_reflect proc~write_reflect->module~od_jdos_utils proc~calc_reflect calc_reflect proc~calc_reflect->module~od_jdos_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables E calc_weighted_jdos delta_bins jdos_adaptive jdos_fixed jdos_linear jdos_nbins vb_max Subroutines allocate_jdos calculate_jdos jdos_deallocate jdos_utils_calculate jdos_utils_merge setup_energy_scale Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, save :: E (:) logical, public :: calc_weighted_jdos real(kind=dp), public, save :: delta_bins real(kind=dp), public, allocatable, save :: jdos_adaptive (:,:) real(kind=dp), public, allocatable, save :: jdos_fixed (:,:) real(kind=dp), public, allocatable, save :: jdos_linear (:,:) integer, public, save :: jdos_nbins integer, public, allocatable, save :: vb_max (:) Subroutines public  subroutine allocate_jdos (jdos) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable :: jdos (:,:) public  subroutine calculate_jdos (jdos_type, jdos, matrix_weights, weighted_jdos) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jdos_type real(kind=dp), intent(out), allocatable :: jdos (:,:) real(kind=dp), intent(in), optional :: matrix_weights (:,:,:,:,:) real(kind=dp), intent(inout), optional, allocatable :: weighted_jdos (:,:,:) public  subroutine jdos_deallocate () Arguments None public  subroutine jdos_utils_calculate (matrix_weights, weighted_jdos) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: matrix_weights (:,:,:,:,:) real(kind=dp), intent(out), optional, allocatable :: weighted_jdos (:,:,:) public  subroutine jdos_utils_merge (jdos, weighted_jdos) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: jdos (:,:) real(kind=dp), intent(inout), optional, allocatable :: weighted_jdos (:,:,:) public  subroutine setup_energy_scale (E) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), optional, allocatable :: E (:)","tags":"","loc":"module/od_jdos_utils.html"},{"title":"od_optics – OptaDOS","text":"Uses od_constants module~~od_optics~~UsesGraph module~od_optics od_optics module~od_constants od_constants module~od_optics->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_optics~~UsedByGraph module~od_optics od_optics program~optados optados program~optados->module~od_optics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables absorp conduct dos_at_e dos_matrix_weights epsilon intra loss_fn matrix_weights reflect refract weighted_dos_at_e weighted_jdos Subroutines calc_absorp calc_conduct calc_epsilon_1 calc_epsilon_2 calc_loss_fn calc_reflect calc_refract make_weights optics_calculate write_absorp write_conduct write_epsilon write_loss_fn write_reflect write_refract Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, dimension(:) :: absorp real(kind=dp), public, allocatable, dimension(:, :) :: conduct real(kind=dp), public, allocatable, dimension(:, :) :: dos_at_e real(kind=dp), public, allocatable, dimension(:, :, :, :) :: dos_matrix_weights real(kind=dp), public, allocatable, dimension(:, :, :, :) :: epsilon real(kind=dp), public, allocatable, dimension(:) :: intra real(kind=dp), public, allocatable, dimension(:, :) :: loss_fn real(kind=dp), public, allocatable, dimension(:, :, :, :, :) :: matrix_weights real(kind=dp), public, allocatable, dimension(:) :: reflect real(kind=dp), public, allocatable, dimension(:, :) :: refract real(kind=dp), public, allocatable, dimension(:, :) :: weighted_dos_at_e real(kind=dp), public, allocatable, dimension(:, :, :) :: weighted_jdos Subroutines public  subroutine calc_absorp () This subroutine calculates the absorption coefficient Read more… Arguments None public  subroutine calc_conduct () This subroutine calculates the conductivity Read more… Arguments None public  subroutine calc_epsilon_1 () This subroutine uses kramers kronig to calculate epsilon_1 Read more… Arguments None public  subroutine calc_epsilon_2 (weighted_jdos, weighted_dos_at_e, photo_atom_volume) This subroutine calculates epsilon_2 Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), allocatable, dimension(:, :, :) :: weighted_jdos real(kind=dp), intent(in), allocatable, dimension(:, :) :: weighted_dos_at_e real(kind=dp), intent(in), optional :: photo_atom_volume public  subroutine calc_loss_fn () This subroutine calculates the loss function and the sum rules Read more… Arguments None public  subroutine calc_reflect () This subroutine calculates the reflection coefficient Read more… Arguments None public  subroutine calc_refract () This subroutine calculates the refractive index Read more… Arguments None public  subroutine make_weights (matrix_weights) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out), allocatable, dimension(:, :, :, :, :) :: matrix_weights public  subroutine optics_calculate () Arguments None public  subroutine write_absorp (atom, photo_volume) This subroutine writes out the absorption coefficient Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional :: photo_volume public  subroutine write_conduct () This subroutine writes out the conductivity Read more… Arguments None public  subroutine write_epsilon (atom, photo_at_e, photo_volume) This subroutine writes out the dielectric function Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional, dimension(:, :) :: photo_at_e real(kind=dp), intent(in), optional :: photo_volume public  subroutine write_loss_fn () This subroutine writes out the loss function Read more… Arguments None public  subroutine write_reflect (atom, photo_volume) This subroutine writes out the reflection coefficient Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional :: photo_volume public  subroutine write_refract (atom, photo_volume) This subroutine writes out the refractive index Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: atom real(kind=dp), intent(in), optional :: photo_volume","tags":"","loc":"module/od_optics.html"},{"title":"od_comms – OptaDOS","text":"Uses od_constants module~~od_comms~~UsesGraph module~od_comms od_comms module~od_constants od_constants module~od_comms->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_comms~~UsedByGraph module~od_comms od_comms proc~cell_get_real_lattice cell_get_real_lattice proc~cell_get_real_lattice->module~od_comms proc~cell_get_symmetry cell_get_symmetry proc~cell_get_symmetry->module~od_comms proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->module~od_comms proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_comms proc~param_dist param_dist proc~param_dist->module~od_comms proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->module~od_comms proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->module~od_comms proc~projection_merge projection_merge proc~projection_merge->module~od_comms proc~algor_dist_array algor_dist_array proc~algor_dist_array->module~od_comms proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->module~od_comms proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_comms proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->module~od_comms proc~jdos_calculate jdos_calculate proc~jdos_calculate->module~od_comms proc~make_weights make_weights proc~make_weights->module~od_comms proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->module~od_comms proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->module~od_comms program~od2od od2od program~od2od->module~od_comms program~optados optados program~optados->module~od_comms proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->module~od_comms proc~optics_calculate optics_calculate proc~optics_calculate->module~od_comms proc~dos_calculate dos_calculate proc~dos_calculate->module~od_comms proc~cell_dist cell_dist proc~cell_dist->module~od_comms proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->module~od_comms proc~core_calculate core_calculate proc~core_calculate->module~od_comms proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->module~od_comms proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_comms proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->module~od_comms proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->module~od_comms proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->module~od_comms proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->module~od_comms proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->module~od_comms proc~calc_epsilon_1 calc_epsilon_1 proc~calc_epsilon_1->module~od_comms proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->module~od_comms proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->module~od_comms proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_comms proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_comms proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->module~od_comms proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_comms proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->module~od_comms Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables my_node_id num_nodes on_root root_id Interfaces comms_bcast comms_recv comms_reduce comms_send Subroutines comms_end comms_setup Variables Type Visibility Attributes Name Initial integer, public, save :: my_node_id integer, public, save :: num_nodes logical, public, save :: on_root integer, public, parameter :: root_id = 0 Interfaces public        interface comms_bcast private  subroutine comms_bcast_int(array, size) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_logical(array, size) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_real(array, size) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_cmplx(array, size) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size private  subroutine comms_bcast_char(array, size) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array integer, intent(in) :: size public        interface comms_recv private  subroutine comms_recv_int(array, size, from) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_logical(array, size, from) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_real(array, size, from) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_cmplx(array, size, from) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from private  subroutine comms_recv_char(array, size, from) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: from public        interface comms_reduce private  subroutine comms_reduce_int(array, size, op) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size character(len=*), intent(in) :: op private  subroutine comms_reduce_real(array, size, op) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size character(len=*), intent(in) :: op private  subroutine comms_reduce_cmplx(array, size, op) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size character(len=*), intent(in) :: op public        interface comms_send private  subroutine comms_send_int(array, size, to) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_logical(array, size, to) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_real(array, size, to) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_cmplx(array, size, to) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to private  subroutine comms_send_char(array, size, to) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array integer, intent(in) :: size integer, intent(in) :: to Subroutines public  subroutine comms_end () Arguments None public  subroutine comms_setup () Arguments None","tags":"","loc":"module/od_comms.html"},{"title":"od_electronic – OptaDOS","text":"Uses od_constants module~~od_electronic~~UsesGraph module~od_electronic od_electronic module~od_constants od_constants module~od_electronic->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_electronic~~UsedByGraph module~od_electronic od_electronic proc~write_pdos_bin write_pdos_bin proc~write_pdos_bin->module~od_electronic proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->module~od_electronic proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_electronic module~od_dos_utils od_dos_utils proc~jdos_utils_calculate->module~od_dos_utils proc~allocate_jdos allocate_jdos proc~allocate_jdos->module~od_electronic proc~write_fem_bin write_fem_bin proc~write_fem_bin->module~od_electronic proc~write_pdos_fmt write_pdos_fmt proc~write_pdos_fmt->module~od_electronic proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->module~od_electronic proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->module~od_electronic proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->module~od_electronic module~od_dos_utils->module~od_electronic proc~projection_merge projection_merge proc~projection_merge->module~od_electronic proc~projection_analyse_orbitals projection_analyse_orbitals proc~projection_analyse_orbitals->module~od_electronic proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_electronic proc~calculate_jdos->module~od_dos_utils proc~pad_an_ome pad_an_ome proc~pad_an_ome->module~od_electronic proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->module~od_electronic proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->module~od_electronic proc~dos_calculate dos_calculate proc~dos_calculate->module~od_electronic proc~dos_calculate->module~od_dos_utils proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->module~od_electronic proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->module~od_electronic proc~make_weights make_weights proc~make_weights->module~od_electronic proc~write_conduct write_conduct proc~write_conduct->module~od_electronic proc~core_calculate core_calculate proc~core_calculate->module~od_electronic proc~core_calculate->module~od_dos_utils proc~write_dos write_dos proc~write_dos->module~od_electronic proc~write_dos->module~od_dos_utils proc~write_absorp write_absorp proc~write_absorp->module~od_electronic proc~write_epsilon write_epsilon proc~write_epsilon->module~od_electronic proc~write_refract write_refract proc~write_refract->module~od_electronic proc~optics_calculate optics_calculate proc~optics_calculate->module~od_electronic proc~optics_calculate->module~od_dos_utils proc~write_loss_fn write_loss_fn proc~write_loss_fn->module~od_electronic proc~read_ome_fmt read_ome_fmt proc~read_ome_fmt->module~od_electronic proc~report_arraysize report_arraysize proc~report_arraysize->module~od_electronic proc~write_dome_fmt write_dome_fmt proc~write_dome_fmt->module~od_electronic program~optados optados program~optados->module~od_electronic proc~slice_an_ome slice_an_ome proc~slice_an_ome->module~od_electronic module~od_conv od_conv module~od_conv->module~od_electronic proc~write_fem_fmt write_fem_fmt proc~write_fem_fmt->module~od_electronic proc~write_ome_bin write_ome_bin proc~write_ome_bin->module~od_electronic proc~read_fem_fmt read_fem_fmt proc~read_fem_fmt->module~od_electronic proc~write_dome_bin write_dome_bin proc~write_dome_bin->module~od_electronic proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_electronic proc~pdos_calculate->module~od_dos_utils proc~write_elnes_bin write_elnes_bin proc~write_elnes_bin->module~od_electronic proc~write_elnes_fmt write_elnes_fmt proc~write_elnes_fmt->module~od_electronic proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->module~od_electronic proc~write_ome_fmt write_ome_fmt proc~write_ome_fmt->module~od_electronic proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->module~od_electronic proc~read_dome_fmt read_dome_fmt proc~read_dome_fmt->module~od_electronic proc~write_reflect write_reflect proc~write_reflect->module~od_electronic proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_electronic proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_electronic proc~read_elnes_fmt read_elnes_fmt proc~read_elnes_fmt->module~od_electronic proc~write_jdos write_jdos proc~write_jdos->module~od_electronic proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_electronic proc~setup_energy_scale->module~od_dos_utils proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->module~od_electronic program~od2od od2od program~od2od->module~od_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables all_kpoint_weight all_kpoints all_pdos_weights band_curvature band_energy band_gradient domefile_header domefile_version efermi efermi_castep efermi_set electrons_per_state elnes_mat elnes_mwab elnes_orbital elnesfile_header elnesfile_version femfile_header foptical_mat nbands nbands_occ nspins num_electrons omefile_header omefile_version optical_mat pdos_mwab pdos_orbital pdos_weights pdosfile_header pdosfile_version spin_polarised unshifted_efermi Derived Types matrix_weights_array_boundaries orbitals Subroutines elec_dealloc_band_gradient elec_dealloc_elnes elec_dealloc_optical elec_dealloc_pdos elec_elnes_find_channel_names elec_elnes_find_channel_numbers elec_pdis_read elec_pdos_read elec_read_band_curvature elec_read_band_energy elec_read_band_energy_ordered elec_read_band_gradient elec_read_elnes_mat elec_read_foptical_mat elec_read_optical_mat elec_report_parameters Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable, save :: all_kpoint_weight (:) real(kind=dp), public, allocatable, save :: all_kpoints (:,:) real(kind=dp), public, allocatable :: all_pdos_weights (:,:,:,:) real(kind=dp), public, allocatable, save :: band_curvature (:,:,:,:,:) real(kind=dp), public, allocatable, save :: band_energy (:,:,:) real(kind=dp), public, allocatable, save :: band_gradient (:,:,:,:) character(len=80), public, save :: domefile_header integer, public, save :: domefile_version real(kind=dp), public, save :: efermi real(kind=dp), public, save :: efermi_castep logical, public, save :: efermi_set = .false. real(kind=dp), public, save :: electrons_per_state complex(kind=dp), public, allocatable, save :: elnes_mat (:,:,:,:,:) type( matrix_weights_array_boundaries ), public, save :: elnes_mwab type( orbitals ), public, save :: elnes_orbital character(len=80), public, save :: elnesfile_header integer, public, save :: elnesfile_version character(len=80), public, save :: femfile_header complex(kind=dp), public, allocatable, save :: foptical_mat (:,:,:,:,:) integer, public, save :: nbands integer, public, allocatable, save :: nbands_occ (:,:) integer, public, save :: nspins real(kind=dp), public, allocatable, save :: num_electrons (:) character(len=80), public, save :: omefile_header integer, public, save :: omefile_version complex(kind=dp), public, allocatable, save :: optical_mat (:,:,:,:,:) type( matrix_weights_array_boundaries ), public, save :: pdos_mwab type( orbitals ), public, save :: pdos_orbital real(kind=dp), public, allocatable, save :: pdos_weights (:,:,:,:) character(len=80), public, save :: pdosfile_header integer, public, save :: pdosfile_version logical, public, save :: spin_polarised real(kind=dp), public, save :: unshifted_efermi Derived Types type, public :: matrix_weights_array_boundaries Components Type Visibility Attributes Name Initial integer, public :: nbands integer, public :: nkpoints integer, public :: norbitals integer, public :: nspins type, public :: orbitals Components Type Visibility Attributes Name Initial integer, public, allocatable :: am_channel (:) character(len=10), public, allocatable :: am_channel_name (:) integer, public, allocatable :: ion_no (:) integer, public, allocatable :: rank_in_species (:) integer, public, allocatable :: shell (:) integer, public, allocatable :: species_no (:) Subroutines public  subroutine elec_dealloc_band_gradient () Arguments None public  subroutine elec_dealloc_elnes () Arguments None public  subroutine elec_dealloc_optical () Arguments None public  subroutine elec_dealloc_pdos () Arguments None public  subroutine elec_elnes_find_channel_names () Arguments None public  subroutine elec_elnes_find_channel_numbers () Arguments None public  subroutine elec_pdis_read () Arguments None public  subroutine elec_pdos_read () Arguments None public  subroutine elec_read_band_curvature () Arguments None public  subroutine elec_read_band_energy () Arguments None public  subroutine elec_read_band_energy_ordered () Arguments None public  subroutine elec_read_band_gradient () Arguments None public  subroutine elec_read_elnes_mat () Arguments None public  subroutine elec_read_foptical_mat () Arguments None public  subroutine elec_read_optical_mat () Arguments None public  subroutine elec_report_parameters () Arguments None","tags":"","loc":"module/od_electronic.html"},{"title":"od_io – OptaDOS","text":"Uses od_constants module~~od_io~~UsesGraph module~od_io od_io module~od_constants od_constants module~od_io->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_io~~UsedByGraph module~od_io od_io proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_io module~od_parameters od_parameters proc~jdos_utils_calculate->module~od_parameters module~od_cell od_cell proc~jdos_utils_calculate->module~od_cell module~od_parameters->module~od_io module~od_parameters->module~od_cell proc~projection_get_string projection_get_string proc~projection_get_string->module~od_io proc~projection_get_string->module~od_parameters proc~projection_get_string->module~od_cell proc~projection_merge projection_merge proc~projection_merge->module~od_io proc~projection_merge->module~od_cell proc~cell_find_mp_grid cell_find_MP_grid proc~cell_find_mp_grid->module~od_io proc~make_weights make_weights proc~make_weights->module~od_io proc~make_weights->module~od_parameters proc~make_weights->module~od_cell proc~write_elnes_bin write_elnes_bin proc~write_elnes_bin->module~od_io proc~write_elnes_bin->module~od_cell proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->module~od_io proc~elec_read_elnes_mat->module~od_parameters proc~elec_read_elnes_mat->module~od_cell proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->module~od_io proc~elec_read_band_curvature->module~od_parameters proc~elec_read_band_curvature->module~od_cell proc~elec_report_parameters elec_report_parameters proc~elec_report_parameters->module~od_io proc~elec_report_parameters->module~od_parameters proc~elec_report_parameters->module~od_cell program~optados optados program~optados->module~od_io program~optados->module~od_parameters program~optados->module~od_cell proc~write_epsilon write_epsilon proc~write_epsilon->module~od_io proc~write_epsilon->module~od_parameters proc~write_epsilon->module~od_cell proc~write_elnes_fmt write_elnes_fmt proc~write_elnes_fmt->module~od_io proc~write_elnes_fmt->module~od_cell proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->module~od_io proc~write_ome_bin write_ome_bin proc~write_ome_bin->module~od_io proc~write_ome_bin->module~od_cell proc~projection_analyse_orbitals projection_analyse_orbitals proc~projection_analyse_orbitals->module~od_io proc~projection_analyse_orbitals->module~od_cell proc~write_reflect write_reflect proc~write_reflect->module~od_io proc~write_reflect->module~od_parameters proc~write_reflect->module~od_cell program~od2od od2od program~od2od->module~od_io module~od_conv od_conv program~od2od->module~od_conv proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->module~od_io proc~dos_utils_calculate->module~od_parameters proc~dos_utils_calculate->module~od_cell proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_io proc~pdis_calculate->module~od_parameters proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_io proc~calc_epsilon_2->module~od_parameters proc~calc_epsilon_2->module~od_cell proc~conv_get_seedname conv_get_seedname proc~conv_get_seedname->module~od_io proc~utility_lowercase utility_lowercase proc~utility_lowercase->module~od_io proc~param_dist param_dist proc~param_dist->module~od_io proc~param_read param_read proc~param_read->module~od_io proc~param_read->module~od_cell proc~xmgu_data xmgu_data proc~xmgu_data->module~od_io proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->module~od_io proc~dos_utils_compute_bandgap->module~od_parameters proc~dos_utils_compute_bandgap->module~od_cell proc~cell_get_real_lattice cell_get_real_lattice proc~cell_get_real_lattice->module~od_io module~od_cell->module~od_io proc~write_conduct write_conduct proc~write_conduct->module~od_io proc~write_conduct->module~od_parameters proc~write_conduct->module~od_cell proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->module~od_io proc~elec_pdis_read->module~od_parameters proc~elec_pdis_read->module~od_cell proc~report_arraysize report_arraysize proc~report_arraysize->module~od_io proc~report_arraysize->module~od_cell proc~write_fem_fmt write_fem_fmt proc~write_fem_fmt->module~od_io proc~write_fem_fmt->module~od_cell proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->module~od_io proc~elec_read_foptical_mat->module~od_parameters proc~elec_read_foptical_mat->module~od_cell proc~cell_report_parameters cell_report_parameters proc~cell_report_parameters->module~od_io proc~xmgu_setup xmgu_setup proc~xmgu_setup->module~od_io proc~dos_utils_deallocate dos_utils_deallocate proc~dos_utils_deallocate->module~od_io proc~read_ome_fmt read_ome_fmt proc~read_ome_fmt->module~od_io proc~read_ome_fmt->module~od_cell proc~optics_calculate optics_calculate proc~optics_calculate->module~od_io proc~optics_calculate->module~od_parameters proc~optics_calculate->module~od_cell proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_io proc~calculate_jdos->module~od_parameters proc~calculate_jdos->module~od_cell proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->module~od_io proc~elec_read_band_energy_ordered->module~od_parameters proc~elec_read_band_energy_ordered->module~od_cell proc~dos_calculate dos_calculate proc~dos_calculate->module~od_io proc~dos_calculate->module~od_parameters proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_elnes_find_channel_names->module~od_io proc~core_calculate core_calculate proc~core_calculate->module~od_io proc~core_calculate->module~od_parameters proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->module~od_io proc~elec_pdos_read->module~od_parameters proc~elec_pdos_read->module~od_cell proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_io proc~pdos_calculate->module~od_parameters proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->module~od_io proc~write_fem_bin write_fem_bin proc~write_fem_bin->module~od_io proc~write_fem_bin->module~od_cell proc~write_pdos_fmt write_pdos_fmt proc~write_pdos_fmt->module~od_io proc~write_pdos_fmt->module~od_cell proc~jdos_calculate jdos_calculate proc~jdos_calculate->module~od_io proc~jdos_calculate->module~od_parameters proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->module~od_io proc~dos_utils_calculate_at_e->module~od_parameters proc~dos_utils_calculate_at_e->module~od_cell proc~cell_get_symmetry cell_get_symmetry proc~cell_get_symmetry->module~od_io proc~write_absorp write_absorp proc~write_absorp->module~od_io proc~write_absorp->module~od_parameters proc~write_absorp->module~od_cell proc~read_elnes_fmt read_elnes_fmt proc~read_elnes_fmt->module~od_io proc~read_elnes_fmt->module~od_cell proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->module~od_io proc~elec_read_optical_mat->module~od_parameters proc~elec_read_optical_mat->module~od_cell proc~write_ome_fmt write_ome_fmt proc~write_ome_fmt->module~od_io proc~write_ome_fmt->module~od_cell proc~cell_read_cell cell_read_cell proc~cell_read_cell->module~od_io proc~write_refract write_refract proc~write_refract->module~od_io proc~write_refract->module~od_parameters proc~write_refract->module~od_cell proc~write_dome_fmt write_dome_fmt proc~write_dome_fmt->module~od_io proc~write_dome_fmt->module~od_cell proc~read_fem_fmt read_fem_fmt proc~read_fem_fmt->module~od_io proc~read_fem_fmt->module~od_cell proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->module~od_io proc~elec_read_band_energy->module~od_parameters proc~elec_read_band_energy->module~od_cell proc~elec_dealloc_elnes elec_dealloc_elnes proc~elec_dealloc_elnes->module~od_io proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->module~od_io proc~dos_utils_set_efermi->module~od_parameters proc~dos_utils_set_efermi->module~od_cell proc~read_dome_fmt read_dome_fmt proc~read_dome_fmt->module~od_io proc~read_dome_fmt->module~od_cell proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->module~od_io proc~write_jdos write_jdos proc~write_jdos->module~od_io proc~write_jdos->module~od_parameters proc~allocate_jdos allocate_jdos proc~allocate_jdos->module~od_io proc~allocate_jdos->module~od_parameters proc~write_pdos_bin write_pdos_bin proc~write_pdos_bin->module~od_io proc~write_pdos_bin->module~od_cell proc~pad_an_ome pad_an_ome proc~pad_an_ome->module~od_io proc~pad_an_ome->module~od_cell proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->module~od_io proc~read_pdos_fmt->module~od_cell proc~algor_dist_array algor_dist_array proc~algor_dist_array->module~od_io proc~write_dome_bin write_dome_bin proc~write_dome_bin->module~od_io proc~write_dome_bin->module~od_cell proc~elec_dealloc_pdos elec_dealloc_pdos proc~elec_dealloc_pdos->module~od_io proc~calc_epsilon_1 calc_epsilon_1 proc~calc_epsilon_1->module~od_io proc~calc_epsilon_1->module~od_parameters proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_io proc~setup_energy_scale->module~od_parameters proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->module~od_io proc~dos_utils_compute_band_energies->module~od_parameters proc~dos_utils_compute_band_energies->module~od_cell proc~write_dos write_dos proc~write_dos->module~od_io proc~write_dos->module~od_parameters module~od_conv->module~od_io module~od_conv->module~od_parameters proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->module~od_io proc~write_dos_xmgrace->module~od_parameters proc~elec_dealloc_optical elec_dealloc_optical proc~elec_dealloc_optical->module~od_io proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->module~od_io proc~elec_read_band_gradient->module~od_parameters proc~elec_read_band_gradient->module~od_cell proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->module~od_io proc~dos_utils_compute_dos_at_efermi->module~od_parameters proc~write_loss_fn write_loss_fn proc~write_loss_fn->module~od_io proc~write_loss_fn->module~od_parameters proc~write_loss_fn->module~od_cell proc~slice_an_ome slice_an_ome proc~slice_an_ome->module~od_io proc~slice_an_ome->module~od_cell proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~elec_elnes_find_channel_numbers->module~od_io proc~cell_dist cell_dist proc~cell_dist->module~od_io proc~elec_dealloc_band_gradient elec_dealloc_band_gradient proc~elec_dealloc_band_gradient->module~od_io proc~jdos_deallocate jdos_deallocate proc~jdos_deallocate->module~od_io proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->module~od_parameters proc~calc_loss_fn calc_loss_fn proc~calc_loss_fn->module~od_parameters proc~calc_loss_fn->module~od_cell proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->module~od_parameters proc~calc_refract calc_refract proc~calc_refract->module~od_parameters proc~calc_conduct calc_conduct proc~calc_conduct->module~od_parameters proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~doslin_sub_cell_corners->module~od_cell Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables filename_len maxlen options seedname stderr stdout temp_dir Functions io_file_unit io_time Subroutines io_date io_error io_get_seedname Variables Type Visibility Attributes Name Initial integer, public, parameter :: filename_len = 80 integer, public, parameter :: maxlen = 120 character(len=filename_len), public, save :: options character(len=filename_len), public, save :: seedname integer, public, save :: stderr integer, public, save :: stdout character(len=filename_len), public, save :: temp_dir Functions public  function io_file_unit () Arguments None Return Value integer public  function io_time () Arguments None Return Value real(kind=dp) Subroutines public  subroutine io_date (cdate, ctime) Arguments Type Intent Optional Attributes Name character(len=11), intent(out) :: cdate character(len=9), intent(out) :: ctime public  subroutine io_error (error_msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_msg public  subroutine io_get_seedname () Arguments None","tags":"","loc":"module/od_io.html"},{"title":"od_pdis – OptaDOS","text":"Uses od_projection_utils od_constants module~~od_pdis~~UsesGraph module~od_pdis od_pdis module~od_projection_utils od_projection_utils module~od_pdis->module~od_projection_utils module~od_constants od_constants module~od_pdis->module~od_constants module~od_projection_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_pdis~~UsedByGraph module~od_pdis od_pdis program~optados optados program~optados->module~od_pdis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines pdis_calculate Subroutines public  subroutine pdis_calculate () Arguments None","tags":"","loc":"module/od_pdis.html"},{"title":"od_dos – OptaDOS","text":"Uses od_constants module~~od_dos~~UsesGraph module~od_dos od_dos module~od_constants od_constants module~od_dos->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~od_dos~~UsedByGraph module~od_dos od_dos program~optados optados program~optados->module~od_dos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines dos_calculate write_dos write_dos_xmgrace Subroutines public  subroutine dos_calculate () $\n$    unshifted_efermi=efermi\n$\n$    if(set_efermi_zero) then\n$       if(on_root) then\n$          write(stdout,*)\n$          write(stdout,'(1x,a71)')  '+----------------------- Shift Fermi Energy --------------------------+'\n$          write(stdout,'(1x,a1,a46,a24)')\"|\", \" Setting Fermi energy to 0 : \",\"|\"\n$       endif\n$       E(:)=E(:)-efermi\n$       band_energy(:,:,:) = band_energy(:,:,:) - efermi\n$       efermi=0.0_dp\n$    endif\n$\n$    if(on_root) then\n$       write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)')\"|\", \" Fermi energy used : \", unshifted_efermi,\"eV\",\"| <- Ef \"\n$       write(stdout,'(1x,a71)')  '+---------------------------------------------------------------------+'\n$\n$       time1=io_time()\n$       write(stdout,'(1x,a40,f11.3,a)') 'Time to perfom analysis ',time1-time0,' (sec)'\n$       !-------------------------------------------------------------------------------\n$    end if Arguments None public  subroutine write_dos (E, dos, intdos, dos_name) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: E (dos_nbins) real(kind=dp), intent(in) :: dos (dos_nbins,nspins) real(kind=dp), intent(in) :: intdos (dos_nbins,nspins) character(len=*), intent(in) :: dos_name public  subroutine write_dos_xmgrace (dos_name, E, dos) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dos_name real(kind=dp), intent(in) :: E (dos_nbins) real(kind=dp), intent(in) :: dos (dos_nbins,nspins)","tags":"","loc":"module/od_dos.html"},{"title":"od_constants – OptaDOS","text":"Used by module~~od_constants~~UsedByGraph module~od_constants od_constants module~od_io od_io module~od_io->module~od_constants module~od_electronic od_electronic module~od_electronic->module~od_constants module~od_comms od_comms module~od_comms->module~od_constants module~od_projection_utils od_projection_utils module~od_projection_utils->module~od_constants proc~write_fem_bin write_fem_bin proc~write_fem_bin->module~od_constants proc~write_fem_bin->module~od_io proc~write_fem_bin->module~od_electronic module~od_cell od_cell proc~write_fem_bin->module~od_cell proc~param_read param_read proc~param_read->module~od_constants proc~param_read->module~od_io proc~param_read->module~od_cell proc~xmgu_vertical_line xmgu_vertical_line proc~xmgu_vertical_line->module~od_constants proc~utility_reciprocal_cart_to_frac utility_reciprocal_cart_to_frac proc~utility_reciprocal_cart_to_frac->module~od_constants proc~elec_read_optical_mat elec_read_optical_mat proc~elec_read_optical_mat->module~od_constants proc~elec_read_optical_mat->module~od_io proc~elec_read_optical_mat->module~od_comms module~od_parameters od_parameters proc~elec_read_optical_mat->module~od_parameters proc~elec_read_optical_mat->module~od_cell module~od_algorithms od_algorithms proc~elec_read_optical_mat->module~od_algorithms proc~version_output version_output proc~version_output->module~od_constants proc~my_zcopy my_ZCOPY proc~my_zcopy->module~od_constants module~od_parameters->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell proc~xmgu_data xmgu_data proc~xmgu_data->module~od_constants proc~xmgu_data->module~od_io proc~projection_analyse_orbitals projection_analyse_orbitals proc~projection_analyse_orbitals->module~od_constants proc~projection_analyse_orbitals->module~od_io proc~projection_analyse_orbitals->module~od_electronic proc~projection_analyse_orbitals->module~od_cell proc~write_pdos_bin write_pdos_bin proc~write_pdos_bin->module~od_constants proc~write_pdos_bin->module~od_io proc~write_pdos_bin->module~od_electronic proc~write_pdos_bin->module~od_cell proc~cell_get_real_lattice cell_get_real_lattice proc~cell_get_real_lattice->module~od_constants proc~cell_get_real_lattice->module~od_io proc~cell_get_real_lattice->module~od_comms proc~elec_read_band_energy_ordered elec_read_band_energy_ordered proc~elec_read_band_energy_ordered->module~od_constants proc~elec_read_band_energy_ordered->module~od_io proc~elec_read_band_energy_ordered->module~od_comms proc~elec_read_band_energy_ordered->module~od_parameters proc~elec_read_band_energy_ordered->module~od_cell proc~elec_read_band_energy_ordered->module~od_algorithms module~od_dos_utils od_dos_utils module~od_dos_utils->module~od_constants module~od_dos_utils->module~od_electronic proc~pad_an_ome pad_an_ome proc~pad_an_ome->module~od_constants proc~pad_an_ome->module~od_io proc~pad_an_ome->module~od_electronic proc~pad_an_ome->module~od_cell proc~cell_read_cell cell_read_cell proc~cell_read_cell->module~od_constants proc~cell_read_cell->module~od_io proc~cell_read_cell->module~od_algorithms proc~my_dcopy my_DCOPY proc~my_dcopy->module~od_constants module~od_core od_core module~od_core->module~od_constants proc~param_write_header param_write_header proc~param_write_header->module~od_constants proc~elec_read_foptical_mat elec_read_foptical_mat proc~elec_read_foptical_mat->module~od_constants proc~elec_read_foptical_mat->module~od_io proc~elec_read_foptical_mat->module~od_comms proc~elec_read_foptical_mat->module~od_parameters proc~elec_read_foptical_mat->module~od_cell proc~elec_read_foptical_mat->module~od_algorithms proc~make_weights make_weights proc~make_weights->module~od_constants proc~make_weights->module~od_io proc~make_weights->module~od_electronic proc~make_weights->module~od_comms proc~make_weights->module~od_parameters proc~make_weights->module~od_cell module~od_jdos od_jdos module~od_jdos->module~od_constants module~od_cell->module~od_constants module~od_cell->module~od_io proc~elec_read_band_energy elec_read_band_energy proc~elec_read_band_energy->module~od_constants proc~elec_read_band_energy->module~od_io proc~elec_read_band_energy->module~od_comms proc~elec_read_band_energy->module~od_parameters proc~elec_read_band_energy->module~od_cell proc~elec_read_band_energy->module~od_algorithms proc~cell_calc_lattice cell_calc_lattice proc~cell_calc_lattice->module~od_constants module~od_algorithms->module~od_constants proc~utility_cart_to_frac utility_cart_to_frac proc~utility_cart_to_frac->module~od_constants module~od_jdos_utils od_jdos_utils module~od_jdos_utils->module~od_constants module~od_pdos od_pdos module~od_pdos->module~od_constants module~od_pdos->module~od_projection_utils proc~read_ome_fmt read_ome_fmt proc~read_ome_fmt->module~od_constants proc~read_ome_fmt->module~od_io proc~read_ome_fmt->module~od_electronic proc~read_ome_fmt->module~od_cell proc~calculate_jdos calculate_jdos proc~calculate_jdos->module~od_constants proc~calculate_jdos->module~od_io proc~calculate_jdos->module~od_electronic proc~calculate_jdos->module~od_comms proc~calculate_jdos->module~od_parameters proc~calculate_jdos->module~od_dos_utils proc~calculate_jdos->module~od_cell proc~calculate_jdos->module~od_algorithms proc~write_dome_fmt write_dome_fmt proc~write_dome_fmt->module~od_constants proc~write_dome_fmt->module~od_io proc~write_dome_fmt->module~od_electronic proc~write_dome_fmt->module~od_cell proc~xmgu_title xmgu_title proc~xmgu_title->module~od_constants proc~slice_an_ome slice_an_ome proc~slice_an_ome->module~od_constants proc~slice_an_ome->module~od_io proc~slice_an_ome->module~od_electronic proc~slice_an_ome->module~od_cell module~od_conv od_conv module~od_conv->module~od_constants module~od_conv->module~od_io module~od_conv->module~od_electronic module~od_conv->module~od_parameters module~od_dos od_dos module~od_dos->module~od_constants program~od2od od2od program~od2od->module~od_constants program~od2od->module~od_io program~od2od->module~od_comms program~od2od->module~od_conv program~optados optados program~optados->module~od_constants program~optados->module~od_io program~optados->module~od_electronic program~optados->module~od_comms program~optados->module~od_parameters program~optados->module~od_core program~optados->module~od_jdos program~optados->module~od_cell program~optados->module~od_pdos program~optados->module~od_dos module~od_optics od_optics program~optados->module~od_optics module~od_pdis od_pdis program~optados->module~od_pdis proc~write_fem_fmt write_fem_fmt proc~write_fem_fmt->module~od_constants proc~write_fem_fmt->module~od_io proc~write_fem_fmt->module~od_electronic proc~write_fem_fmt->module~od_cell proc~write_ome_bin write_ome_bin proc~write_ome_bin->module~od_constants proc~write_ome_bin->module~od_io proc~write_ome_bin->module~od_electronic proc~write_ome_bin->module~od_cell module~od_optics->module~od_constants proc~write_dome_bin write_dome_bin proc~write_dome_bin->module~od_constants proc~write_dome_bin->module~od_io proc~write_dome_bin->module~od_electronic proc~write_dome_bin->module~od_cell module~od_pdis->module~od_constants module~od_pdis->module~od_projection_utils proc~elec_read_band_curvature elec_read_band_curvature proc~elec_read_band_curvature->module~od_constants proc~elec_read_band_curvature->module~od_io proc~elec_read_band_curvature->module~od_comms proc~elec_read_band_curvature->module~od_parameters proc~elec_read_band_curvature->module~od_cell proc~elec_read_band_curvature->module~od_algorithms proc~cell_get_atoms cell_get_atoms proc~cell_get_atoms->module~od_constants proc~cell_get_atoms->module~od_io proc~cell_get_atoms->module~od_algorithms proc~io_time io_time proc~io_time->module~od_constants proc~write_ome_fmt write_ome_fmt proc~write_ome_fmt->module~od_constants proc~write_ome_fmt->module~od_io proc~write_ome_fmt->module~od_electronic proc~write_ome_fmt->module~od_cell proc~read_dome_fmt read_dome_fmt proc~read_dome_fmt->module~od_constants proc~read_dome_fmt->module~od_io proc~read_dome_fmt->module~od_electronic proc~read_dome_fmt->module~od_cell proc~calc_epsilon_1 calc_epsilon_1 proc~calc_epsilon_1->module~od_constants proc~calc_epsilon_1->module~od_io proc~calc_epsilon_1->module~od_comms proc~calc_epsilon_1->module~od_parameters proc~calc_epsilon_1->module~od_jdos_utils proc~elec_read_band_gradient elec_read_band_gradient proc~elec_read_band_gradient->module~od_constants proc~elec_read_band_gradient->module~od_io proc~elec_read_band_gradient->module~od_comms proc~elec_read_band_gradient->module~od_parameters proc~elec_read_band_gradient->module~od_cell proc~elec_read_band_gradient->module~od_algorithms proc~calc_loss_fn calc_loss_fn proc~calc_loss_fn->module~od_constants proc~calc_loss_fn->module~od_parameters proc~calc_loss_fn->module~od_cell proc~calc_loss_fn->module~od_jdos_utils proc~calc_epsilon_2 calc_epsilon_2 proc~calc_epsilon_2->module~od_constants proc~calc_epsilon_2->module~od_io proc~calc_epsilon_2->module~od_electronic proc~calc_epsilon_2->module~od_comms proc~calc_epsilon_2->module~od_parameters proc~calc_epsilon_2->module~od_cell proc~calc_epsilon_2->module~od_jdos_utils proc~read_fem_fmt read_fem_fmt proc~read_fem_fmt->module~od_constants proc~read_fem_fmt->module~od_io proc~read_fem_fmt->module~od_electronic proc~read_fem_fmt->module~od_cell proc~help_output help_output proc~help_output->module~od_constants proc~elec_report_parameters elec_report_parameters proc~elec_report_parameters->module~od_io proc~elec_report_parameters->module~od_parameters proc~elec_report_parameters->module~od_cell proc~utility_lowercase utility_lowercase proc~utility_lowercase->module~od_io proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos_xmgrace->module~od_io proc~write_jdos_xmgrace->module~od_electronic proc~write_jdos_xmgrace->module~od_jdos_utils proc~write_refract write_refract proc~write_refract->module~od_io proc~write_refract->module~od_electronic proc~write_refract->module~od_parameters proc~write_refract->module~od_cell proc~write_refract->module~od_jdos_utils proc~write_loss_fn write_loss_fn proc~write_loss_fn->module~od_io proc~write_loss_fn->module~od_electronic proc~write_loss_fn->module~od_parameters proc~write_loss_fn->module~od_cell proc~write_loss_fn->module~od_jdos_utils proc~param_dist param_dist proc~param_dist->module~od_io proc~param_dist->module~od_comms proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_utils_compute_bandgap->module~od_io proc~dos_utils_compute_bandgap->module~od_electronic proc~dos_utils_compute_bandgap->module~od_comms proc~dos_utils_compute_bandgap->module~od_parameters proc~dos_utils_compute_bandgap->module~od_cell proc~conv_get_seedname conv_get_seedname proc~conv_get_seedname->module~od_io proc~write_conduct write_conduct proc~write_conduct->module~od_io proc~write_conduct->module~od_electronic proc~write_conduct->module~od_parameters proc~write_conduct->module~od_cell proc~write_conduct->module~od_jdos_utils proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_utils_calculate->module~od_io proc~jdos_utils_calculate->module~od_electronic proc~jdos_utils_calculate->module~od_comms proc~jdos_utils_calculate->module~od_parameters proc~jdos_utils_calculate->module~od_dos_utils proc~jdos_utils_calculate->module~od_cell proc~projection_get_string projection_get_string proc~projection_get_string->module~od_io proc~projection_get_string->module~od_parameters proc~projection_get_string->module~od_cell proc~write_elnes_bin write_elnes_bin proc~write_elnes_bin->module~od_io proc~write_elnes_bin->module~od_electronic proc~write_elnes_bin->module~od_cell proc~projection_merge projection_merge proc~projection_merge->module~od_io proc~projection_merge->module~od_electronic proc~projection_merge->module~od_comms proc~projection_merge->module~od_cell proc~cell_find_mp_grid cell_find_MP_grid proc~cell_find_mp_grid->module~od_io proc~elec_read_elnes_mat elec_read_elnes_mat proc~elec_read_elnes_mat->module~od_io proc~elec_read_elnes_mat->module~od_comms proc~elec_read_elnes_mat->module~od_parameters proc~elec_read_elnes_mat->module~od_cell proc~write_pdos_fmt write_pdos_fmt proc~write_pdos_fmt->module~od_io proc~write_pdos_fmt->module~od_electronic proc~write_pdos_fmt->module~od_cell proc~allocate_jdos allocate_jdos proc~allocate_jdos->module~od_io proc~allocate_jdos->module~od_electronic proc~allocate_jdos->module~od_parameters proc~cell_dist cell_dist proc~cell_dist->module~od_io proc~cell_dist->module~od_comms proc~elec_dealloc_band_gradient elec_dealloc_band_gradient proc~elec_dealloc_band_gradient->module~od_io proc~dos_utils_merge dos_utils_merge proc~dos_utils_merge->module~od_electronic proc~dos_utils_merge->module~od_comms proc~dos_utils_merge->module~od_parameters proc~jdos_calculate jdos_calculate proc~jdos_calculate->module~od_io proc~jdos_calculate->module~od_comms proc~jdos_calculate->module~od_parameters proc~jdos_calculate->module~od_jdos_utils proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~dos_utils_calculate_at_e->module~od_io proc~dos_utils_calculate_at_e->module~od_electronic proc~dos_utils_calculate_at_e->module~od_comms proc~dos_utils_calculate_at_e->module~od_parameters proc~dos_utils_calculate_at_e->module~od_cell proc~cell_get_symmetry cell_get_symmetry proc~cell_get_symmetry->module~od_io proc~cell_get_symmetry->module~od_comms proc~read_pdos_fmt read_pdos_fmt proc~read_pdos_fmt->module~od_io proc~read_pdos_fmt->module~od_electronic proc~read_pdos_fmt->module~od_comms proc~read_pdos_fmt->module~od_cell proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_utils_compute_band_energies->module~od_io proc~dos_utils_compute_band_energies->module~od_electronic proc~dos_utils_compute_band_energies->module~od_comms proc~dos_utils_compute_band_energies->module~od_parameters proc~dos_utils_compute_band_energies->module~od_cell proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~doslin_sub_cell_corners->module~od_cell proc~doslin_sub_cell_corners->module~od_algorithms proc~dos_calculate dos_calculate proc~dos_calculate->module~od_io proc~dos_calculate->module~od_electronic proc~dos_calculate->module~od_comms proc~dos_calculate->module~od_parameters proc~dos_calculate->module~od_dos_utils proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_merge->module~od_electronic proc~jdos_utils_merge->module~od_comms proc~jdos_utils_merge->module~od_parameters proc~calc_conduct calc_conduct proc~calc_conduct->module~od_parameters proc~calc_conduct->module~od_jdos_utils proc~calc_reflect calc_reflect proc~calc_reflect->module~od_jdos_utils proc~calc_absorp calc_absorp proc~calc_absorp->module~od_jdos_utils proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_elnes_find_channel_names->module~od_io proc~core_calculate core_calculate proc~core_calculate->module~od_io proc~core_calculate->module~od_electronic proc~core_calculate->module~od_comms proc~core_calculate->module~od_parameters proc~core_calculate->module~od_dos_utils proc~elec_pdos_read elec_pdos_read proc~elec_pdos_read->module~od_io proc~elec_pdos_read->module~od_comms proc~elec_pdos_read->module~od_parameters proc~elec_pdos_read->module~od_cell proc~write_absorp write_absorp proc~write_absorp->module~od_io proc~write_absorp->module~od_electronic proc~write_absorp->module~od_parameters proc~write_absorp->module~od_cell proc~write_absorp->module~od_jdos_utils proc~write_dos write_dos proc~write_dos->module~od_io proc~write_dos->module~od_electronic proc~write_dos->module~od_parameters proc~write_dos->module~od_dos_utils proc~algor_dist_array algor_dist_array proc~algor_dist_array->module~od_io proc~algor_dist_array->module~od_comms proc~calc_refract calc_refract proc~calc_refract->module~od_parameters proc~calc_refract->module~od_jdos_utils proc~cell_report_parameters cell_report_parameters proc~cell_report_parameters->module~od_io proc~elec_dealloc_optical elec_dealloc_optical proc~elec_dealloc_optical->module~od_io proc~write_epsilon write_epsilon proc~write_epsilon->module~od_io proc~write_epsilon->module~od_electronic proc~write_epsilon->module~od_parameters proc~write_epsilon->module~od_cell proc~write_epsilon->module~od_jdos_utils proc~write_elnes_fmt write_elnes_fmt proc~write_elnes_fmt->module~od_io proc~write_elnes_fmt->module~od_electronic proc~write_elnes_fmt->module~od_cell proc~write_reflect write_reflect proc~write_reflect->module~od_io proc~write_reflect->module~od_electronic proc~write_reflect->module~od_parameters proc~write_reflect->module~od_cell proc~write_reflect->module~od_jdos_utils proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos_xmgrace->module~od_io proc~write_dos_xmgrace->module~od_electronic proc~write_dos_xmgrace->module~od_parameters proc~elec_pdis_read elec_pdis_read proc~elec_pdis_read->module~od_io proc~elec_pdis_read->module~od_comms proc~elec_pdis_read->module~od_parameters proc~elec_pdis_read->module~od_cell proc~report_arraysize report_arraysize proc~report_arraysize->module~od_io proc~report_arraysize->module~od_electronic proc~report_arraysize->module~od_cell proc~xmgu_setup xmgu_setup proc~xmgu_setup->module~od_io proc~dos_utils_deallocate dos_utils_deallocate proc~dos_utils_deallocate->module~od_io proc~optics_calculate optics_calculate proc~optics_calculate->module~od_io proc~optics_calculate->module~od_electronic proc~optics_calculate->module~od_comms proc~optics_calculate->module~od_parameters proc~optics_calculate->module~od_dos_utils proc~optics_calculate->module~od_cell proc~optics_calculate->module~od_jdos_utils proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~elec_elnes_find_channel_numbers->module~od_io proc~elec_dealloc_pdos elec_dealloc_pdos proc~elec_dealloc_pdos->module~od_io proc~pdos_calculate pdos_calculate proc~pdos_calculate->module~od_io proc~pdos_calculate->module~od_electronic proc~pdos_calculate->module~od_comms proc~pdos_calculate->module~od_projection_utils proc~pdos_calculate->module~od_parameters proc~pdos_calculate->module~od_dos_utils proc~dos_utils_calculate dos_utils_calculate proc~dos_utils_calculate->module~od_io proc~dos_utils_calculate->module~od_electronic proc~dos_utils_calculate->module~od_comms proc~dos_utils_calculate->module~od_parameters proc~dos_utils_calculate->module~od_cell proc~elec_dealloc_elnes elec_dealloc_elnes proc~elec_dealloc_elnes->module~od_io proc~jdos_deallocate jdos_deallocate proc~jdos_deallocate->module~od_io proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_utils_set_efermi->module~od_io proc~dos_utils_set_efermi->module~od_electronic proc~dos_utils_set_efermi->module~od_comms proc~dos_utils_set_efermi->module~od_parameters proc~dos_utils_set_efermi->module~od_cell proc~cell_calc_kpoint_r_cart cell_calc_kpoint_r_cart proc~cell_calc_kpoint_r_cart->module~od_io proc~cell_calc_kpoint_r_cart->module~od_comms proc~cell_calc_kpoint_r_cart->module~od_algorithms proc~pdis_calculate pdis_calculate proc~pdis_calculate->module~od_io proc~pdis_calculate->module~od_electronic proc~pdis_calculate->module~od_comms proc~pdis_calculate->module~od_projection_utils proc~pdis_calculate->module~od_parameters proc~read_elnes_fmt read_elnes_fmt proc~read_elnes_fmt->module~od_io proc~read_elnes_fmt->module~od_electronic proc~read_elnes_fmt->module~od_cell proc~write_jdos write_jdos proc~write_jdos->module~od_io proc~write_jdos->module~od_electronic proc~write_jdos->module~od_parameters proc~write_jdos->module~od_jdos_utils proc~setup_energy_scale setup_energy_scale proc~setup_energy_scale->module~od_io proc~setup_energy_scale->module~od_electronic proc~setup_energy_scale->module~od_comms proc~setup_energy_scale->module~od_parameters proc~setup_energy_scale->module~od_dos_utils proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_utils_compute_dos_at_efermi->module~od_io proc~dos_utils_compute_dos_at_efermi->module~od_electronic proc~dos_utils_compute_dos_at_efermi->module~od_comms proc~dos_utils_compute_dos_at_efermi->module~od_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables H2eV b_factor bohr2ang boltzmann c_speed cmplx_0 cmplx_i copyright deg_to_rad dp e_charge e_mass epsilon_0 epsilon_zero ev_to_hartree ev_to_j hbar inv_sqrt_two_pi j_to_ev kB optados_version p1 p2 p3 p4 periodic_table_name periodic_table_vdw pi q1 q2 q3 q4 rad_to_deg sqrt_two twopi Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: H2eV = 27.21138342902473_dp real(kind=dp), public, parameter :: b_factor = 74.4412181295_dp real(kind=dp), public, parameter :: bohr2ang = 0.52917720859_dp real(kind=dp), public, parameter :: boltzmann = 1.38064852E-23_dp real(kind=dp), public, parameter :: c_speed = 299792458.0_dp complex(kind=dp), public, parameter :: cmplx_0 = (0.0_dp, 0.0_dp) complex(kind=dp), public, parameter :: cmplx_i = (0.0_dp, 1.0_dp) character(len=14), public, parameter :: copyright = \" (c) 2010-2022\" real(kind=dp), public, parameter :: deg_to_rad = 0.0174532925_dp integer, public, parameter :: dp = selected_real_kind(15, 300) real(kind=dp), public, parameter :: e_charge = 1.602176487E-19_dp real(kind=dp), public, parameter :: e_mass = 9.10938215E-31_dp real(kind=dp), public, parameter :: epsilon_0 = 8.8541878176E-12_dp real(kind=dp), public, parameter :: epsilon_zero = 55.26349406_dp real(kind=dp), public, parameter :: ev_to_hartree = 0.03674932379_dp real(kind=dp), public, parameter :: ev_to_j = 1.602176565E-19_dp real(kind=dp), public, parameter :: hbar = 1.054571628E-34_dp real(kind=dp), public, parameter :: inv_sqrt_two_pi = 0.3989422804014326779399460599_dp real(kind=dp), public, parameter :: j_to_ev = 6.24150934E+18_dp real(kind=dp), public, parameter :: kB = 8.617333262E-5_dp character(len=6), public, parameter :: optados_version = \" 1.3 \" real(kind=dp), public, parameter :: p1 = 0.03270530446_dp real(kind=dp), public, parameter :: p2 = 0.009157798739_dp real(kind=dp), public, parameter :: p3 = 0.002644272807_dp real(kind=dp), public, parameter :: p4 = 0.00008987173811_dp character(len=3), public, parameter,               dimension(109) :: periodic_table_name = (/'H ', 'He', 'Li', 'Be', 'B ', 'C ', 'N ', 'O ', 'F ', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P ', 'S ', 'Cl', 'Ar', 'K ', 'Ca', 'Sc', 'Ti', 'V ', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y ', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I ', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W ', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U ', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt'/) real(kind=dp), public, parameter,               dimension(109) :: periodic_table_vdw = (/1.20_dp, 1.43_dp, 2.12_dp, 1.98_dp, 1.91_dp, 1.77_dp, 1.66_dp, 1.50_dp, 1.46_dp, 1.58_dp, 2.50_dp, 2.51_dp, 2.25_dp, 2.19_dp, 1.90_dp, 1.89_dp, 1.82_dp, 1.83_dp, 2.73_dp, 2.62_dp, 2.58_dp, 2.46_dp, 2.42_dp, 2.45_dp, 2.45_dp, 2.44_dp, 2.40_dp, 2.40_dp, 2.38_dp, 2.39_dp, 2.32_dp, 2.29_dp, 1.88_dp, 1.82_dp, 1.86_dp, 2.25_dp, 3.21_dp, 2.84_dp, 2.75_dp, 2.52_dp, 2.56_dp, 2.45_dp, 2.44_dp, 2.46_dp, 2.44_dp, 2.15_dp, 2.53_dp, 2.49_dp, 2.43_dp, 2.42_dp, 2.47_dp, 1.99_dp, 2.04_dp, 2.06_dp, 3.48_dp, 3.03_dp, 2.98_dp, 2.88_dp, 2.92_dp, 2.95_dp, 1.0_dp, 2.90_dp, 2.87_dp, 2.83_dp, 2.79_dp, 2.87_dp, 2.81_dp, 2.83_dp, 2.79_dp, 2.80_dp, 2.74_dp, 2.63_dp, 2.53_dp, 2.57_dp, 2.49_dp, 2.48_dp, 2.41_dp, 2.29_dp, 2.32_dp, 2.45_dp, 2.47_dp, 2.60_dp, 2.54_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 2.8_dp, 2.93_dp, 2.88_dp, 2.71_dp, 2.82_dp, 2.81_dp, 2.83_dp, 3.05_dp, 3.4_dp, 3.05_dp, 2.7_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp, 1.0_dp/) real(kind=dp), public, parameter :: pi = 3.141592653589793238462643383279502884197_dp real(kind=dp), public, parameter :: q1 = 0.1874993441_dp real(kind=dp), public, parameter :: q2 = 0.01750636947_dp real(kind=dp), public, parameter :: q3 = 0.005527069444_dp real(kind=dp), public, parameter :: q4 = 0.001023904180_dp real(kind=dp), public, parameter :: rad_to_deg = 57.2957795_dp real(kind=dp), public, parameter :: sqrt_two = 1.414213562373095048801688724209698079_dp real(kind=dp), public, parameter :: twopi = 6.283185307179586476925286766559005768394_dp","tags":"","loc":"module/od_constants.html"},{"title":"optados – OptaDOS","text":"Uses od_pdis od_jdos od_parameters od_build od_pdos od_dos od_core od_optics od_photo od_comms od_constants od_cell od_electronic od_io program~~optados~~UsesGraph program~optados optados module~od_comms od_comms program~optados->module~od_comms od_photo od_photo program~optados->od_photo module~od_optics od_optics program~optados->module~od_optics module~od_io od_io program~optados->module~od_io module~od_parameters od_parameters program~optados->module~od_parameters module~od_pdis od_pdis program~optados->module~od_pdis module~od_cell od_cell program~optados->module~od_cell module~od_electronic od_electronic program~optados->module~od_electronic module~od_build od_build program~optados->module~od_build module~od_jdos od_jdos program~optados->module~od_jdos module~od_pdos od_pdos program~optados->module~od_pdos module~od_dos od_dos program~optados->module~od_dos module~od_core od_core program~optados->module~od_core module~od_constants od_constants program~optados->module~od_constants module~od_comms->module~od_constants module~od_optics->module~od_constants module~od_io->module~od_constants module~od_parameters->module~od_io module~od_parameters->module~od_cell module~od_parameters->module~od_constants module~od_pdis->module~od_constants module~od_projection_utils od_projection_utils module~od_pdis->module~od_projection_utils module~od_cell->module~od_io module~od_cell->module~od_constants module~od_electronic->module~od_constants module~od_jdos->module~od_constants module~od_pdos->module~od_constants module~od_pdos->module~od_projection_utils module~od_dos->module~od_constants module~od_core->module~od_constants module~od_projection_utils->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~optados~~CallsGraph program~optados optados proc~jdos_calculate jdos_calculate program~optados->proc~jdos_calculate proc~param_dealloc param_dealloc program~optados->proc~param_dealloc proc~elec_report_parameters elec_report_parameters program~optados->proc~elec_report_parameters proc~comms_setup comms_setup program~optados->proc~comms_setup proc~param_dist param_dist program~optados->proc~param_dist proc~version_output version_output program~optados->proc~version_output proc~io_date io_date program~optados->proc~io_date proc~param_read param_read program~optados->proc~param_read proc~param_write param_write program~optados->proc~param_write proc~param_write_atomic_coord param_write_atomic_coord program~optados->proc~param_write_atomic_coord proc~io_file_unit io_file_unit program~optados->proc~io_file_unit proc~param_write_header param_write_header program~optados->proc~param_write_header proc~io_get_seedname io_get_seedname program~optados->proc~io_get_seedname proc~cell_report_parameters cell_report_parameters program~optados->proc~cell_report_parameters proc~dos_calculate dos_calculate program~optados->proc~dos_calculate proc~core_calculate core_calculate program~optados->proc~core_calculate proc~elec_read_band_energy_ordered elec_read_band_energy_ordered program~optados->proc~elec_read_band_energy_ordered proc~pdos_calculate pdos_calculate program~optados->proc~pdos_calculate photo_calculate photo_calculate program~optados->photo_calculate proc~optics_calculate optics_calculate program~optados->proc~optics_calculate proc~comms_end comms_end program~optados->proc~comms_end proc~cell_dist cell_dist program~optados->proc~cell_dist proc~elec_read_band_energy elec_read_band_energy program~optados->proc~elec_read_band_energy proc~cell_calc_lattice cell_calc_lattice program~optados->proc~cell_calc_lattice proc~io_time io_time program~optados->proc~io_time proc~pdis_calculate pdis_calculate program~optados->proc~pdis_calculate proc~help_output help_output program~optados->proc~help_output proc~jdos_calculate->proc~io_time proc~jdos_utils_calculate jdos_utils_calculate proc~jdos_calculate->proc~jdos_utils_calculate proc~write_jdos write_jdos proc~jdos_calculate->proc~write_jdos proc~io_error io_error proc~param_dist->proc~io_error interface~comms_bcast comms_bcast proc~param_dist->interface~comms_bcast proc~param_read->proc~io_error proc~cell_read_cell cell_read_cell proc~param_read->proc~cell_read_cell proc~dos_calculate->proc~io_time proc~dos_utils_compute_bandgap dos_utils_compute_bandgap proc~dos_calculate->proc~dos_utils_compute_bandgap proc~write_dos write_dos proc~dos_calculate->proc~write_dos proc~dos_utils_calculate dos_utils_calculate proc~dos_calculate->proc~dos_utils_calculate proc~dos_utils_set_efermi dos_utils_set_efermi proc~dos_calculate->proc~dos_utils_set_efermi proc~dos_utils_compute_dos_at_efermi dos_utils_compute_dos_at_efermi proc~dos_calculate->proc~dos_utils_compute_dos_at_efermi proc~dos_utils_compute_band_energies dos_utils_compute_band_energies proc~dos_calculate->proc~dos_utils_compute_band_energies proc~elec_read_elnes_mat elec_read_elnes_mat proc~core_calculate->proc~elec_read_elnes_mat proc~core_calculate->proc~dos_utils_calculate proc~core_calculate->proc~dos_utils_set_efermi proc~elec_read_band_energy_ordered->proc~io_file_unit proc~elec_read_band_energy_ordered->proc~io_time proc~cell_find_mp_grid cell_find_MP_grid proc~elec_read_band_energy_ordered->proc~cell_find_mp_grid interface~comms_recv comms_recv proc~elec_read_band_energy_ordered->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_energy_ordered->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_energy_ordered->interface~comms_send proc~elec_read_band_energy_ordered->proc~io_error proc~elec_read_band_energy_ordered->interface~comms_bcast proc~projection_get_string projection_get_string proc~pdos_calculate->proc~projection_get_string proc~projection_analyse_orbitals projection_analyse_orbitals proc~pdos_calculate->proc~projection_analyse_orbitals proc~projection_merge projection_merge proc~pdos_calculate->proc~projection_merge proc~elec_pdos_read elec_pdos_read proc~pdos_calculate->proc~elec_pdos_read proc~pdos_calculate->proc~dos_utils_calculate proc~pdos_calculate->proc~dos_utils_set_efermi proc~write_epsilon write_epsilon proc~optics_calculate->proc~write_epsilon proc~write_refract write_refract proc~optics_calculate->proc~write_refract proc~write_loss_fn write_loss_fn proc~optics_calculate->proc~write_loss_fn proc~optics_calculate->proc~jdos_utils_calculate proc~elec_dealloc_optical elec_dealloc_optical proc~optics_calculate->proc~elec_dealloc_optical proc~dos_utils_calculate_at_e dos_utils_calculate_at_e proc~optics_calculate->proc~dos_utils_calculate_at_e proc~calc_conduct calc_conduct proc~optics_calculate->proc~calc_conduct proc~calc_reflect calc_reflect proc~optics_calculate->proc~calc_reflect proc~calc_absorp calc_absorp proc~optics_calculate->proc~calc_absorp proc~make_weights make_weights proc~optics_calculate->proc~make_weights proc~write_conduct write_conduct proc~optics_calculate->proc~write_conduct proc~write_absorp write_absorp proc~optics_calculate->proc~write_absorp proc~calc_refract calc_refract proc~optics_calculate->proc~calc_refract proc~optics_calculate->proc~dos_utils_set_efermi proc~elec_read_optical_mat elec_read_optical_mat proc~optics_calculate->proc~elec_read_optical_mat proc~calc_epsilon_1 calc_epsilon_1 proc~optics_calculate->proc~calc_epsilon_1 proc~calc_loss_fn calc_loss_fn proc~optics_calculate->proc~calc_loss_fn proc~write_reflect write_reflect proc~optics_calculate->proc~write_reflect proc~calc_epsilon_2 calc_epsilon_2 proc~optics_calculate->proc~calc_epsilon_2 proc~cell_dist->proc~io_error proc~cell_dist->interface~comms_bcast proc~elec_read_band_energy->proc~io_file_unit proc~elec_read_band_energy->proc~io_time proc~elec_read_band_energy->proc~cell_find_mp_grid proc~elec_read_band_energy->interface~comms_recv proc~elec_read_band_energy->proc~algor_dist_array proc~elec_read_band_energy->interface~comms_send proc~elec_read_band_energy->proc~io_error proc~elec_read_band_energy->interface~comms_bcast proc~cell_get_real_lattice cell_get_real_lattice proc~cell_calc_lattice->proc~cell_get_real_lattice proc~pdis_calculate->proc~projection_get_string proc~pdis_calculate->proc~projection_analyse_orbitals proc~pdis_calculate->proc~projection_merge proc~elec_pdis_read elec_pdis_read proc~pdis_calculate->proc~elec_pdis_read proc~write_epsilon->proc~io_file_unit proc~write_refract->proc~io_file_unit proc~write_loss_fn->proc~io_file_unit proc~cell_find_mp_grid->proc~io_error proc~projection_get_string->proc~io_error proc~algor_dist_array->proc~io_error proc~jdos_utils_calculate->proc~io_time proc~jdos_utils_calculate->proc~io_error proc~jdos_utils_calculate->proc~dos_utils_set_efermi proc~elec_read_band_gradient elec_read_band_gradient proc~jdos_utils_calculate->proc~elec_read_band_gradient proc~jdos_utils_merge jdos_utils_merge proc~jdos_utils_calculate->proc~jdos_utils_merge proc~setup_energy_scale setup_energy_scale proc~jdos_utils_calculate->proc~setup_energy_scale proc~calculate_jdos calculate_jdos proc~jdos_utils_calculate->proc~calculate_jdos proc~dos_utils_compute_bandgap->proc~io_time proc~dos_utils_compute_bandgap->interface~comms_recv proc~dos_utils_compute_bandgap->interface~comms_send proc~dos_utils_compute_bandgap->proc~io_error proc~elec_read_elnes_mat->proc~io_file_unit proc~elec_read_elnes_mat->proc~io_time proc~elec_read_elnes_mat->interface~comms_recv proc~elec_read_elnes_mat->interface~comms_send proc~elec_read_elnes_mat->proc~io_error proc~elec_read_elnes_mat->interface~comms_bcast proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~projection_analyse_orbitals->proc~io_error proc~projection_merge->proc~io_error proc~elec_dealloc_optical->proc~io_error proc~cell_get_real_lattice->proc~io_file_unit proc~dos_utils_calculate_at_e->proc~io_time proc~dos_utils_calculate_at_e->proc~io_error proc~dos_utils_calculate_at_e->proc~elec_read_band_gradient proc~make_weights->proc~io_error proc~cell_get_symmetry cell_get_symmetry proc~make_weights->proc~cell_get_symmetry proc~write_conduct->proc~io_file_unit proc~write_absorp->proc~io_file_unit proc~write_dos->proc~io_date proc~write_dos->proc~io_file_unit proc~write_dos->proc~io_error proc~write_dos_xmgrace write_dos_xmgrace proc~write_dos->proc~write_dos_xmgrace proc~elec_pdos_read->proc~io_file_unit proc~elec_pdos_read->interface~comms_recv proc~elec_pdos_read->interface~comms_send proc~elec_pdos_read->proc~io_error proc~elec_pdos_read->interface~comms_bcast proc~write_jdos->proc~io_date proc~write_jdos->proc~io_file_unit proc~write_jdos->proc~io_error proc~write_jdos_xmgrace write_jdos_xmgrace proc~write_jdos->proc~write_jdos_xmgrace proc~cell_read_cell->proc~io_file_unit proc~cell_read_cell->proc~cell_get_real_lattice proc~cell_read_cell->proc~io_error proc~utility_cart_to_frac utility_cart_to_frac proc~cell_read_cell->proc~utility_cart_to_frac proc~utility_lowercase utility_lowercase proc~cell_read_cell->proc~utility_lowercase proc~utility_frac_to_cart utility_frac_to_cart proc~cell_read_cell->proc~utility_frac_to_cart proc~dos_utils_calculate->proc~io_time proc~dos_utils_calculate->proc~io_error proc~dos_utils_calculate->interface~comms_bcast proc~dos_utils_merge dos_utils_merge proc~dos_utils_calculate->proc~dos_utils_merge proc~dos_utils_calculate->proc~elec_read_band_gradient proc~dos_utils_set_efermi->proc~io_error proc~dos_utils_set_efermi->interface~comms_bcast proc~dos_utils_set_efermi->proc~dos_utils_calculate interface~comms_reduce comms_reduce proc~dos_utils_set_efermi->interface~comms_reduce proc~dos_utils_compute_dos_at_efermi->proc~io_time proc~dos_utils_compute_dos_at_efermi->proc~dos_utils_calculate_at_e proc~dos_utils_compute_dos_at_efermi->interface~comms_bcast proc~dos_utils_compute_band_energies->proc~io_time proc~dos_utils_compute_band_energies->interface~comms_reduce proc~elec_pdis_read->proc~io_file_unit proc~elec_pdis_read->proc~io_error proc~elec_pdis_read->interface~comms_bcast proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~elec_read_optical_mat->proc~io_error proc~write_reflect->proc~io_file_unit proc~dos_utils_merge->interface~comms_reduce proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->interface~comms_recv proc~elec_read_band_gradient->proc~algor_dist_array proc~elec_read_band_gradient->interface~comms_send proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->interface~comms_bcast proc~elec_read_band_gradient->proc~elec_read_optical_mat proc~elec_elnes_find_channel_names->proc~io_error proc~jdos_utils_merge->interface~comms_reduce proc~setup_energy_scale->proc~io_error proc~setup_energy_scale->interface~comms_bcast proc~setup_energy_scale->interface~comms_reduce proc~calculate_jdos->proc~io_error proc~doslin doslin proc~calculate_jdos->proc~doslin proc~gaussian gaussian proc~calculate_jdos->proc~gaussian proc~allocate_jdos allocate_jdos proc~calculate_jdos->proc~allocate_jdos proc~doslin_sub_cell_corners doslin_sub_cell_corners proc~calculate_jdos->proc~doslin_sub_cell_corners proc~cell_get_symmetry->proc~io_file_unit proc~cell_get_symmetry->proc~io_error proc~cell_get_symmetry->interface~comms_bcast proc~write_dos_xmgrace->proc~io_file_unit proc~write_dos_xmgrace->proc~io_error proc~xmgu_legend xmgu_legend proc~write_dos_xmgrace->proc~xmgu_legend proc~xmgu_setup xmgu_setup proc~write_dos_xmgrace->proc~xmgu_setup proc~xmgu_title xmgu_title proc~write_dos_xmgrace->proc~xmgu_title proc~xmgu_subtitle xmgu_subtitle proc~write_dos_xmgrace->proc~xmgu_subtitle proc~xmgu_axis xmgu_axis proc~write_dos_xmgrace->proc~xmgu_axis proc~xmgu_vertical_line xmgu_vertical_line proc~write_dos_xmgrace->proc~xmgu_vertical_line proc~xmgu_data xmgu_data proc~write_dos_xmgrace->proc~xmgu_data proc~xmgu_data_header xmgu_data_header proc~write_dos_xmgrace->proc~xmgu_data_header proc~write_jdos_xmgrace->proc~io_file_unit proc~write_jdos_xmgrace->proc~io_error proc~write_jdos_xmgrace->proc~xmgu_legend proc~write_jdos_xmgrace->proc~xmgu_setup proc~write_jdos_xmgrace->proc~xmgu_title proc~write_jdos_xmgrace->proc~xmgu_subtitle proc~write_jdos_xmgrace->proc~xmgu_axis proc~write_jdos_xmgrace->proc~xmgu_data proc~write_jdos_xmgrace->proc~xmgu_data_header proc~allocate_jdos->proc~io_error proc~heap_sort heap_sort proc~doslin_sub_cell_corners->proc~heap_sort proc~xmgu_setup->proc~io_date proc~xmgu_data->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cdate ctime filename odo_found pos stat time0 time1 Subroutines help_output version_output Source Code optados Variables Type Attributes Name Initial character(len=11) :: cdate character(len=9) :: ctime character(len=120) :: filename logical :: odo_found character(len=9) :: pos character(len=9) :: stat real(kind=dp) :: time0 real(kind=dp) :: time1 Subroutines subroutine help_output () Arguments None subroutine version_output () Arguments None Source Code program optados !=========================================================================! !                             O P T A D O S                               ! !                      OPTics And Density Of States                       ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! ! Described below.                                                        ! !-------------------------------------------------------------------------! ! Necessary conditions:                                                   ! !-------------------------------------------------------------------------! ! Written by Andrew Morris, Rebecca Nicholls, Chris Pickard               ! !             and Jonathan Yates      2010                                ! !=========================================================================! use od_comms , only : comms_setup , on_root , comms_end , num_nodes use od_constants , only : dp use od_io , only : io_get_seedname , io_time , io_date , io_file_unit ,& ! Functions & stdout , stderr , seedname , options , temp_dir ! Variables use od_parameters , only : param_read , param_write_header , param_Dist , param_write , & param_dealloc , pdos , pdis , dos , jdos , core , optics , photo , iprint , param_write_atomic_coord , & devel_flag , photo_photon_energy , photo_model use od_cell , only : cell_calc_lattice , cell_report_parameters , cell_dist use od_electronic , only : elec_read_band_energy , elec_read_band_energy_ordered , elec_report_parameters use od_dos , only : dos_calculate use od_jdos , only : jdos_calculate use od_core , only : core_calculate use od_pdos , only : pdos_calculate use od_pdis , only : pdis_calculate use od_optics , only : optics_calculate use od_photo , only : photo_calculate use od_build , only : build_info implicit none real ( kind = dp ) :: time0 , time1 ! Variables for timing logical :: odo_found ! Ouptut file exists? character ( len = 9 ) :: stat , pos ! Status and position of .odo file character ( len = 9 ) :: ctime ! Temp. time string character ( len = 11 ) :: cdate ! Temp. date string character ( len = 120 ) :: filename ! Added by Felix Mildner, 03/23 for multi file output ! call sleep(25) time0 = io_time () call comms_setup if ( on_root ) then call io_get_seedname () ! If blank set to seedname='--help' if ( trim ( seedname ) == '-h' . or . trim ( seedname ) == '--help' ) call help_output if ( trim ( seedname ) == '-v' . or . trim ( seedname ) == '--version' ) call version_output !-------------------------------------------------------------------------! ! O R G A N I S E   T H E   E R R O R   F I L E stderr = io_file_unit () ! This is to allow multiple OptaDOS photoemission runs to be performed in the same directory. if (( index ( options , '-temp' ) > 0 )) then filename = trim ( adjustl ( temp_dir )) // '/' // trim ( seedname ) // '.opt_err' open ( unit = stderr , file = filename ) else open ( unit = stderr , file = trim ( seedname ) // '.opt_err' ) end if call io_date ( cdate , ctime ) write ( stderr , * ) 'OptaDOS: Execution started on ' , cdate , ' at ' , ctime !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! O R G A N I S E   T H E   O U T P U T   F I L E  A N D ! R E A D   A N D   W R I T E   U S E R   P A R A M E T E R S call param_read () ! This is to allow multiple simultaneous OptaDOS photoemission runs to be performed in the same directory. if (( index ( options , '-temp' ) /= 0 )) then filename = trim ( adjustl ( temp_dir )) // '/' // trim ( seedname ) // '.odo' inquire ( file = filename , exist = odo_found ) else inquire ( file = trim ( seedname ) // '.odo' , exist = odo_found ) end if if ( odo_found ) then stat = 'old' else stat = 'replace' end if pos = 'append' stdout = io_file_unit () ! This is to allow multiple OptaDOS photoemission runs to be performed in the same directory. if (( index ( options , '-temp' ) /= 0 )) then open ( unit = stdout , file = filename , status = trim ( stat ), position = trim ( pos )) else open ( unit = stdout , file = trim ( seedname ) // '.odo' , status = trim ( stat ), position = trim ( pos )) end if write ( stdout , * ) 'OptaDOS: Execution started on ' , cdate , ' at ' , ctime write ( stdout , '(1x,a26,i5,a10)' ) 'Parallelised over' , num_nodes , ' thread(s)' if ( iprint > 0 ) call param_write_header () if ( iprint > 0 ) call param_write () time1 = io_time () if ( iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read parameters ' , time1 - time0 , ' (sec)' !-------------------------------------------------------------------------! end if if ( pdis ) then call elec_read_band_energy_ordered else call elec_read_band_energy end if if ( on_root ) then call cell_calc_lattice if ( iprint > 0 ) call param_write_atomic_coord if ( iprint > 0 ) call cell_report_parameters if ( iprint > 0 ) call elec_report_parameters end if ! now send the data from the parameter file to each node call param_dist call cell_dist !-------------------------------------------------------------------------! ! C A L L   P D O S   R O U T I N E S if ( pdos ) then time0 = io_time () call pdos_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Projected Density of States          & &      ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   P D I S   R O U T I N E S if ( pdis ) then time0 = io_time () call pdis_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Projected Dispersion & &      ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   C O R E   R O U T I N E S if ( core ) then time0 = io_time () call core_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Core Level Spectra       & &                  ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   D O S  R O U T I N E S if ( dos ) then time0 = io_time () call dos_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Density of States        & &                  ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   O P T I C S   R O U T I N E S if ( optics ) then time0 = io_time () call optics_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Optical properties                         ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   P H O T O E M I S S I O N   R O U T I N E S if ( photo ) then time0 = io_time () call photo_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Photoemission                              ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   J D O S   R O U T I N E S if ( jdos ) then time0 = io_time () call jdos_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Joint Density of States                    ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! F I N A L I S E call param_dealloc if ( on_root ) then call io_date ( cdate , ctime ) write ( stdout , * ) write ( stdout , * ) 'OptaDOS: Execution complete on ' , cdate , ' at ' , ctime close ( stdout ) close ( stderr , status = 'delete' ) end if call comms_end !-------------------------------------------------------------------------! contains subroutine help_output use od_constants , only : optados_version , copyright implicit none write ( * , * ) write ( * , * ) \" OptaDOS version \" , trim ( build_info % build ) write ( * , * ) write ( * , * ) \" Andrew J. Morris, R. J. Nicholls, C. J. Pickard and J. R. Yates\" , trim ( copyright ) write ( * , * ) \" Usage: optados <seedname>\" write ( * , * ) stop end subroutine help_output subroutine version_output use od_build , only : build_info use od_constants , only : optados_version , copyright implicit none write ( * , * ) write ( * , * ) \" OptaDOS version \" , trim ( build_info % build ) write ( * , * ) write ( * , * ) \" Andrew J. Morris, R. J. Nicholls, C. J. Pickard and J. R. Yates\" , trim ( copyright ) write ( * , * ) \" Compiled with \" // trim ( build_info % compiler ) // \" on \" // trim ( build_info % compile_date )& & // \" at \" // trim ( build_info % compile_time ) // \".\" write ( * , * ) \" Compile type: \" // trim ( build_info % build_type ) // \", \" // trim ( build_info % comms_arch ) write ( * , * ) \" From source \" // trim ( build_info % build ) // \" submitted on \" // trim ( build_info % source_date )& & // \" at \" // trim ( build_info % source_time ) // \".\" stop end subroutine version_output end program optados","tags":"","loc":"program/optados.html"},{"title":"od2od – OptaDOS","text":"Uses od_comms od_conv od_io od_constants program~~od2od~~UsesGraph program~od2od od2od module~od_comms od_comms program~od2od->module~od_comms module~od_io od_io program~od2od->module~od_io module~od_constants od_constants program~od2od->module~od_constants module~od_conv od_conv program~od2od->module~od_conv module~od_comms->module~od_constants module~od_io->module~od_constants module~od_conv->module~od_io module~od_conv->module~od_constants module~od_parameters od_parameters module~od_conv->module~od_parameters module~od_electronic od_electronic module~od_conv->module~od_electronic module~od_parameters->module~od_io module~od_parameters->module~od_constants module~od_cell od_cell module~od_parameters->module~od_cell module~od_electronic->module~od_constants module~od_cell->module~od_io module~od_cell->module~od_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Program to convert checkpoint files from formatted to unformmated\nand vice versa - useful for switching between computers. Plan is to use to convert outputs of other DFT programs to ones that\nOptaDOS can read. AJM 2019 Calls program~~od2od~~CallsGraph program~od2od od2od proc~write_fem_bin write_fem_bin program~od2od->proc~write_fem_bin proc~write_pdos_fmt write_pdos_fmt program~od2od->proc~write_pdos_fmt proc~read_dome_bin read_dome_bin program~od2od->proc~read_dome_bin proc~conv_get_seedname conv_get_seedname program~od2od->proc~conv_get_seedname proc~read_elnes_bin read_elnes_bin program~od2od->proc~read_elnes_bin proc~pad_an_ome pad_an_ome program~od2od->proc~pad_an_ome proc~read_pdos_fmt read_pdos_fmt program~od2od->proc~read_pdos_fmt proc~io_date io_date program~od2od->proc~io_date proc~comms_setup comms_setup program~od2od->proc~comms_setup proc~get_band_energy get_band_energy program~od2od->proc~get_band_energy proc~comms_end comms_end program~od2od->proc~comms_end proc~write_pdos_bin write_pdos_bin program~od2od->proc~write_pdos_bin proc~read_pdos_bin read_pdos_bin program~od2od->proc~read_pdos_bin proc~io_time io_time program~od2od->proc~io_time proc~read_dome_fmt read_dome_fmt program~od2od->proc~read_dome_fmt proc~io_file_unit io_file_unit program~od2od->proc~io_file_unit proc~write_dome_fmt write_dome_fmt program~od2od->proc~write_dome_fmt proc~slice_an_ome slice_an_ome program~od2od->proc~slice_an_ome proc~io_error io_error program~od2od->proc~io_error proc~write_read_file write_read_file program~od2od->proc~write_read_file proc~read_ome_fmt read_ome_fmt program~od2od->proc~read_ome_fmt proc~read_ome_bin read_ome_bin program~od2od->proc~read_ome_bin proc~write_ome_bin write_ome_bin program~od2od->proc~write_ome_bin proc~write_fem_fmt write_fem_fmt program~od2od->proc~write_fem_fmt proc~read_fem_bin read_fem_bin program~od2od->proc~read_fem_bin proc~write_dome_bin write_dome_bin program~od2od->proc~write_dome_bin proc~write_elnes_bin write_elnes_bin program~od2od->proc~write_elnes_bin proc~write_elnes_fmt write_elnes_fmt program~od2od->proc~write_elnes_fmt proc~write_ome_fmt write_ome_fmt program~od2od->proc~write_ome_fmt proc~read_elnes_fmt read_elnes_fmt program~od2od->proc~read_elnes_fmt proc~read_fem_fmt read_fem_fmt program~od2od->proc~read_fem_fmt proc~write_pdos_fmt->proc~io_file_unit proc~elec_read_band_gradient elec_read_band_gradient proc~read_dome_bin->proc~elec_read_band_gradient proc~conv_get_seedname->proc~io_error proc~print_usage print_usage proc~conv_get_seedname->proc~print_usage proc~elec_read_elnes_mat elec_read_elnes_mat proc~read_elnes_bin->proc~elec_read_elnes_mat proc~read_pdos_fmt->proc~io_file_unit proc~read_pdos_fmt->proc~io_error proc~report_arraysize report_arraysize proc~get_band_energy->proc~report_arraysize proc~elec_read_band_energy elec_read_band_energy proc~get_band_energy->proc~elec_read_band_energy proc~write_pdos_bin->proc~io_file_unit proc~elec_pdos_read elec_pdos_read proc~read_pdos_bin->proc~elec_pdos_read proc~elec_read_optical_mat elec_read_optical_mat proc~read_ome_bin->proc~elec_read_optical_mat proc~elec_read_foptical_mat elec_read_foptical_mat proc~read_fem_bin->proc~elec_read_foptical_mat proc~write_elnes_bin->proc~io_file_unit proc~elec_elnes_find_channel_numbers elec_elnes_find_channel_numbers proc~write_elnes_bin->proc~elec_elnes_find_channel_numbers proc~write_elnes_fmt->proc~io_file_unit proc~write_elnes_fmt->proc~elec_elnes_find_channel_numbers proc~read_elnes_fmt->proc~io_file_unit proc~read_elnes_fmt->proc~io_error proc~elec_elnes_find_channel_names elec_elnes_find_channel_names proc~read_elnes_fmt->proc~elec_elnes_find_channel_names proc~elec_read_band_gradient->proc~io_time proc~elec_read_band_gradient->proc~io_file_unit proc~elec_read_band_gradient->proc~io_error proc~elec_read_band_gradient->proc~elec_read_optical_mat interface~comms_bcast comms_bcast proc~elec_read_band_gradient->interface~comms_bcast interface~comms_recv comms_recv proc~elec_read_band_gradient->interface~comms_recv proc~algor_dist_array algor_dist_array proc~elec_read_band_gradient->proc~algor_dist_array interface~comms_send comms_send proc~elec_read_band_gradient->interface~comms_send proc~elec_dealloc_optical elec_dealloc_optical proc~elec_read_band_gradient->proc~elec_dealloc_optical proc~elec_read_elnes_mat->proc~io_time proc~elec_read_elnes_mat->proc~io_file_unit proc~elec_read_elnes_mat->proc~io_error proc~elec_read_elnes_mat->proc~elec_elnes_find_channel_names proc~elec_read_elnes_mat->interface~comms_bcast proc~elec_read_elnes_mat->interface~comms_recv proc~elec_read_elnes_mat->interface~comms_send proc~elec_read_band_energy->proc~io_time proc~elec_read_band_energy->proc~io_file_unit proc~elec_read_band_energy->proc~io_error proc~elec_read_band_energy->interface~comms_bcast proc~elec_read_band_energy->interface~comms_recv proc~elec_read_band_energy->proc~algor_dist_array proc~elec_read_band_energy->interface~comms_send proc~cell_find_mp_grid cell_find_MP_grid proc~elec_read_band_energy->proc~cell_find_mp_grid proc~elec_pdos_read->proc~io_file_unit proc~elec_pdos_read->proc~io_error proc~elec_pdos_read->interface~comms_bcast proc~elec_pdos_read->interface~comms_recv proc~elec_pdos_read->interface~comms_send proc~elec_read_optical_mat->proc~io_time proc~elec_read_optical_mat->proc~io_file_unit proc~elec_read_optical_mat->proc~io_error proc~elec_read_optical_mat->interface~comms_recv proc~elec_read_optical_mat->proc~algor_dist_array proc~elec_read_optical_mat->interface~comms_send proc~elec_read_foptical_mat->proc~io_time proc~elec_read_foptical_mat->proc~io_file_unit proc~elec_read_foptical_mat->proc~io_error proc~elec_read_foptical_mat->interface~comms_recv proc~elec_read_foptical_mat->proc~algor_dist_array proc~elec_read_foptical_mat->interface~comms_send interface~comms_reduce comms_reduce proc~elec_read_foptical_mat->interface~comms_reduce proc~elec_elnes_find_channel_numbers->proc~io_error selectcase selectcase proc~elec_elnes_find_channel_numbers->selectcase proc~elec_elnes_find_channel_names->proc~io_error proc~algor_dist_array->proc~io_error proc~elec_dealloc_optical->proc~io_error proc~cell_find_mp_grid->proc~io_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cdate ctime dome_conv dummy_conv elnes_conv fem_conv file_found ome_conv pdos_conv pos stat time0 time1 Source Code od2od Variables Type Attributes Name Initial character(len=11) :: cdate Temp. date string character(len=9) :: ctime Temp. time string logical :: dome_conv Flags to stop people trying to, say, read in a pdos and write out an\nelnes. That's not going to end well. logical :: dummy_conv Flags to stop people trying to, say, read in a pdos and write out an\nelnes. That's not going to end well. logical :: elnes_conv Flags to stop people trying to, say, read in a pdos and write out an\nelnes. That's not going to end well. logical :: fem_conv Flags to stop people trying to, say, read in a pdos and write out an\nelnes. That's not going to end well. logical :: file_found logical :: ome_conv Flags to stop people trying to, say, read in a pdos and write out an\nelnes. That's not going to end well. logical :: pdos_conv Flags to stop people trying to, say, read in a pdos and write out an\nelnes. That's not going to end well. character(len=9) :: pos Status and position of .odo file character(len=9) :: stat Position of .odo file real(kind=dp) :: time0 Varaibles for measuring exectuion time. real(kind=dp) :: time1 Varaibles for measuring exectuion time. Source Code program od2od !! Program to convert checkpoint files from formatted to unformmated !! and vice versa - useful for switching between computers. !! !! Plan is to use to convert outputs of other DFT programs to ones that !! OptaDOS can read. !! !! AJM 2019 use od_constants , only : dp use od_io , only : io_file_unit , stdout , stderr , io_error , seedname , io_time , & & io_date use od_conv use od_comms , only : num_nodes , comms_setup , comms_end implicit none logical :: file_found logical :: ome_conv , fem_conv , dome_conv , pdos_conv , elnes_conv , dummy_conv !! Flags to stop people trying to, say, read in a pdos and write out an !! elnes. That's not going to end well. real ( kind = dp ) :: time0 , time1 !! Varaibles for measuring exectuion time. character ( len = 9 ) :: pos !! Status and position of .odo file character ( len = 9 ) :: stat !! Position of .odo file character ( len = 9 ) :: ctime !! Temp. time string character ( len = 11 ) :: cdate !! Temp. date string time0 = io_time () iprint = 4 call comms_setup call conv_get_seedname stderr = io_file_unit () open ( unit = stderr , file = trim ( seedname ) // '.opt_err' ) call io_date ( cdate , ctime ) write ( stderr , * ) 'od2od: Execution started on ' , cdate , ' at ' , ctime stdout = io_file_unit () open ( unit = stdout , file = trim ( seedname ) // '.log' ) !-------------------------------------------------------------------------! write ( stdout , * ) write ( stdout , * ) 'od2od: Execution started on ' , cdate , ' at ' , ctime write ( stdout , * ) write ( stdout , * ) \"+============================================================================+ \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"|                         OO   DDD   222    OO   DDD                         | \" write ( stdout , * ) \"|                        O  O  D  D     2  O  O  D  D                        | \" write ( stdout , * ) \"|                        O  O  D  D   22   O  O  D  D                        | \" write ( stdout , * ) \"|                        O  O  D  D  2     O  O  D  D                        | \" write ( stdout , * ) \"|                         OO   DDD   2222   OO   DDD                         | \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"|                   For doing the odd thing to OptaDOS files                 | \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"|                      OptaDOS Developers Group 2019 (C)                     | \" write ( stdout , * ) \"|                             (But blame Andrew)                             | \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"+============================================================================+ \" if ( num_nodes /= 1 ) then call io_error ( 'od2od can only be used in serial...' ) end if write ( stdout , * ) write ( stdout , * ) \"+--------------------------------- JOB CONTROL ------------------------------+\" write ( stdout , '(a40,i5)' ) \"Number of nodes : \" , num_nodes write ( stdout , '(a40,a)' ) \"Convert from : \" , trim ( infile ) write ( stdout , '(a40,a)' ) \"Convert to : \" , trim ( outfile ) write ( stdout , '(a40,a)' ) \"Seedname : \" , trim ( seedname ) write ( stdout , '(a40,a)' ) \"Output Seedname : \" , trim ( outseedname ) write ( stdout , * ) \"+----------------------------------------------------------------------------+\" ome_conv = . false . fem_conv = . false . dome_conv = . false . pdos_conv = . false . elnes_conv = . false . dummy_conv = . false . ! Main case to decide what file format to read in. read_input : select case ( trim ( infile )) case ( \"ome_fmt\" ) ome_conv = . true . call get_band_energy () call write_read_file () call read_ome_fmt () case ( \"ome_bin\" ) ome_conv = . true . call get_band_energy () call write_read_file () call read_ome_bin () case ( \"fem_fmt\" ) fem_conv = . true . call get_band_energy () call write_read_file () call read_fem_fmt () case ( \"fem_bin\" ) fem_conv = . true . call get_band_energy () call write_read_file () call read_fem_bin () case ( \"dome_fmt\" ) dome_conv = . true . call get_band_energy () call write_read_file () call read_dome_fmt () case ( \"dome_bin\" ) dome_conv = . true . call get_band_energy () call write_read_file () call read_dome_bin () case ( \"pdos_fmt\" ) pdos_conv = . true . call get_band_energy () call write_read_file () call read_pdos_fmt () case ( \"pdos_bin\" ) pdos_conv = . true . call get_band_energy () call write_read_file () call read_pdos_bin () case ( \"elnes_fmt\" ) elnes_conv = . true . call get_band_energy () call write_read_file () call read_elnes_fmt () case ( \"elnes_bin\" ) elnes_conv = . true . call get_band_energy () call write_read_file () call read_elnes_bin () case ( \"dummy\" ) dummy_conv = . true . call get_band_energy () call write_read_file () write ( stdout , * ) \" Not reading any input file.\" case default call io_error ( 'Unknown Input File format speccified' ) end select read_input write ( stdout , * ) \"+----------------------------------------------------------------------------+\" write ( stdout , * ) write ( stdout , * ) \"+------------------------------- Write File ---------------------------------+\" ! Main case to decide what file format to write. write_output : select case ( trim ( outfile )) case ( \"ome_fmt\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) if ( dome_conv ) call pad_an_ome () call write_ome_fmt () case ( \"ome_bin\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) if ( dome_conv ) call pad_an_ome () call write_ome_bin () case ( \"fem_fmt\" ) if (. not . ( fem_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) call write_fem_fmt () case ( \"fem_bin\" ) if (. not . ( fem_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) call write_fem_bin () case ( \"dome_fmt\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // & & ' not compatible with output format ' // trim ( outfile )) if ( ome_conv ) call slice_an_ome () call write_dome_fmt () case ( \"dome_bin\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // & & ' not compatible with output format ' // trim ( outfile )) if ( ome_conv ) call slice_an_ome () call write_dome_bin () case ( \"pdos_fmt\" ) if (. not . pdos_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_pdos_fmt () case ( \"pdos_bin\" ) if (. not . pdos_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_pdos_bin () case ( \"elnes_fmt\" ) if (. not . elnes_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_elnes_fmt () case ( \"elnes_bin\" ) if (. not . elnes_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_elnes_bin () case ( \"dummy\" ) write ( stdout , * ) \" Not writing any output file.\" if ( dummy_conv ) then write ( stdout , * ) write ( stdout , * ) \"                 Dummy in + dummy out  -- who's the dummy now ?\" else write ( stdout , * ) write ( stdout , * ) \"                No point in taking up disk space unnecessarily, eh ?\" end if case default call io_error ( 'Unknown Output File format speccified' ) end select write_output call io_date ( cdate , ctime ) write ( stdout , * ) \"+----------------------------------------------------------------------------+\" time1 = io_time () write ( stdout , '(1x,a40,f11.3,a)' ) 'Total runtime :' , time1 - time0 , ' (sec)' write ( stdout , * ) write ( stdout , * ) 'od2od: Execution complete on ' , cdate , ' at ' , ctime write ( stdout , * ) close ( stdout ) close ( stderr , status = 'delete' ) call comms_end !  close(unit=stdout,status='delete') end program od2od","tags":"","loc":"program/od2od.html"},{"title":"pdos.F90 – OptaDOS","text":"This file depends on sourcefile~~pdos.f90~~EfferentGraph sourcefile~pdos.f90 pdos.F90 sourcefile~constants.f90 constants.f90 sourcefile~pdos.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~comms.f90 comms.F90 sourcefile~pdos.f90->sourcefile~comms.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~io.f90 io.f90 sourcefile~pdos.f90->sourcefile~io.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~pdos.f90->sourcefile~algorithms.f90 sourcefile~cell.f90 cell.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~constants.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90->sourcefile~comms.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~io.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pdos.f90~~AfferentGraph sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~pdos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_pdos Source Code pdos.F90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! MODULE od_pdos ! This module contains routines for writing the desired projector weights ! out to file, after accumulating across all kpoints. !------------------------------------------------------------------------------- module od_pdos !-------------------------------------------------------------------------! ! G L O B A L   V A R I A B L E S !-------------------------------------------------------------------------! use od_constants , only : dp use od_projection_utils , only : projection_array , matrix_weights , max_am , proj_symbol , num_proj , shortcut implicit none real ( kind = dp ), public , allocatable , save :: dos_partial (:, :, :) !-------------------------------------------------------------------------! private public :: pdos_calculate contains subroutine pdos_calculate use od_electronic , only : elec_pdos_read , efermi , efermi_set use od_dos_utils , only : dos_utils_calculate , dos_utils_set_efermi use od_projection_utils , only : projection_merge , projection_get_string , projection_analyse_orbitals use od_comms , only : on_root use od_parameters , only : iprint , set_efermi_zero use od_io , only : stdout implicit none if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                 Projected Density Of States Calculation                    +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) end if ! read in the pdos weights call elec_pdos_read ! look at the orbitals and figure out which atoms / states we have call projection_analyse_orbitals ! parse the pdos string to see what we want call projection_get_string ! form the right matrix elements call projection_merge if ( on_root . and . ( iprint > 2 )) then call pdos_report_projectors end if ! now compute the weighted dos call dos_utils_calculate ( matrix_weights , dos_partial ) ! and write everything out if ( set_efermi_zero . and . . not . efermi_set ) call dos_utils_set_efermi if ( on_root ) then call pdos_write end if end subroutine pdos_calculate !=============================================================================== subroutine pdos_write !=============================================================================== ! Write out the pdos that was requested. Write them all to the same file, unless ! we don't have a short cut. In this case, write 10 projectors per file. !=============================================================================== use od_io , only : seedname implicit none character ( len = 20 ) :: start_iproj_name , end_iproj_name integer :: ifile , nfile , start_iproj , end_iproj character ( len = 512 ) :: name ! write(*,*) \"======================================================================================\" ! write(*,*) \"ispecies,ispecies_num,iam,iproj,projection_array(ispecies,ispecies_num,iam,iproj)\" ! do iproj=1,num_proj !    do iam=1,max_am !       do ispecies_num=1,maxval(atoms_species_num) !          do  ispecies=1,num_species !             write(*,*) ispecies,ispecies_num,iam,iproj,projection_array(ispecies,ispecies_num,iam,iproj) !          enddo !       enddo !    enddo ! enddo ! write(*,*) \"======================================================================================\" if ( shortcut ) then ! write everything to one file name = trim ( seedname ) // '.pdos.dat' call write_proj_to_file ( 1 , num_proj , name ) else ! not shortcut nfile = int ( num_proj / 10 ) + 1 ! Number of output files do ifile = 1 , nfile start_iproj = ( ifile - 1 ) * 10 + 1 ! First projector in nfile if ( ifile == nfile ) then ! We're doing the last file end_iproj = num_proj else end_iproj = ifile * 10 end if write ( start_iproj_name , '(I20.4)' ) start_iproj write ( end_iproj_name , '(I20.4)' ) end_iproj name = trim ( seedname ) // '.pdos.proj-' // trim ( adjustl ( start_iproj_name )) // '-' // trim ( adjustl ( end_iproj_name )) // '.dat' call write_proj_to_file ( start_iproj , end_iproj , name ) end do end if end subroutine pdos_write subroutine write_proj_to_file ( start_proj , stop_proj , name ) !=============================================================================== ! Write out projectors, start_proj, stop_proj, to file name !=============================================================================== use od_dos_utils , only : E , dos_utils_set_efermi use od_parameters , only : dos_nbins , iprint , set_efermi_zero use od_algorithms , only : channel_to_am use od_electronic , only : pdos_mwab , efermi , efermi_set use od_cell , only : atoms_species_num , num_species use od_io , only : io_file_unit , io_error , io_date , stdout implicit none integer , intent ( in ) :: start_proj , stop_proj character ( len = 512 ), intent ( in ) :: name character ( len = 11 ) :: cdate character ( len = 9 ) :: ctime character ( len = 20 ) :: string integer :: iproj , iam , ispecies_num , ispecies integer :: idos , i , pdos_file , ierr real ( kind = dp ), allocatable :: E_shift (:) allocate ( E_shift ( dos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating E_shift in write_proj_to_file' ) if ( set_efermi_zero ) then E_shift = E - efermi else E_shift = E end if write ( string , '(I4,\"(1x,es14.7)\")' ) ( stop_proj - start_proj ) + 1 pdos_file = io_file_unit () open ( unit = pdos_file , file = trim ( name ), iostat = ierr ) if ( iprint > 2 ) write ( stdout , '(1x,a30,a30,17x,a1)' ) \"| Writing PDOS projectors to: \" , trim ( name ), \"|\" if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open output file in pdos: pdos_write\" ) write ( pdos_file , '(a78)' ) \"##############################################################################\" write ( pdos_file , '(1a)' ) \"#\" write ( pdos_file , '(a57)' ) \"#                  O p t a D O S   o u t p u t   f i l e \" write ( pdos_file , '(1x,a1)' ) \"#\" call io_date ( cdate , ctime ) write ( pdos_file , '(a16, 11a, 4a, 9a)' ) '#  Generated on ' , cdate , ' at ' , ctime write ( pdos_file , '(a78)' ) \"##############################################################################\" write ( pdos_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' write ( pdos_file , '(1a,a)' ) '#' , '|                    Partial Density of States -- Projectors                 |' write ( pdos_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' if ( pdos_mwab % nspins > 1 ) then do iproj = start_proj , stop_proj write ( pdos_file , '(1a,a1,a12,i4,a10,50x,a1)' ) '#' , '|' , ' Column: ' , iproj , ' contains:' , '|' write ( pdos_file , '(1a,a1,a16,10x,a14,5x,a15,16x,a1)' ) '#' , '|' , ' Atom ' , ' AngM Channel ' , ' Spin Channel ' , '|' do ispecies = 1 , num_species do ispecies_num = 1 , atoms_species_num ( ispecies ) do iam = 1 , max_am if ( projection_array ( ispecies , ispecies_num , iam , iproj ) == 1 ) then write ( pdos_file , '(1a,a1,a13,i3,a18,16x,a2,24x,1a)' ) \"#\" , \"|\" , proj_symbol ( ispecies ), & & ispecies_num , channel_to_am ( iam ), 'Up' , '|' end if end do end do end do write ( pdos_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' end do do iproj = start_proj , stop_proj write ( pdos_file , '(1a,a1,a12,i4,a10,50x,a1)' ) '#' , '|' , ' Column: ' , iproj + num_proj , ' contains:' , '|' write ( pdos_file , '(1a,a1,a16,10x,a14,5x,a15,16x,a1)' ) '#' , '|' , ' Atom ' , ' AngM Channel ' , ' Spin Channel ' , '|' do ispecies = 1 , num_species do ispecies_num = 1 , atoms_species_num ( ispecies ) do iam = 1 , max_am if ( projection_array ( ispecies , ispecies_num , iam , iproj ) == 1 ) then write ( pdos_file , '(1a,a1,a13,i3,a18,15x,a4,23x,1a)' ) \"#\" , \"|\" , proj_symbol ( ispecies ), & & ispecies_num , channel_to_am ( iam ), 'Down' , '|' end if end do end do end do write ( pdos_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' end do dos_partial (:, 2 , :) = - dos_partial (:, 2 , :) do idos = 1 , dos_nbins write ( pdos_file , '(es14.7,' // trim ( string ) // trim ( string ) // ')' ) E_shift ( idos ), ( dos_partial ( idos , 1 , i ), & & i = start_proj , stop_proj ), ( dos_partial ( idos , 2 , i ), i = start_proj , stop_proj ) end do else do iproj = start_proj , stop_proj write ( pdos_file , '(1a,a1,a12,i4,a10,50x,a1)' ) '#' , '|' , ' Column: ' , iproj , ' contains:' , '|' write ( pdos_file , '(1a,a1,a16,10x,a14,36x,a1)' ) '#' , '|' , ' Atom ' , ' AngM Channel ' , '|' do ispecies = 1 , num_species do ispecies_num = 1 , atoms_species_num ( ispecies ) do iam = 1 , max_am if ( projection_array ( ispecies , ispecies_num , iam , iproj ) == 1 ) then write ( pdos_file , '(1a,a1,a13,i3,a18,42x,a1)' ) \"#\" , \"|\" , proj_symbol ( ispecies ), & & ispecies_num , channel_to_am ( iam ), '|' end if end do end do end do write ( pdos_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' end do do idos = 1 , dos_nbins write ( pdos_file , '(es14.7,' // trim ( string ) // ')' ) E_shift ( idos ), ( dos_partial ( idos , 1 , i ), i = start_proj , stop_proj ) end do end if close ( pdos_file ) deallocate ( E_shift , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating E_shift in write_proj_to_file' ) end subroutine write_proj_to_file subroutine pdos_report_projectors use od_algorithms , only : channel_to_am use od_cell , only : atoms_species_num , num_species use od_io , only : stdout implicit none integer :: iproj , iam , ispecies_num , ispecies write ( stdout , * ) write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a)' ) '|                    Partial Density of States -- Projectors                 |' write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' do iproj = 1 , num_proj write ( stdout , '(1x,a1,a12,i4,a10,50x,a1)' ) '|' , ' Column: ' , iproj , ' contains:' , '|' write ( stdout , '(1x,a1,a16,10x,a14,36x,a1)' ) '|' , ' Atom ' , ' AngM Channel ' , '|' do ispecies = 1 , num_species do ispecies_num = 1 , atoms_species_num ( ispecies ) do iam = 1 , max_am if ( projection_array ( ispecies , ispecies_num , iam , iproj ) == 1 ) then write ( stdout , '(1x,a1,a13,i3,a18,42x,a1)' ) \"|\" , proj_symbol ( ispecies ), & ispecies_num , channel_to_am ( iam ), '|' !, \" |  DEBUG :\",  ispecies ,iam end if end do end do end do write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' end do end subroutine pdos_report_projectors !!$!=============================================================================== !!$ subroutine count_atoms(orbital,num_orbitals,num_atoms) !!$!=============================================================================== !!$! From the program LinDOS (AJM) !!$! Take the orbial information and work out the number of atoms that the LCAO !!$! describe !!$!=============================================================================== !!$   use od_io, only : io_error !!$   implicit none !!$   integer, intent(in)            :: num_orbitals !!$   type(orbitals), intent(inout)  :: orbital(1:num_orbitals) ! sepcies, ! num of each species ! l channel !!$   integer, intent(out)           :: num_atoms !!$ !!$   integer, allocatable           :: species_count(:) !!$   integer                        :: num_species, ion_count !!$   integer                        :: i, ierr !!$ !!$   num_species=maxval(orbital(:)%species_no)  ! The maximum value is the highest species rank !!$ !!$   allocate(species_count(1:num_species), stat=ierr) !!$   if(ierr/=0) call io_error( \" Error : cannot allocate species_count\") !!$ !!$   species_count=0 !!$   ion_count=0 !!$ !!$   do i=1,num_orbitals !!$    ! If the species number is greater than the number we have for that species then use this !!$    ! new number instead !!$    ! NB I'm using data from the array orbital to index species count! :S !!$    if(orbital(i)%rank_in_species>species_count(orbital(i)%species_no)) then !!$      species_count(orbital(i)%species_no)=orbital(i)%rank_in_species !!$      ion_count=ion_count+1 !!$    endif !!$    orbital(i)%ion_no=ion_count !!$   enddo !!$ !!$   num_atoms=sum(species_count(:)) !!$ !!$   if(allocated(species_count)) then !!$     deallocate(species_count, stat=ierr) !!$     if(ierr/=0) stop \" Error : cannot deallocate  species_count\" !!$   endif !!$  end subroutine count_atoms !!$  subroutine general_write_pdos !!$    !=============================================================================== !!$    ! Write out the pdos that was requested. Make a pretty header so that the user !!$    ! knows what each column means !!$    !=============================================================================== !!$    use od_dos_utils,       only : E !!$    use od_parameters,only : dos_nbins !!$    use od_algorithms, only : channel_to_am !!$    use od_electronic, only         : pdos_mwab !!$    use od_cell, only : atoms_species_num, num_species !!$    use od_io, only : io_file_unit, seedname, io_error, io_date !!$ !!$    implicit none !!$ !!$   character(len=11) :: cdate !!$   character(len=9) :: ctime !!$    character(len=20) :: string, filename !!$    integer :: iproj, iam, ispecies_num, ispecies, species, species_num !!$    integer :: last_species, last_species_num !!$    integer :: idos, i, pdos_file,ierr, start_proj !!$ !!$    logical :: projector_to_file !!$ !!$ !!$    write(string,'(I4,\"(x,es14.7)\")') pdos_mwab%norbitals !!$ !!$    start_proj=1 !!$    projectors: do iproj=1,num_proj !!$       projector_to_file=.false. !!$ !!$       ! Are we writing .pdos.projX.dat or .pdos.AtomAtomNo.dat? !!$       ! does this projector contain more than one atom? !!$       do iam=1,max_am !!$          if(sum(projection_array(:,:,iam,iproj))>1) then !!$             ! Yes it does contain more than one atom !!$             projector_to_file=.true. !!$          endif !!$       enddo !!$ !!$       if(projector_to_file) then !!$          ! Then let's write out this projector and move on to the next one !!$ !!$          ! Must first check whether this isn't the last one in a previous projector group !!$          if(start_proj.ne.iproj) then ! Yes it is. !!$             write(string,'(I20)') last_species_num !!$             filename=proj_symbol(last_species)//adjustl(string) !!$             write(*,*) \"So write out Projectors \", start_proj,\" to \", iproj, \" to file \", & !!$                  & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\" !!$             call write_proj_to_file(start_proj, iproj, filename) !!$             start_proj=iproj+1 ! Reset start counter, and we've written the current one. !!$             cycle projectors !!$          endif !!$ !!$          write(*,*) \"For proj:\", iproj, \"there is more than one atom\" !!$          write(*,*) \"Hence we're writing projectors to files\" !!$          write(string,'(I20)') iproj !!$          filename=\"proj\"//adjustl(string) !!$          write(*,*) \"So write out Projectors \", start_proj,\" to \", iproj, \" to file \", & !!$               & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\" !!$          call write_proj_to_file(iproj,iproj,filename) !!$          start_proj=iproj+1 ! Reset start counter, and we've written the current one. !!$          cycle projectors !!$       endif !!$ !!$       ! Since we're not writing just one projector to the file, we're going to have to work out !!$       ! how many projectors there are going to be in this file. !!$       ! Work out the species and species_rank of this projector !!$       scan: do iam=1,max_am !!$          do ispecies_num=1,maxval(atoms_species_num) !!$             do  ispecies=1,num_species !!$                if(projection_array(ispecies,ispecies_num,iam,iproj)==1) then !!$                   species=ispecies !!$                   species_num=ispecies_num !!$                   write(*,*) \"Projector \",iproj,\" is Species \", ispecies, \" Rank \", ispecies_num !!$                   exit scan !!$                endif !!$             enddo !!$          enddo !!$       enddo scan !!$ !!$       ! First time through we just put the info about this projector into the registry !!$       if(iproj==start_proj) then !!$          write(*,*) \"Skipping over projector:\", iproj,\" as we've nothing to compare it against yet\" !!$          last_species=species !!$          last_species_num=species_num !!$          start_proj=iproj !!$       ! If this is the same species as the last one. We go around again. !!$       elseif((species==last_species).and.(species_num==last_species_num)) then !!$          write(*,*) \"Projector \", iproj, \" has the same Species and Rank as \", start_proj !!$          last_species=species !!$          last_species_num=species_num !!$       else ! We've come to the end of the projector group, so need to write out all the old ones. !!$          write(*,*) \"Projector \", iproj, \" has different Species and Rank to \", start_proj !!$          write(string,'(I20)') iproj !!$          filename=trim(proj_symbol(species))//adjustl(string) !!$          write(*,*) \"So write out Projectors \", start_proj,\" to \", iproj-1, \" to file \", & !!$               & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\" !!$          call write_proj_to_file(start_proj, iproj-1,filename) !!$          start_proj=iproj ! Since we haven't written the current projector yet !!$          last_species=species !!$          last_species_num=species_num !!$       endif !!$ !!$       ! If this is our last loop, then we'd better write the last on out too. !!$       if(iproj==num_proj) then !!$          write(*,*) \"Last Projector group \", start_proj, \" to \", iproj !!$          write(string,'(I20)') iproj !!$          filename=trim(proj_symbol(species))//adjustl(string) !!$          write(*,*) \"So write out Projectors \", start_proj,\" to \", iproj, \" to file \",& !!$               & trim(seedname)//\".pdos.\"//trim(filename)//\".dat\" !!$          call write_proj_to_file(start_proj, iproj, filename) !!$       endif !!$ !!$    enddo projectors !!$    return !!$  end subroutine general_write_pdos end module od_pdos","tags":"","loc":"sourcefile/pdos.f90.html"},{"title":"projection_utils.f90 – OptaDOS","text":"This file depends on sourcefile~~projection_utils.f90~~EfferentGraph sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~constants.f90 constants.f90 sourcefile~projection_utils.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~cell.f90 cell.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~io.f90 io.f90 sourcefile~projection_utils.f90->sourcefile~io.f90 sourcefile~comms.f90 comms.F90 sourcefile~projection_utils.f90->sourcefile~comms.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~projection_utils.f90~~AfferentGraph sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~optados.f90->sourcefile~pdis.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_projection_utils Source Code projection_utils.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! MODULE od_projection_utils ! This module contains all of the routines to read projections of DOS and dispersion ! curves from CASTEP pdos_bin files, as well as parsing the user-requested projectors. ! It provides most calculated arrays as globals, namely: ! !    - projection_array: array of projections for all projectors returned by CASTEP. !    - matrix_weights: weights of desired projectors by (projector, band, kpoint, spin). !    - proj_{symbol,am,sites}: array of projections split by OptaDOS shortcuts. ! ! as well as a few global variables, `num_proj` and `shortcut`. !------------------------------------------------------------------------------- module od_projection_utils use od_constants , only : dp implicit none !-------------------------------------------------------------------------! ! G L O B A L   V A R I A B L E S !-------------------------------------------------------------------------! real ( kind = dp ), allocatable , public , dimension (:, :, :, :) :: matrix_weights integer , public , allocatable :: projection_array (:, :, :, :) integer , public :: num_proj integer , public , parameter :: max_am = 4 ! s,p,d,f  hard coded! ! Data derived from the info in the pdos_weights file character ( len = 3 ), public , allocatable :: proj_symbol (:) ! symbols integer , public , allocatable :: proj_am (:, :) ! angular mtm (num_species,max_am) integer , public , allocatable :: proj_sites (:) ! number of each species logical , public :: shortcut !-------------------------------------------------------------------------! private public :: projection_merge , projection_get_string , projection_analyse_orbitals contains !=============================================================================== subroutine projection_merge !=============================================================================== ! This subroutine accumulates the weights of desired projectors into the ! matrix_weights array. !=============================================================================== use od_electronic , only : pdos_orbital , pdos_weights , pdos_mwab , nspins use od_cell , only : num_kpoints_on_node use od_comms , only : my_node_id use od_io , only : io_error , stdout implicit none integer :: N , N_spin , n_eigen , nproj , orb , ierr allocate ( matrix_weights ( num_proj , pdos_mwab % nbands , num_kpoints_on_node ( my_node_id ), nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_merge - allocation of matrix_weights failed' ) matrix_weights = 0.0_dp do N = 1 , num_kpoints_on_node ( my_node_id ) ! Loop over kpoints do N_spin = 1 , nspins ! Loop over spins do n_eigen = 1 , pdos_mwab % nbands ! Loop over unoccupied states do nproj = 1 , num_proj do orb = 1 , pdos_mwab % norbitals if ( projection_array ( pdos_orbital % species_no ( orb ), pdos_orbital % rank_in_species ( orb ) & , pdos_orbital % am_channel ( orb ) + 1 , nproj ) == 1 ) then matrix_weights ( nproj , n_eigen , N , N_spin ) = matrix_weights ( nproj , n_eigen , N , N_spin ) + & pdos_weights ( orb , n_eigen , N , N_spin ) end if end do end do end do end do end do return end subroutine projection_merge !=============================================================================== subroutine projection_get_string !=============================================================================== ! This is a mindbendingly horrific exercise in book-keeping !=============================================================================== use od_parameters , only : projectors_string use od_cell , only : num_species , atoms_species_num use od_io , only : maxlen , io_error implicit none character ( len = maxlen ) :: ctemp , ctemp2 , ctemp3 integer :: loop4 , loop3 , loop2 , ierr logical :: pdos_sum integer :: loop , pos , loop_l , loop_a , loop_p integer :: i_digit , species_count , species_proj character ( len = 1 ), parameter :: c_sep = \":\" integer , allocatable :: pdos_temp (:, :, :, :) !Check for any short cuts shortcut = . false . ctemp = projectors_string if ( index ( ctemp , 'species_ang' ) > 0 ) then num_proj = 0 do loop = 1 , num_species num_proj = num_proj + count ( proj_am ( loop , :) == 1 ) end do allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 loop_p = 1 do loop = 1 , num_species do loop_l = 1 , max_am if ( proj_am ( loop , loop_l ) == 0 ) cycle projection_array ( loop , :, loop_l , loop_p ) = 1 loop_p = loop_p + 1 end do end do shortcut = . true . elseif ( index ( ctemp , 'species' ) > 0 ) then num_proj = num_species allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 do loop = 1 , num_species projection_array ( loop , :, :, loop ) = 1 end do shortcut = . true . elseif ( index ( ctemp , 'sites' ) > 0 ) then num_proj = 0 do loop = 1 , num_species num_proj = num_proj + proj_sites ( loop ) end do allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 loop_p = 1 do loop = 1 , num_species do loop_a = 1 , proj_sites ( loop ) projection_array ( loop , loop_a , :, loop_p ) = 1 loop_p = loop_p + 1 end do end do shortcut = . true . elseif ( index ( ctemp , 'angular' ) > 0 ) then num_proj = max_am allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 loop_p = 0 do loop = 1 , num_proj projection_array (:, :, loop , loop ) = 1 end do shortcut = . true . end if if (. not . shortcut ) then !look for sum ctemp = projectors_string pdos_sum = . false . if ( index ( ctemp , 'sum:' ) == 1 ) then pdos_sum = . true . ctemp = ctemp ( 5 :) end if ! take 1st part of string ctemp2 = ctemp species_count = 1 ; num_proj = 0 do !look for each species section ! and pass to find number of projections pos = index ( ctemp2 , c_sep ) if ( pos == 0 ) then ctemp3 = ctemp2 else ctemp3 = ctemp2 ( 1 : pos - 1 ) end if call projection_analyse_substring ( ctemp3 , species_proj ) num_proj = num_proj + species_proj if ( pos == 0 ) exit species_count = species_count + 1 ctemp2 = ctemp2 ( pos + 1 :) end do ! now allocate the correct sized array allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 ctemp2 = ctemp do loop = 1 , species_count !loop for each species section !and pass fill in projection pos = index ( ctemp2 , c_sep ) if ( pos == 0 ) then ctemp3 = ctemp2 else ctemp3 = ctemp2 ( 1 : pos - 1 ) end if call projection_analyse_substring ( ctemp3 ) ctemp2 = ctemp2 ( pos + 1 :) end do if ( pdos_sum ) then allocate ( pdos_temp ( num_species , maxval ( atoms_species_num ), max_am , 1 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of pdos_temp failed' ) pdos_temp = 0 do loop4 = 1 , num_proj do loop3 = 1 , max_am do loop2 = 1 , maxval ( atoms_species_num ) do loop = 1 , num_species if ( projection_array ( loop , loop2 , loop3 , loop4 ) == 1 ) then pdos_temp ( loop , loop2 , loop3 , 1 ) = 1 end if end do end do end do end do deallocate ( projection_array , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - deallocation of projection_array failed' ) num_proj = 1 allocate ( projection_array ( num_species , maxval ( atoms_species_num ), max_am , num_proj ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_get_string - allocation of projection_array failed' ) projection_array = 0 projection_array = pdos_temp end if end if return contains !=============================================================================== subroutine projection_analyse_substring ( ctemp , species_proj ) !=============================================================================== ! This is a mindbendingly horrific exercise in book-keeping !=============================================================================== use od_cell , only : num_species , atoms_species_num use od_io , only : maxlen , io_error implicit none character ( len = maxlen ), intent ( inout ) :: ctemp integer , optional , intent ( out ) :: species_proj integer , save :: offset = 0 character ( len = maxlen ) :: ctemp2 , c_am , m_string integer :: pos_l , pos_r , ia , iz , idiff , ic1 , ic2 , species , num_sites , num_am character ( len = 3 ) :: c_symbol = '   ' logical :: am_sum , site_sum integer :: num1 , num2 , i_punc , pos3 , loop_l , loop_a , loop_p , loop_j integer :: counter , loop_r , range_size , ierr character ( len = maxlen ) :: dummy character ( len = 10 ), parameter :: c_digit = \"0123456789\" character ( len = 1 ), parameter :: c_range = \"-\" character ( len = 1 ), parameter :: c_sep = \",\" character ( len = 4 ), parameter :: c_punc = \" ,-:\" character ( len = 5 ) :: c_num1 , c_num2 integer , allocatable :: pdos_atoms (:), pdos_ang (:) logical :: lcount allocate ( pdos_atoms ( maxval ( atoms_species_num )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of pdos_atoms failed' ) allocate ( pdos_ang ( max_am ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of pdos_ang failed' ) lcount = . false . if ( present ( species_proj )) lcount = . true . pdos_atoms = 0 ; pdos_ang = 0 site_sum = . false . am_sum = . false . ! look for Ang Mtm string eg (s,p) c_am = '' pos_l = index ( ctemp , '(' ) if ( pos_l > 0 ) then pos_r = index ( ctemp , ')' ) if ( pos_r == 0 ) call io_error ( 'projection_analyse_substring: found ( but no )' ) if ( pos_r <= pos_l ) call io_error ( 'projection_analyse_substring: found ) before (' ) c_am = ctemp ( pos_l + 1 : pos_r - 1 ) ctemp = ctemp (: pos_l - 1 ) else ! implicit sum over AM am_sum = . true . end if ia = ichar ( 'a' ) iz = ichar ( 'z' ) idiff = ichar ( 'Z' ) - ichar ( 'z' ) ic1 = ichar ( ctemp ( 1 : 1 )) if ( ic1 < ia . or . ic1 > iz ) call io_error ( 'projection_analyse_substring: problem reading atomic symbol in pdos string' ) ic2 = ichar ( ctemp ( 2 : 2 )) if ( ic2 >= ia . and . ic1 <= iz ) then c_symbol ( 1 : 1 ) = char ( ic1 + idiff ) c_symbol ( 2 : 2 ) = ctemp ( 2 : 2 ) ctemp = ctemp ( 3 :) else c_symbol ( 1 : 1 ) = char ( ic1 + idiff ) c_symbol ( 2 : 2 ) = '' ctemp = ctemp ( 2 :) end if species = 0 do loop_j = 1 , num_species if ( adjustl ( c_symbol ) == adjustl ( proj_symbol ( loop_j ))) then species = loop_j end if end do if ( species == 0 ) call io_error ( 'projection_analyse_substring: Failed to match atomic symbol in pdos string' ) !Count atoms numbers counter = 0 dummy = adjustl ( ctemp ) if ( len_trim ( dummy ) > 0 ) then dummy = adjustl ( dummy ) do i_punc = scan ( dummy , c_punc ) if ( i_punc == 0 ) call io_error ( 'projection_analyse_substring: error looking for atom numbers' ) c_num1 = dummy ( 1 : i_punc - 1 ) read ( c_num1 , * , err = 101 , end = 101 ) num1 dummy = adjustl ( dummy ( i_punc :)) !look for range if ( scan ( dummy , c_range ) == 1 ) then i_digit = scan ( dummy , c_digit ) dummy = adjustl ( dummy ( i_digit :)) i_punc = scan ( dummy , c_punc ) c_num2 = dummy ( 1 : i_punc - 1 ) read ( c_num2 , * , err = 101 , end = 101 ) num2 dummy = adjustl ( dummy ( i_punc :)) range_size = abs ( num2 - num1 ) + 1 do loop_r = 1 , range_size counter = counter + 1 if ( min ( num1 , num2 ) + loop_r - 1 > proj_sites ( species )) & call io_error ( 'projection_analyse_substring: Atom number given in pdos string & &is greater than number of atoms for given species' ) pdos_atoms ( min ( num1 , num2 ) + loop_r - 1 ) = 1 end do else counter = counter + 1 if ( num1 > proj_sites ( species )) & call io_error ( 'projection_analyse_substring: Atom number given in pdos string & &is greater than number of atoms for given species' ) pdos_atoms ( num1 ) = 1 end if if ( scan ( dummy , c_sep ) == 1 ) dummy = adjustl ( dummy ( 2 :)) if ( scan ( dummy , c_range ) == 1 ) & & call io_error ( 'projection_analyse_substring: Error parsing atoms numbers - incorrect range' ) if ( index ( dummy , ' ' ) == 1 ) exit end do else site_sum = . true . end if ! count am counter = 0 dummy = adjustl ( c_am ) if ( len_trim ( dummy ) > 0 ) then do pos3 = index ( dummy , ',' ) if ( pos3 == 0 ) then ctemp2 = dummy else ctemp2 = dummy (: pos3 - 1 ) end if read ( ctemp2 ( 1 :), * , err = 106 , end = 106 ) m_string select case ( trim ( adjustl ( m_string ))) case ( 's' ) pdos_ang ( 1 ) = 1 case ( 'p' ) pdos_ang ( 2 ) = 1 case ( 'd' ) pdos_ang ( 3 ) = 1 case ( 'f' ) pdos_ang ( 4 ) = 1 case default call io_error ( 'projection_analyse_substring: Problem reading l state ' ) end select if ( pos3 == 0 ) exit dummy = dummy ( pos3 + 1 :) end do else am_sum = . true . end if if ( site_sum ) then num_sites = 1 else num_sites = count ( pdos_atoms == 1 ) end if if ( am_sum ) then num_am = 1 else num_am = count ( pdos_ang == 1 ) end if if ( lcount ) species_proj = num_am * num_sites if (. not . lcount ) then loop_p = 1 + offset if ( site_sum . and . am_sum ) then projection_array ( species , :, :, loop_p ) = 1 elseif ( site_sum . and . . not . am_sum ) then do loop_l = 1 , max_am if ( pdos_ang ( loop_l ) == 0 ) cycle projection_array ( species , :, loop_l , loop_p ) = 1 loop_p = loop_p + 1 end do elseif (. not . site_sum . and . am_sum ) then do loop_a = 1 , proj_sites ( species ) if ( pdos_atoms ( loop_a ) == 0 ) cycle projection_array ( species , loop_a , :, loop_p ) = 1 loop_p = loop_p + 1 end do else do loop_l = 1 , max_am if ( pdos_ang ( loop_l ) == 0 ) cycle do loop_a = 1 , proj_sites ( species ) if ( pdos_atoms ( loop_a ) == 0 ) cycle projection_array ( species , loop_a , loop_l , loop_p ) = 1 loop_p = loop_p + 1 end do end do end if offset = loop_p - 1 end if return 101 call io_error ( 'projection_analyse_substring Error parsing keyword ' ) 106 call io_error ( 'projection_analyse_substring: Problem reading l state into string ' ) end subroutine projection_analyse_substring end subroutine projection_get_string subroutine projection_analyse_orbitals use od_electronic , only : pdos_orbital , pdos_mwab use od_cell , only : atoms_symbol , num_species use od_constants , only : periodic_table_name use od_io , only : io_error implicit none integer :: loop , loop2 , counter , ierr if ( maxval ( pdos_orbital % species_no (:)) > num_species ) & call io_error ( 'Error: projection_analyse_substring - more species in pdos file than in cell file' ) allocate ( proj_sites ( maxval ( pdos_orbital % species_no (:))), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of proj_sites failed' ) allocate ( proj_am ( maxval ( pdos_orbital % species_no (:)), max_am ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of proj_am failed' ) allocate ( proj_symbol ( maxval ( pdos_orbital % species_no (:))), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: projection_analyse_substring - allocation of proj_symbol failed' ) proj_sites = 0 ; proj_am = 0 do loop = 1 , pdos_mwab % norbitals if ( pdos_orbital % rank_in_species ( loop ) > proj_sites ( pdos_orbital % species_no ( loop ))) & proj_sites ( pdos_orbital % species_no ( loop )) = pdos_orbital % rank_in_species ( loop ) if ( pdos_orbital % rank_in_species ( loop ) == 1 ) & proj_am ( pdos_orbital % species_no ( loop ), pdos_orbital % am_channel ( loop ) + 1 ) = 1 end do !Now need to figure out symbols for each species counter = 1 do loop2 = 1 , 109 do loop = 1 , num_species if ( atoms_symbol ( loop ) == periodic_table_name ( loop2 )) then proj_symbol ( counter ) = periodic_table_name ( loop2 ) counter = counter + 1 !check atom count here end if end do end do end subroutine projection_analyse_orbitals end module od_projection_utils","tags":"","loc":"sourcefile/projection_utils.f90.html"},{"title":"algorithms.f90 – OptaDOS","text":"This file depends on sourcefile~~algorithms.f90~~EfferentGraph sourcefile~algorithms.f90 algorithms.f90 sourcefile~constants.f90 constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~io.f90 io.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~comms.f90 comms.F90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~comms.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~algorithms.f90~~AfferentGraph sourcefile~algorithms.f90 algorithms.f90 sourcefile~cell.f90 cell.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~pdos.f90->sourcefile~algorithms.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~pdis.f90->sourcefile~algorithms.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~cell.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~core.f90 core.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~optics.f90 optics.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~cell.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~dos.f90 dos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~dos.f90->sourcefile~electronic.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_algorithms Source Code algorithms.f90 Source Code ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! Module: algorithms                                                      ! ! For low-level algorithms that are not specific to electronic structure  ! !-------------------------------------------------------------------------! ! Modules used:  constants - dp. inv_sqrt_two_pi                          ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! ! Described below                                                         ! !-------------------------------------------------------------------------! ! Necessary conditions:                                                   ! !-------------------------------------------------------------------------! ! Written by Andrew Morris and Chris Picakrd (so far)          11/10/2010 ! !=========================================================================! module od_algorithms use od_constants , only : dp , inv_sqrt_two_pi implicit none private public :: gaussian public :: heap_sort public :: utility_lowercase public :: utility_cart_to_frac public :: utility_frac_to_cart public :: utility_reciprocal_frac_to_cart public :: utility_reciprocal_cart_to_frac public :: channel_to_am public :: algorithms_erf public :: algor_dist_array contains function channel_to_am ( no ) implicit none character ( len = 1 ) :: channel_to_am integer , intent ( in ) :: no select case ( no ) case ( 1 ) channel_to_am = \"s\" case ( 2 ) channel_to_am = \"p\" case ( 3 ) channel_to_am = \"d\" case ( 4 ) channel_to_am = \"f\" case ( 5 ) channel_to_am = \"g\" end select end function channel_to_am !=========================================================================! function gaussian ( m , w , x ) !=========================================================================! ! ** Return value of Gaussian(mean=m,width=w) at position x ! I don't know who's this function originally was, CJP? MIJP? !=========================================================================! implicit none real ( kind = dp ), intent ( in ) :: m , w , x real ( kind = dp ) :: gaussian if ( 0.5_dp * (( x - m ) / w ) ** 2 . gt . 3 0.0_dp ) then gaussian = 0.0_dp return else gaussian = inv_sqrt_two_pi * exp ( - 0.5_dp * (( x - m ) / w ) ** 2 ) / w end if return end function gaussian !=========================================================================! subroutine heap_sort ( num_items , weight ) !=========================================================================! ! This subroutine sorts the list of weights into descending order.        ! ! On exit, if present, the array of indexes contains the original index   ! ! of each item.                                                           ! !                                                                         ! ! This is a heap sort                                                     ! !-------------------------------------------------------------------------! ! Arguments:                                                              ! !   num_items (input) :: The number of items to sort                      ! !   weight (in/out) :: The weights of each item. On exit these are        ! !                      sorted into descending order.                      ! !-------------------------------------------------------------------------! ! Parent module variables used:                                           ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Modules used:                                                           ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Necessary conditions:                                                   ! !   None                                                                  ! !-------------------------------------------------------------------------! ! Written by Chris Pickard 22nd May 2009                                  ! !=========================================================================! implicit none ! Arguments integer , intent ( in ) :: num_items real ( kind = dp ), dimension ( num_items ), intent ( inout ) :: weight ! Local variables integer :: i , ir , j , l ! Loop counters real ( kind = dp ) :: wta if ( num_items . lt . 2 ) return l = num_items / 2 + 1 ir = num_items do if ( l . gt . 1 ) then l = l - 1 wta = weight ( l ) else wta = weight ( ir ) weight ( ir ) = weight ( 1 ) ir = ir - 1 if ( ir . eq . 1 ) then weight ( 1 ) = wta return end if end if i = l j = l + l 20 if ( j . le . ir ) then if ( j . lt . ir ) then if ( weight ( j ) . lt . weight ( j + 1 )) j = j + 1 end if if ( wta . lt . weight ( j )) then weight ( i ) = weight ( j ) i = j j = j + j else j = ir + 1 end if goto 20 end if weight ( i ) = wta end do end subroutine heap_sort !=========================================================================! function utility_lowercase ( string ) !=========================================================================! ! Takes a string and converts to lowercase characters !=========================================================================! use od_io , only : maxlen implicit none character ( len =* ), intent ( in ) :: string character ( len = maxlen ) :: utility_lowercase integer :: iA , iZ , idiff , ipos , ilett iA = ichar ( 'A' ) iZ = ichar ( 'Z' ) idiff = iZ - ichar ( 'z' ) utility_lowercase = string do ipos = 1 , len ( string ) ilett = ichar ( string ( ipos : ipos )) if (( ilett . ge . iA ) . and . ( ilett . le . iZ )) & utility_lowercase ( ipos : ipos ) = char ( ilett - idiff ) end do utility_lowercase = trim ( adjustl ( utility_lowercase )) return end function utility_lowercase !=================================================================== subroutine utility_frac_to_cart ( frac , cart , real_lat ) !==================================================================! !                                                                  ! !  Convert from fractional to Cartesian coordinates                ! !                                                                  ! !=================================================================== implicit none real ( kind = dp ), intent ( in ) :: real_lat ( 3 , 3 ) real ( kind = dp ), intent ( in ) :: frac ( 3 ) real ( kind = dp ), intent ( out ) :: cart ( 3 ) integer :: i do i = 1 , 3 cart ( i ) = real_lat ( 1 , i ) * frac ( 1 ) + real_lat ( 2 , i ) * frac ( 2 ) + real_lat ( 3 , i ) * frac ( 3 ) end do return end subroutine utility_frac_to_cart !=================================================================== subroutine utility_cart_to_frac ( cart , frac , recip_lat ) !==================================================================! !                                                                  ! !  Convert from fractional to Cartesian coordinates                ! !                                                                  ! !=================================================================== use od_constants , only : twopi implicit none real ( kind = dp ), intent ( in ) :: recip_lat ( 3 , 3 ) real ( kind = dp ), intent ( out ) :: frac ( 3 ) real ( kind = dp ), intent ( in ) :: cart ( 3 ) integer :: i do i = 1 , 3 frac ( i ) = recip_lat ( i , 1 ) * cart ( 1 ) + recip_lat ( i , 2 ) * cart ( 2 ) + recip_lat ( i , 3 ) * cart ( 3 ) end do frac = frac / twopi return end subroutine utility_cart_to_frac !=================================================================== subroutine utility_reciprocal_frac_to_cart ( frac_rec , cart_rec , recip_lattice ) !==================================================================! !                                                                  ! !  Convert k points from fractional to Cartesian coordinates       ! !                                                                  ! !=================================================================== implicit none real ( kind = dp ), intent ( in ) :: recip_lattice ( 3 , 3 ) real ( kind = dp ), intent ( in ) :: frac_rec ( 3 ) real ( kind = dp ), intent ( out ) :: cart_rec ( 3 ) integer :: i do i = 1 , 3 cart_rec ( i ) = recip_lattice ( 1 , i ) * frac_rec ( 1 ) + recip_lattice ( 2 , i ) * frac_rec ( 2 ) + recip_lattice ( 3 , i ) * frac_rec ( 3 ) end do return end subroutine utility_reciprocal_frac_to_cart !=================================================================== subroutine utility_reciprocal_cart_to_frac ( cart , frac , real_lattice ) !==================================================================! !                                                                  ! !  Convert from fractional to Cartesian coordinates in reicprocal  ! !                                                                  ! !=================================================================== use od_constants , only : twopi implicit none real ( kind = dp ), intent ( in ) :: real_lattice ( 3 , 3 ) real ( kind = dp ), intent ( out ) :: frac ( 3 ) real ( kind = dp ), intent ( in ) :: cart ( 3 ) integer :: i do i = 1 , 3 frac ( i ) = real_lattice ( 1 , i ) * cart ( 1 ) + real_lattice ( 2 , i ) * cart ( 2 ) + real_lattice ( 3 , i ) * cart ( 3 ) end do frac = frac / twopi return end subroutine utility_reciprocal_cart_to_frac function algorithms_erf ( x ) ! Calculate the error function ! From the NSWC Mathematics Subroutine Library implicit none real ( kind = dp ), intent ( in ) :: x real ( kind = dp ) :: algorithms_erf real ( kind = dp ) :: C = 0.564189583547756_dp real ( kind = dp ), dimension ( 1 : 5 ) :: A = ( / 0.771058495001320E-04_dp , - 0.133733772997339E-02_dp , & & 0.323076579225834E-01_dp , 0.479137145607681E-01_dp , 0.128379167095513E+00_dp / ) real ( kind = dp ), dimension ( 1 : 3 ) :: B = ( / 0.301048631703895E-02_dp , 0.538971687740286E-01_dp , & & 0.375795757275549E+00_dp / ) real ( kind = dp ), dimension ( 1 : 8 ) :: P = ( /- 1.36864857382717E-07_dp , 5.64195517478974E-01_dp , & & 7.21175825088309E+00_dp , 4.31622272220567E+01_dp , 1.52989285046940E+02_dp , & & 3.39320816734344E+02_dp , 4.51918953711873E+02_dp , 3.00459261020162E+02_dp / ) real ( kind = dp ), dimension ( 1 : 8 ) :: Q = ( / 1.00000000000000E+00_dp , 1.27827273196294E+01_dp , & & 7.70001529352295E+01_dp , 2.77585444743988E+02_dp , 6.38980264465631E+02_dp , & & 9.31354094850610E+02_dp , 7.90950925327898E+02_dp , 3.00459260956983E+02_dp / ) real ( kind = dp ), dimension ( 1 : 5 ) :: R = ( / 2.10144126479064E+00_dp , 2.62370141675169E+01_dp , & & 2.13688200555087E+01_dp , 4.65807828718470E+00_dp , 2.82094791773523E-01_dp / ) real ( kind = dp ), dimension ( 1 : 4 ) :: S = ( / 9.41537750555460E+01_dp , 1.87114811799590E+02_dp , & & 9.90191814623914E+01_dp , 1.80124575948747E+01_dp / ) real ( kind = dp ) :: ax , t , top , bot , x2 AX = abs ( X ) if ( AX <= 0.5_dp ) then T = X * X top = (((( A ( 1 ) * T + A ( 2 )) * T + A ( 3 )) * T + A ( 4 )) * T + A ( 5 )) + 1.0_dp bot = (( B ( 1 ) * T + B ( 2 )) * T + B ( 3 )) * T + 1.0_dp algorithms_erf = X * ( top / bot ) return elseif ( AX <= 4.0_dp ) then top = (((((( P ( 1 ) * AX + P ( 2 )) * AX + P ( 3 )) * AX + P ( 4 )) * AX + P ( 5 )) * AX & & + P ( 6 )) * AX + P ( 7 )) * AX + P ( 8 ) bot = (((((( Q ( 1 ) * AX + Q ( 2 )) * AX + Q ( 3 )) * AX + Q ( 4 )) * AX + Q ( 5 )) * AX & & + Q ( 6 )) * AX + Q ( 7 )) * AX + Q ( 8 ) algorithms_erf = 0.5_dp + ( 0.5_dp - exp ( - X * X ) * top / bot ) if ( X < 0.0_dp ) algorithms_erf = - algorithms_erf return elseif ( AX <= 5.8_dp ) then X2 = X * X T = 1.0_dp / X2 top = ((( R ( 1 ) * T + R ( 2 )) * T + R ( 3 )) * T + R ( 4 )) * T + R ( 5 ) bot = ((( S ( 1 ) * T + S ( 2 )) * T + S ( 3 )) * T + S ( 4 )) * T + 1.0 algorithms_erf = ( C - top / ( X2 * bot )) / AX algorithms_erf = 0.5_dp + ( 0.5_dp - exp ( - X2 ) * algorithms_erf ) if ( X < 0.0_dp ) algorithms_erf = - algorithms_erf return else algorithms_erf = 1.0_dp if ( X < 0.0_dp ) algorithms_erf = - algorithms_erf end if end function algorithms_erf !====================================================== subroutine algor_dist_array ( num_elements , elements_per_node ) ! Takes the number of elements in an array, num_elements ! Returns an array 0,num_nodes-1 which contains the number of ! elements that should be on each node. ! AJM based on an idea from JRY !====================================================== use od_comms , only : num_nodes use od_io , only : io_error implicit none integer , intent ( in ) :: num_elements integer , allocatable , intent ( out ) :: elements_per_node (:) integer :: loop , ierr allocate ( elements_per_node ( 0 : num_nodes - 1 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating elements_per_node in algor_dist_array' ) elements_per_node (:) = num_elements / num_nodes if ( num_elements < num_nodes ) then call io_error ( 'Fewer kpoints than nodes. Reduce the number of nodes used!' ) end if ! Distribute the remainder if ( elements_per_node ( 0 ) * num_nodes . ne . num_elements ) then do loop = 0 , num_elements - elements_per_node ( 0 ) * num_nodes - 1 elements_per_node ( loop ) = elements_per_node ( loop ) + 1 end do end if end subroutine algor_dist_array end module od_algorithms","tags":"","loc":"sourcefile/algorithms.f90.html"},{"title":"optados.f90 – OptaDOS","text":"This file depends on sourcefile~~optados.f90~~EfferentGraph sourcefile~optados.f90 optados.f90 sourcefile~constants.f90 constants.f90 sourcefile~optados.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~cell.f90 cell.f90 sourcefile~optados.f90->sourcefile~cell.f90 sourcefile~io.f90 io.f90 sourcefile~optados.f90->sourcefile~io.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~build.f90 build.f90 sourcefile~optados.f90->sourcefile~build.f90 sourcefile~dos.f90 dos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~optics.f90 optics.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~comms.f90 comms.F90 sourcefile~optados.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~jdos.f90->sourcefile~constants.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~io.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~jdos.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~jdos.f90->sourcefile~xmgrace_utils.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~pdis.f90->sourcefile~constants.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~pdis.f90->sourcefile~io.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~comms.f90 sourcefile~pdis.f90->sourcefile~algorithms.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~pdos.f90->sourcefile~constants.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~pdos.f90->sourcefile~io.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~comms.f90 sourcefile~pdos.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~dos.f90->sourcefile~constants.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~io.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~dos.f90->sourcefile~comms.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~dos.f90->sourcefile~xmgrace_utils.f90 sourcefile~core.f90->sourcefile~constants.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~core.f90->sourcefile~io.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~comms.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~core.f90->sourcefile~xmgrace_utils.f90 sourcefile~optics.f90->sourcefile~constants.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~optics.f90->sourcefile~io.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~optics.f90->sourcefile~comms.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~optics.f90->sourcefile~xmgrace_utils.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~projection_utils.f90->sourcefile~constants.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~io.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~constants.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~io.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs optados Source Code optados.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! program optados !=========================================================================! !                             O P T A D O S                               ! !                      OPTics And Density Of States                       ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! ! Described below.                                                        ! !-------------------------------------------------------------------------! ! Necessary conditions:                                                   ! !-------------------------------------------------------------------------! ! Written by Andrew Morris, Rebecca Nicholls, Chris Pickard               ! !             and Jonathan Yates      2010                                ! !=========================================================================! use od_comms , only : comms_setup , on_root , comms_end , num_nodes use od_constants , only : dp use od_io , only : io_get_seedname , io_time , io_date , io_file_unit ,& ! Functions & stdout , stderr , seedname , options , temp_dir ! Variables use od_parameters , only : param_read , param_write_header , param_Dist , param_write , & param_dealloc , pdos , pdis , dos , jdos , core , optics , photo , iprint , param_write_atomic_coord , & devel_flag , photo_photon_energy , photo_model use od_cell , only : cell_calc_lattice , cell_report_parameters , cell_dist use od_electronic , only : elec_read_band_energy , elec_read_band_energy_ordered , elec_report_parameters use od_dos , only : dos_calculate use od_jdos , only : jdos_calculate use od_core , only : core_calculate use od_pdos , only : pdos_calculate use od_pdis , only : pdis_calculate use od_optics , only : optics_calculate use od_photo , only : photo_calculate use od_build , only : build_info implicit none real ( kind = dp ) :: time0 , time1 ! Variables for timing logical :: odo_found ! Ouptut file exists? character ( len = 9 ) :: stat , pos ! Status and position of .odo file character ( len = 9 ) :: ctime ! Temp. time string character ( len = 11 ) :: cdate ! Temp. date string character ( len = 120 ) :: filename ! Added by Felix Mildner, 03/23 for multi file output ! call sleep(25) time0 = io_time () call comms_setup if ( on_root ) then call io_get_seedname () ! If blank set to seedname='--help' if ( trim ( seedname ) == '-h' . or . trim ( seedname ) == '--help' ) call help_output if ( trim ( seedname ) == '-v' . or . trim ( seedname ) == '--version' ) call version_output !-------------------------------------------------------------------------! ! O R G A N I S E   T H E   E R R O R   F I L E stderr = io_file_unit () ! This is to allow multiple OptaDOS photoemission runs to be performed in the same directory. if (( index ( options , '-temp' ) > 0 )) then filename = trim ( adjustl ( temp_dir )) // '/' // trim ( seedname ) // '.opt_err' open ( unit = stderr , file = filename ) else open ( unit = stderr , file = trim ( seedname ) // '.opt_err' ) end if call io_date ( cdate , ctime ) write ( stderr , * ) 'OptaDOS: Execution started on ' , cdate , ' at ' , ctime !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! O R G A N I S E   T H E   O U T P U T   F I L E  A N D ! R E A D   A N D   W R I T E   U S E R   P A R A M E T E R S call param_read () ! This is to allow multiple simultaneous OptaDOS photoemission runs to be performed in the same directory. if (( index ( options , '-temp' ) /= 0 )) then filename = trim ( adjustl ( temp_dir )) // '/' // trim ( seedname ) // '.odo' inquire ( file = filename , exist = odo_found ) else inquire ( file = trim ( seedname ) // '.odo' , exist = odo_found ) end if if ( odo_found ) then stat = 'old' else stat = 'replace' end if pos = 'append' stdout = io_file_unit () ! This is to allow multiple OptaDOS photoemission runs to be performed in the same directory. if (( index ( options , '-temp' ) /= 0 )) then open ( unit = stdout , file = filename , status = trim ( stat ), position = trim ( pos )) else open ( unit = stdout , file = trim ( seedname ) // '.odo' , status = trim ( stat ), position = trim ( pos )) end if write ( stdout , * ) 'OptaDOS: Execution started on ' , cdate , ' at ' , ctime write ( stdout , '(1x,a26,i5,a10)' ) 'Parallelised over' , num_nodes , ' thread(s)' if ( iprint > 0 ) call param_write_header () if ( iprint > 0 ) call param_write () time1 = io_time () if ( iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read parameters ' , time1 - time0 , ' (sec)' !-------------------------------------------------------------------------! end if if ( pdis ) then call elec_read_band_energy_ordered else call elec_read_band_energy end if if ( on_root ) then call cell_calc_lattice if ( iprint > 0 ) call param_write_atomic_coord if ( iprint > 0 ) call cell_report_parameters if ( iprint > 0 ) call elec_report_parameters end if ! now send the data from the parameter file to each node call param_dist call cell_dist !-------------------------------------------------------------------------! ! C A L L   P D O S   R O U T I N E S if ( pdos ) then time0 = io_time () call pdos_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Projected Density of States          & &      ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   P D I S   R O U T I N E S if ( pdis ) then time0 = io_time () call pdis_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Projected Dispersion & &      ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   C O R E   R O U T I N E S if ( core ) then time0 = io_time () call core_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Core Level Spectra       & &                  ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   D O S  R O U T I N E S if ( dos ) then time0 = io_time () call dos_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Density of States        & &                  ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   O P T I C S   R O U T I N E S if ( optics ) then time0 = io_time () call optics_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Optical properties                         ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   P H O T O E M I S S I O N   R O U T I N E S if ( photo ) then time0 = io_time () call photo_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Photoemission                              ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! C A L L   J D O S   R O U T I N E S if ( jdos ) then time0 = io_time () call jdos_calculate time1 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '|                                                                            |' write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Joint Density of States                    ' , time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' ' write ( stdout , * ) ' ' end if end if !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! F I N A L I S E call param_dealloc if ( on_root ) then call io_date ( cdate , ctime ) write ( stdout , * ) write ( stdout , * ) 'OptaDOS: Execution complete on ' , cdate , ' at ' , ctime close ( stdout ) close ( stderr , status = 'delete' ) end if call comms_end !-------------------------------------------------------------------------! contains subroutine help_output use od_constants , only : optados_version , copyright implicit none write ( * , * ) write ( * , * ) \" OptaDOS version \" , trim ( build_info % build ) write ( * , * ) write ( * , * ) \" Andrew J. Morris, R. J. Nicholls, C. J. Pickard and J. R. Yates\" , trim ( copyright ) write ( * , * ) \" Usage: optados <seedname>\" write ( * , * ) stop end subroutine help_output subroutine version_output use od_build , only : build_info use od_constants , only : optados_version , copyright implicit none write ( * , * ) write ( * , * ) \" OptaDOS version \" , trim ( build_info % build ) write ( * , * ) write ( * , * ) \" Andrew J. Morris, R. J. Nicholls, C. J. Pickard and J. R. Yates\" , trim ( copyright ) write ( * , * ) \" Compiled with \" // trim ( build_info % compiler ) // \" on \" // trim ( build_info % compile_date )& & // \" at \" // trim ( build_info % compile_time ) // \".\" write ( * , * ) \" Compile type: \" // trim ( build_info % build_type ) // \", \" // trim ( build_info % comms_arch ) write ( * , * ) \" From source \" // trim ( build_info % build ) // \" submitted on \" // trim ( build_info % source_date )& & // \" at \" // trim ( build_info % source_time ) // \".\" stop end subroutine version_output end program optados","tags":"","loc":"sourcefile/optados.f90.html"},{"title":"jdos.f90 – OptaDOS","text":"This file depends on sourcefile~~jdos.f90~~EfferentGraph sourcefile~jdos.f90 jdos.f90 sourcefile~constants.f90 constants.f90 sourcefile~jdos.f90->sourcefile~constants.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~io.f90 io.f90 sourcefile~jdos.f90->sourcefile~io.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~comms.f90 comms.F90 sourcefile~jdos.f90->sourcefile~comms.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~jdos.f90->sourcefile~xmgrace_utils.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~cell.f90 cell.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~jdos_utils.f90->sourcefile~constants.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~io.f90 sourcefile~jdos_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~jdos.f90~~AfferentGraph sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~jdos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_jdos Source Code jdos.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=============================================================================== module od_jdos use od_constants , only : dp implicit none !------------------------------------------------------------------------------- ! P U B L I C   F U N C T I O N S public :: jdos_calculate contains !=============================================================================== subroutine jdos_calculate !=============================================================================== use od_jdos_utils , only : jdos_utils_calculate , E , jdos_fixed & &, jdos_adaptive , jdos_linear use od_parameters , only : fixed , adaptive , linear use od_io , only : io_time , stdout use od_comms , only : on_root implicit none real ( kind = dp ) :: time0 , time1 if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                           Joint Density of States                          +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if call jdos_utils_calculate !------------------------------------------------------------------------------- ! W R I T E   O U T   J D O S time0 = io_time () ! Otherwise we have written to wdos and dos, so they can be called ! by whatever. if ( on_root ) then if ( fixed ) call write_jdos ( E , jdos_fixed , \"fixed\" ) if ( adaptive ) call write_jdos ( E , jdos_adaptive , \"adaptive\" ) if ( linear ) call write_jdos ( E , jdos_linear , \"linear\" ) !if(quad)    call write_jdos(E, dos_quad, intdos_quad, \"quad\") end if time1 = io_time () !------------------------------------------------------------------------------- end subroutine jdos_calculate !=============================================================================== subroutine write_jdos ( E , dos , dos_name ) use od_parameters , only : dos_per_volume , output_format use od_jdos_utils , only : jdos_nbins use od_electronic , only : nspins use od_io , only : io_file_unit , seedname , stdout , io_error , io_date !=============================================================================== ! This routine receives an energy scale, a density of states and a file name ! and writes out the DOS to disk !=============================================================================== implicit none real ( kind = dp ), intent ( in ) :: E ( jdos_nbins ) real ( kind = dp ), intent ( in ) :: dos ( jdos_nbins , nspins ) character ( len =* ), intent ( in ) :: dos_name integer :: i , dos_file , ierr character ( len = 11 ) :: cdate character ( len = 9 ) :: ctime character ( len = 22 ) :: dos_units , intdos_units dos_file = io_file_unit () open ( unit = dos_file , file = trim ( seedname ) // '.j' // trim ( dos_name ) // '.dat' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open output file in dos: write_dos\" ) dos_units = \"(electrons per eV)\" ; intdos_units = \"(electrons)\" if ( dos_per_volume ) then dos_units = \"(electrons per eV/A&#94;3)\" intdos_units = \"(electrons per A&#94;3)\" end if write ( dos_file , * ) \"##############################################################################\" write ( dos_file , * ) \"#\" write ( dos_file , * ) \"#                  O p t a D O S   o u t p u t   f i l e \" write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , * ) \"#    Density of States using \" , trim ( dos_name ), \" broadening\" call io_date ( cdate , ctime ) write ( dos_file , * ) '#  Generated on ' , cdate , ' at ' , ctime write ( dos_file , * ) \"# Column        Data\" write ( dos_file , * ) \"#    1        Energy (eV)\" if ( nspins > 1 ) then write ( dos_file , * ) \"#    2        Up-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Down-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    4        Up-spin Integrated DOS \" , trim ( intdos_units ) write ( dos_file , * ) \"#    5        Down-spin Integrated DOS \" , trim ( intdos_units ) else write ( dos_file , * ) \"#    2        DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Integrated DOS \" , trim ( intdos_units ) end if write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , '(1x,a78)' ) \"##############################################################################\" if ( nspins > 1 ) then do i = 1 , jdos_nbins write ( dos_file , '(3(E21.13,2x))' ) E ( i ), dos ( i , 1 ), - dos ( i , 2 ) end do else do i = 1 , jdos_nbins write ( dos_file , '(2(E21.13,2x))' ) E ( i ), dos ( i , 1 ) end do end if close ( dos_file ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_jdos_xmgrace ( dos_name , E , dos ) elseif ( trim ( output_format ) == \"gnuplot\" ) then write ( stdout , * ) \" WARNING: GNUPLOT output not yet available, calling xmgrace\" call write_jdos_xmgrace ( dos_name , E , dos ) !     call write_dos_gnuplot(dos_name,E,dos) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_jdos !=============================================================================== !=============================================================================== subroutine write_jdos_xmgrace ( dos_name , E , dos ) !=============================================================================== use xmgrace_utils use od_jdos_utils , only : jdos_nbins use od_electronic , only : nspins use od_io , only : io_file_unit , io_error , seedname implicit none real ( kind = dp ), intent ( in ) :: E ( jdos_nbins ) real ( kind = dp ), intent ( in ) :: dos ( jdos_nbins , nspins ) real ( kind = dp ) :: min_x , max_x , min_y , max_y integer :: batch_file , ierr character ( len =* ), intent ( in ) :: dos_name batch_file = io_file_unit () open ( unit = batch_file , file = trim ( seedname ) // '.j' // trim ( dos_name ) // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in dos: write_jdos_xmgrace\" ) min_x = minval ( E ) max_x = maxval ( E ) min_y = 0 max_y = maxval ( dos ) if ( nspins > 1 ) then min_y = - max_y end if call xmgu_setup ( batch_file ) call xmgu_legend ( batch_file ) call xmgu_title ( batch_file , min_x , max_x , min_y , max_y , \"Joint Electronic Density of States\" ) call xmgu_subtitle ( batch_file , \"Generated by OptaDOS\" ) call xmgu_axis ( batch_file , \"x\" , \"Energy eV\" ) call xmgu_axis ( batch_file , \"y\" , \"JDOS\" ) if ( nspins > 1 ) then call xmgu_data_header ( batch_file , 0 , 1 , \"up-spin channel\" ) call xmgu_data_header ( batch_file , 1 , 2 , \"down-spin channel\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) call xmgu_data ( batch_file , 1 , E (:), - dos (:, 2 )) else call xmgu_data_header ( batch_file , 0 , 1 , \"Total JDOS\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) end if close ( batch_file ) end subroutine write_jdos_xmgrace end module od_jdos","tags":"","loc":"sourcefile/jdos.f90.html"},{"title":"dos_utils.f90 – OptaDOS","text":"This file depends on sourcefile~~dos_utils.f90~~EfferentGraph sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~constants.f90 constants.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~io.f90 io.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~comms.f90 comms.F90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~cell.f90 cell.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~dos_utils.f90~~AfferentGraph sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~dos.f90 dos.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90 optics.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~core.f90 core.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_dos_utils Source Code dos_utils.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=============================================================================== ! MODULE od_dos  OptaDOS - Density of States ! This is the module that contains all if the DOS routines. It is used through ! the global calculate_dos subroutine !------------------------------------------------------------------------------- ! Three other global routines are available, dos_merge, doslin and ! doslin_sub_cell_corners, these are currently used by the jdos module and ! routines. !------------------------------------------------------------------------------- ! Written by: A J Morris Nov - Dec 2010 Modified from LinDOS (CJP+AJM) !=============================================================================== module od_dos_utils use od_constants , only : dp use od_electronic , only : matrix_weights_array_boundaries implicit none !------------------------------------------------------------------------------- ! D E R I V E D   P R O T O T Y P E S !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! P U B L I C   V A R I A B L E S real ( kind = dp ), allocatable , public , save :: dos_adaptive (:, :) real ( kind = dp ), allocatable , public , save :: dos_fixed (:, :) real ( kind = dp ), allocatable , public , save :: dos_linear (:, :) real ( kind = dp ), allocatable , public , save :: intdos_adaptive (:, :) real ( kind = dp ), allocatable , public , save :: intdos_fixed (:, :) real ( kind = dp ), allocatable , public , save :: intdos_linear (:, :) real ( kind = dp ), allocatable , public , save :: E (:) real ( kind = dp ), public , save :: vbm_energy = 0.0_dp real ( kind = dp ), public , save :: cbm_energy = 0.0_dp real ( kind = dp ), public , save :: efermi_fixed real ( kind = dp ), public , save :: efermi_adaptive real ( kind = dp ), public , save :: efermi_linear !real(kind=dp), public, save :: efermi_quad !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! P U B L I C   F U N C T I O N S public :: dos_utils_calculate public :: dos_utils_deallocate public :: dos_utils_calculate_at_e public :: dos_utils_merge ! Used by od_jdos public :: doslin_sub_cell_corners ! Used by od_jdos public :: doslin ! Used by od_jdos public :: dos_utils_compute_dos_at_efermi public :: dos_utils_compute_bandgap public :: dos_utils_compute_band_energies public :: dos_utils_set_efermi !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! P R I V A T E   V A R I A B L E S private ! unless otherwise indicated type ( matrix_weights_array_boundaries ) :: mw real ( kind = dp ), save :: delta_bins ! Width of bins logical :: calc_weighted_dos !------------------------------------------------------------------------------- contains !=============================================================================== subroutine dos_utils_calculate ( matrix_weights , weighted_dos ) !=============================================================================== ! Main routine in dos module, drives the calculation of density of states for ! both task : dos and also if it is required elsewhere. !------------------------------------------------------------------------------- ! Arguments: matrix_weigths (in) (opt) : LCAO or other weightings for DOS !            weighted_dos   (out)(opt) : Output DOS weigthed by matrix_weights !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw, E, dos_adaptive, dos_fixed, dos_linear ! intdos_adaptive, intdos_fixed, intdos_linear, efermi_fixed, efermi_adaptive ! efermi_linear, delta_bins, calc_weighted_dos !------------------------------------------------------------------------------- ! Modules Used: see below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: One of linear, adaptive or fixed must be .true. !------------------------------------------------------------------------------- ! Known Worries: (1) If more than one of linear, adaptive or fixed are set it ! uses the most complicated method. ! (2) It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_io , only : stdout , io_time , io_error use od_comms , only : on_root , my_node_id , comms_bcast use od_electronic , only : band_gradient , band_energy , efermi , efermi_castep , nspins , & & elec_read_band_gradient , unshifted_efermi use od_parameters , only : linear , adaptive , fixed , quad , & & dos_per_volume , iprint , set_efermi_zero , efermi_choice , iprint , photo use od_cell , only : cell_volume , num_kpoints_on_node implicit none !------------------------------------------------------------------------------- ! I N T E R N A L   V A R I A B L E S real ( kind = dp ) :: time0 , time1 real ( kind = dp ), intent ( in ), allocatable , optional :: matrix_weights (:, :, :, :) real ( kind = dp ), intent ( out ), allocatable , optional :: weighted_dos (:, :, :) ! bins.spins, orbitals !------------------------------------------------------------------------------- if (. not . ( linear . or . adaptive . or . fixed . or . quad )) call io_error ( \" DOS: No Broadening Set\" ) calc_weighted_dos = . false . if ( present ( matrix_weights )) calc_weighted_dos = . true . if ( calc_weighted_dos . eqv . . false .) then ! We are called just to provide dos. if ( allocated ( E )) then if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a78)' ) \"| Already calculated dos, so returning... & &                                   |\" return ! The dos has already been calculated previously so just return. end if end if if ( calc_weighted_dos ) then mw % norbitals = size ( matrix_weights , 1 ) mw % nbands = size ( matrix_weights , 2 ) mw % nkpoints = size ( matrix_weights , 3 ) mw % nspins = size ( matrix_weights , 4 ) end if if ( calc_weighted_dos ) then !       print*,'mw%nkpoints.ne.num_nkpoints_on_node(my_node_id))',mw%nkpoints,nunum_nkpoints_on_node(my_node_id) if ( mw % nspins . ne . nspins ) call io_error ( \"ERROR : DOS :  mw%nspins not equal to nspins.\" ) if ( mw % nkpoints . ne . num_kpoints_on_node ( my_node_id )) & call io_error ( \"ERROR : DOS : mw%nkpoints not equal to nkpoints.\" ) end if !------------------------------------------------------------------------------- ! R E A D   B A N D   G R A D I E N T S ! If we're using one of the more accurate roadening schemes we also need to read in the ! band gradients too if ( quad . or . linear . or . adaptive ) then if (. not . allocated ( band_gradient )) call elec_read_band_gradient end if !------------------------------------------------------------------------------- ! C A L C U L A T E   D O S ! Now everything is set up, we can perform the dos accumulation in parallel time0 = io_time () call setup_energy_scale if ( on_root . and . ( iprint > 1 )) write ( stdout , * ) if ( fixed ) then if ( calc_weighted_dos . and . (. not . adaptive ) . and . (. not . linear )) then call calculate_dos ( \"f\" , dos_fixed , intdos_fixed , matrix_weights = matrix_weights , weighted_dos = weighted_dos ) call dos_utils_merge ( dos_fixed , weighted_dos = weighted_dos ) else call calculate_dos ( \"f\" , dos_fixed , intdos_fixed ) call dos_utils_merge ( dos_fixed ) end if call dos_utils_merge ( intdos_fixed ) end if if ( adaptive ) then if ( calc_weighted_dos . and . (. not . linear )) then call calculate_dos ( \"a\" , dos_adaptive , intdos_adaptive , matrix_weights = matrix_weights , weighted_dos = weighted_dos ) call dos_utils_merge ( dos_adaptive , weighted_dos = weighted_dos ) else call calculate_dos ( \"a\" , dos_adaptive , intdos_adaptive ) call dos_utils_merge ( dos_adaptive ) end if call dos_utils_merge ( intdos_adaptive ) end if if ( linear ) then if ( calc_weighted_dos ) then call calculate_dos ( \"l\" , dos_linear , intdos_linear , matrix_weights = matrix_weights , weighted_dos = weighted_dos ) call dos_utils_merge ( dos_linear , weighted_dos = weighted_dos ) else call calculate_dos ( \"l\" , dos_linear , intdos_linear ) call dos_utils_merge ( dos_linear ) end if call dos_utils_merge ( intdos_linear ) end if if ( quad ) then call io_error ( \"quadratic broadening not implemented\" ) !if(quad)    call merge_dos(dos_quad) !if(quad)    call merge_dos(intdos_quad) end if !    if(.not.on_root) then !       if(allocated(E)) deallocate(E, stat=ierr) !       if (ierr/=0) call io_error (\"cannot deallocate  E\") !    endif time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) '+ Time to calculate DOS                                     ' , & & time1 - time0 , ' (sec) +' write ( stdout , '(1x,a78)' ) end if !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! F E R M I   E N E R G Y   A N A L Y S I S if ( efermi_choice == \"optados\" ) then if ( on_root ) then time0 = io_time () write ( stdout , '(1x,a78)' ) '+----------------------------- Fermi Energy Analysis ------------------------+' !    write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)') \"|\",\" Fermi energy from CASTEP : \",efermi_castep,\" eV\",\"<- EfC |\" !    write(stdout,'(1x,a71)')  '+---------------------------------------------------------------------+' if ( fixed ) then write ( stdout , '(1x,a23,54x,a1)' ) \"| From Fixed broadening\" , \"|\" efermi_fixed = calc_efermi_from_intdos ( intdos_fixed ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy (Fixed broadening) : \" , & & efermi_fixed , \"eV\" , \"<- EfF |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( adaptive ) then write ( stdout , '(1x,a26,51x,a1)' ) \"| From Adaptive broadening\" , \"|\" efermi_adaptive = calc_efermi_from_intdos ( intdos_adaptive ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy (Adaptive broadening) : \" & , efermi_adaptive , \"eV\" , \"<- EfA |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( linear ) then write ( stdout , '(1x,a24,53x,a1)' ) \"| From Linear broadening\" , \"|\" efermi_linear = calc_efermi_from_intdos ( intdos_linear ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy (Linear broadening) : \" , & efermi_linear , \" eV\" , \"<- EfL |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if end if end if call comms_bcast ( efermi_fixed , 1 ) call comms_bcast ( efermi_linear , 1 ) call comms_bcast ( efermi_adaptive , 1 ) if ( on_root ) then if ( dos_per_volume ) then if ( fixed ) then dos_fixed = dos_fixed / cell_volume intdos_fixed = intdos_fixed / cell_volume end if if ( adaptive ) then dos_adaptive = dos_adaptive / cell_volume intdos_adaptive = intdos_adaptive / cell_volume end if if ( linear ) then dos_linear = dos_linear / cell_volume intdos_linear = intdos_linear / cell_volume end if if ( calc_weighted_dos ) then if ( photo ) then weighted_dos = weighted_dos else weighted_dos = weighted_dos / cell_volume end if end if ! if(quad) then !    dos_quad=dos_quad/cell_volume !    intdos_quad=intdos_quad/cell_volume ! endif end if end if end subroutine dos_utils_calculate !=============================================================================== subroutine dos_utils_set_efermi !=============================================================================== use od_parameters , only : efermi_choice , efermi_user , fixed ,& & linear , adaptive , iprint use od_electronic , only : efermi_castep , num_electrons , nspins , efermi , & & electrons_per_state , band_energy , nbands , efermi_set use od_io , only : io_error , stdout use od_comms , only : on_root , my_node_id , comms_reduce , comms_bcast use od_cell , only : num_kpoints_on_node implicit none integer :: is , ik , top_occ_band real ( kind = dp ) :: vbm , cbm if ( on_root ) then write ( stdout , '(1x,a78)' ) '+--------------------------- Setting Fermi Energy  --------------------------+' end if !    if(on_root) write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)') \"|\",& !         &\" Fermi energy from file : \",efermi_castep,\" eV\",\"| <- EfC\" select case ( efermi_choice ) case ( \"file\" ) if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Set fermi energy from file : \" , efermi_castep , \" eV\" , \"  <- EfC\" efermi = efermi_castep case ( \"user\" ) if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Fermi energy from user : \" , efermi_user , \" eV\" , \"  <- EfU\" efermi = efermi_user case ( \"insulator\" ) ! Same fermi level for up and down spins. Different number ! of electrons for up and down spins. ! For an insulator. Hence same number of electrons at each kpoint. ! band_energy(ib,is,ik) vbm = - huge ( vbm ) cbm = huge ( cbm ) if ( on_root . and . iprint > 3 ) write ( stdout , * ) vbm , \" =vbm : cbm= \" , cbm ! Go between global VBM and CBM band_energy(ib,is,ik) do ik = 1 , num_kpoints_on_node ( my_node_id ) do is = 1 , nspins ! Which is the band below the fermi energy at this spin and kpoint top_occ_band = ceiling ( num_electrons ( is ) / electrons_per_state ) if ( band_energy ( top_occ_band , is , ik ) > vbm ) & & vbm = band_energy ( top_occ_band , is , ik ) ! If the band_energy array is big enough then there will be occupied states. if ( num_electrons ( is ) + 1 . le . nbands ) then if ( band_energy ( top_occ_band + 1 , is , ik ) < cbm ) & & cbm = band_energy ( top_occ_band + 1 , is , ik ) end if end do if ( on_root . and . iprint > 3 ) write ( stdout , * ) vbm , \" =vbm : cbm= \" , cbm end do ! Find the globals call comms_reduce ( cbm , 1 , 'MIN' ) call comms_bcast ( cbm , 1 ) call comms_reduce ( vbm , 1 , 'MAX' ) call comms_bcast ( vbm , 1 ) ! If we have a CBM then set the efermi halfway between VBM and CBM ! If we don't have a CBM then set it 0.5 eV above VBM and hope for ! the best. if ( cbm == huge ( cbm )) then efermi = vbm + 0.5_dp else efermi = vbm + 0.5_dp * ( cbm - vbm ) end if if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Fermi energy assuming insulator : \" , efermi , \" eV\" , \"  <- EfI\" case ( \"optados\" ) ! So in the case of compare_jdos we pick efermi_adaptive. call dos_utils_calculate ! This will return if we already have. if ( fixed ) efermi = efermi_fixed if ( linear ) efermi = efermi_linear if ( adaptive ) efermi = efermi_adaptive if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Fermi energy from DOS : \" , efermi , \" eV\" , \"<- EfD |\" case default call io_error ( 'Error in dos_utils_set_efermi: unknown efermi choice this is a bug' ) end select if ( on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a78)' ) end if efermi_set = . true . end subroutine dos_utils_set_efermi !=============================================================================== subroutine dos_utils_compute_dos_at_efermi !=============================================================================== use od_io , only : stdout , io_time use od_comms , only : on_root , comms_bcast use od_electronic , only : efermi , nspins use od_parameters , only : fixed , linear , adaptive , iprint , compute_band_gap implicit none real ( dp ) :: time0 , time1 real ( dp ) :: dos_at_efermi ( 1 : 3 , 1 : nspins ) ! Fix,Adapt,Linear integer :: is time0 = io_time () call dos_utils_calculate_at_e ( efermi , dos_at_e = dos_at_efermi ) if (( iprint > 1 ) . and . on_root ) then write ( stdout , * ) end if if ( on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------- DOS at Fermi Energy Analysis -----------------------+' write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" , \" Fermi energy used : \" , efermi , \"eV\" , \"       |\" if ( fixed ) then write ( stdout , '(1x,a78)' ) \"| From Fixed broadening                                                      |\" do is = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a25,f8.4,a9,6x,a8)' ) \"|\" , \"Spin Component : \" , is ,& & \"  DOS at Fermi Energy : \" , dos_at_efermi ( 1 , is ), \" eln/cell\" , \"<- DEF |\" end do write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( adaptive ) then write ( stdout , '(1x,a78)' ) \"| From Adaptive broadening                                                   |\" do is = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a25,f8.4,a9,6x,a8)' ) \"|\" , \"Spin Component : \" , is ,& & \"  DOS at Fermi Energy : \" , dos_at_efermi ( 2 , is ), \" eln/cell\" , \"<- DEA |\" end do write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if ( linear ) then write ( stdout , '(1x,a78)' ) \"| From Linear broadening                                                     |\" do is = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a25,f8.4,a9,6x,a8)' ) \"|\" , \"Spin Component : \" , is ,& & \"  DOS at Fermi Energy : \" , dos_at_efermi ( 3 , is ), \" eln/cell\" , \"<- DEL |\" end do write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if time1 = io_time () if ( iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate DOS at Fermi Energy                  & &      ' , time1 - time0 , ' (sec) +' end if write ( stdout , '(1x,a78)' ) !------------------------------------------------------------------------------- end if call comms_bcast ( compute_band_gap , 1 ) end subroutine dos_utils_compute_dos_at_efermi !=============================================================================== subroutine dos_utils_compute_bandgap !=============================================================================== ! Modified from LINDOS -- AJM 3rd June 2011 ! Rewritten 31/1/12 AJM use od_electronic , only : nspins , nbands , efermi , band_energy , num_electrons , & & all_kpoints use od_cell , only : nkpoints , num_kpoints_on_node use od_io , only : stdout , io_time , io_error use od_parameters , only : iprint use od_comms , only : comms_send , comms_recv , on_root , my_node_id , & & num_nodes , root_id implicit none ! Local array containing vbm and cbm at each kpoint and spin. real ( dp ), allocatable :: bandgap (:, :, :) !nbands=1,2,nspins,nkpoints ! Same as bandgap only merged over all nodes to the root-node real ( dp ), allocatable :: global_bandgap (:, :, :) ! Avergae bandgap for up and down spins (summed over all kpoints and divided ! by num_kpoints) real ( dp ), allocatable :: average_bandgap (:) ! Optical bandgap. Smallest vertical distance between two kpoints real ( dp ), allocatable :: optical_bandgap (:) ! The number of kpoints that have the vbm and cbm integer , allocatable :: thermal_vbm_multiplicity (:), thermal_cbm_multiplicity (:) ! The number of kpoints that have the optical gap integer , allocatable :: optical_multiplicity (:) ! Timing variables real ( dp ) :: time0 , time1 ! Loop counters integer :: ik , is , ib , ierr , inode , kpoints_before_this_node ! Temporary variables real ( dp ), allocatable :: kpoint_bandgap (:) real ( dp ) :: thermal_cbm , thermal_vbm , thermal_bandgap , weighted_average integer :: thermal_vbm_k , thermal_cbm_k logical :: thermal_multiplicity time0 = io_time () ! Preamble if ( on_root ) then if ( iprint > 2 ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) \"| Finding an estimate of the maximum bandgap...                              |\" end if write ( stdout , '(1x,a78)' ) '+----------------------------- Bandgap Analysis -----------------------------+' end if if (. not . allocated ( all_kpoints )) call io_error ( 'Error all_kpoints not allocated in dos_utils: compute_bandgap' ) allocate ( bandgap ( 1 : 2 , 1 : nspins , 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating bandgap in dos_utils: compute_bandgap' ) bandgap = - 20 0.00_dp ! Write the VBM and CBM into a slice of an band_energy array ! It is easier to merge these slices onto the root node rather than try ! the horrendous book-keeping of which kpoint on which node has which ! gap do is = 1 , nspins do ik = 1 , num_kpoints_on_node ( my_node_id ) bands_loop : do ib = 1 , nbands ! If this eignevalue is greater than efermi, then this is the CBM ! and the one below it is the VBM if ( band_energy ( ib , is , ik ) . gt . efermi ) then bandgap ( 1 , is , ik ) = band_energy ( ib - 1 , is , ik ) bandgap ( 2 , is , ik ) = band_energy ( ib , is , ik ) exit bands_loop end if end do bands_loop end do !ik end do !is ! Create a global kpoint array,and set it to something silly in case we need to debug whether ! data was actually written to it. if ( on_root ) then allocate ( global_bandgap ( 1 : 2 , 1 : nspins , 1 : nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating global_bandgap in dos_utils: compute_bandgap' ) global_bandgap = - 10 0.00_dp end if ! Pass all the slices around Efermi to the head node, making sure whe get the global ! kpoint number. *And* crucially the same kpoint numbers as in the bands file. ! Otherwise the kpoint numbers of the VBM and CBM change as different numbers of nodes ! are used. kpoints_before_this_node = 0 do inode = 1 , ( num_nodes - 1 ) if ( my_node_id == inode ) call comms_send ( bandgap ( 1 , 1 , 1 ), 2 * is * num_kpoints_on_node ( inode ), root_id ) if ( on_root ) call comms_recv ( global_bandgap ( 1 , 1 , & & kpoints_before_this_node + 1 ), 2 * is * num_kpoints_on_node ( inode ), inode ) kpoints_before_this_node = kpoints_before_this_node + num_kpoints_on_node ( inode ) end do ! Copy the root node's slice to the global array. if ( on_root ) & & global_bandgap ( 1 : 2 , 1 : nspins , kpoints_before_this_node & & + 1 : kpoints_before_this_node + num_kpoints_on_node ( root_id )) & & = bandgap ( 1 : 2 , 1 : nspins , 1 : num_kpoints_on_node ( root_id )) ! We now have an array with the VBM and CBM of all kpoints, so we can deallocate the local ones. deallocate ( bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating bandgap in dos_utils: compute_bandgap' ) ! We've freed up a bit of memory, so now we can allocate all of the output data arrays on the ! headnode if ( on_root ) then allocate ( average_bandgap ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating average_bandgap in dos_utils: compute_bandgap' ) allocate ( optical_bandgap ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating optical_bandgap in dos_utils: compute_bandgap' ) allocate ( kpoint_bandgap ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating kpoint_bandgap in dos_utils: compute_bandgap' ) allocate ( thermal_vbm_multiplicity ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating thermal_vbm_multiplicity in dos_utils: compute_bandgap' ) allocate ( thermal_cbm_multiplicity ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocatingthermal_cbm_multiplicity in dos_utils: compute_bandgap' ) allocate ( optical_multiplicity ( nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating optical_multiplicity in dos_utils: compute_bandgap' ) end if ! Now lets look for the various bandgaps by cycling through the global_bandgap array if ( on_root ) then ! COMMENTED OUT: This writes out the complete global_bandgap array to fort.7 if you'd like ! to take a look !  do ik=1,nkpoints !     do is=1,nspins !        write(7,*) ik,is, global_bandgap(1,is,ik),global_bandgap(2,is,ik) !     enddo ! enddo average_bandgap = 0.0_dp thermal_cbm = huge ( 1.0_dp ) thermal_vbm = - huge ( 1.0_dp ) thermal_vbm_multiplicity = 1 thermal_cbm_multiplicity = 1 thermal_vbm_k = - 1 thermal_cbm_k = - 1 optical_multiplicity = 1 optical_bandgap = huge ( 1.0_dp ) do is = 1 , nspins do ik = 1 , nkpoints ! Look for the thermal vbm. This is done for both spin components although ! ws care about the individual spin multiplicity if ( global_bandgap ( 1 , is , ik ) . ge . thermal_vbm ) then if ( abs ( global_bandgap ( 1 , is , ik ) - thermal_vbm ) < epsilon ( thermal_vbm )) then ! If this is the same value of vbm as we had before, then ! we have multiple maxima, and we need to know that we might not ! get the direct/indirect gap right thermal_vbm_multiplicity ( is ) = thermal_vbm_multiplicity ( is ) + 1 else ! If we haven't had this high a vbm value before, then we take it ! and set the multiplicty back to zero thermal_vbm = global_bandgap ( 1 , is , ik ) thermal_vbm_multiplicity ( is ) = 1 thermal_vbm_k = ik end if end if ! We search for the CBM in the same way as the VBM above. if ( global_bandgap ( 2 , is , ik ) . le . thermal_cbm ) then if ( abs ( global_bandgap ( 2 , is , ik ) - thermal_cbm ) < epsilon ( thermal_cbm )) then thermal_cbm_multiplicity ( is ) = thermal_cbm_multiplicity ( is ) + 1 else thermal_cbm = global_bandgap ( 2 , is , ik ) thermal_cbm_multiplicity ( is ) = 1 thermal_cbm_k = ik end if end if ! Work out the bandgap for this particular kpoint and spin kpoint_bandgap ( is ) = global_bandgap ( 2 , is , ik ) - global_bandgap ( 1 , is , ik ) ! If this is smaller than the optical gap. Then this is our next iteration ! of the optical gap. Worry about mutiplicties in the same way. Although this ! is just for into, since we can't have direct/indirect optical gaps. if ( kpoint_bandgap ( is ) . le . optical_bandgap ( is )) then if ( abs ( kpoint_bandgap ( is ) - optical_bandgap ( is )) < epsilon ( optical_bandgap ( is ))) then optical_multiplicity ( is ) = optical_multiplicity ( is ) + 1 else optical_bandgap ( is ) = kpoint_bandgap ( is ) optical_multiplicity ( is ) = 1 end if end if average_bandgap ( is ) = average_bandgap ( is ) + ( global_bandgap ( 2 , is , ik ) - global_bandgap ( 1 , is , ik )) end do ! nkpoints end do ! nspins ! We now have enough info to calculate the average bandgap and the thermal bandgap average_bandgap = average_bandgap / nkpoints vbm_energy = thermal_vbm cbm_energy = thermal_cbm thermal_bandgap = thermal_cbm - thermal_vbm ! Don't want this array hanging around a moment longer than we need it. deallocate ( global_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating global_bandgap in dos_utils: compute_bandgap' ) ! If there is more than one VBM and CBM let's flag it up. ! We wouldn't like to comment on the nature of the gap at this point ! Unless we did some more work. (Which should have been done before we deallocated ! global_bandgap!) thermal_multiplicity = . false . do is = 1 , nspins if (( thermal_vbm_multiplicity ( is ) . ne . 1 ) . or . ( thermal_cbm_multiplicity ( is ) . ne . 1 )) thermal_multiplicity = . true . end do ! Report the thermal gap multiplicity write ( stdout , '(1x,1a,a50, 19x, a8)' ) \"|\" , \"Number of kpoints at       VBM       CBM\" , \"       |\" do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,1x,i5,5x,i5,20x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , & & thermal_vbm_multiplicity ( is ), thermal_cbm_multiplicity ( is ), \"       |\" end do ! Write out the thermal gap info write ( stdout , '(1x,a1,a32,f15.10,1x,a3,18x,a8)' ) \"|\" , \"Thermal Bandgap :\" , thermal_bandgap , \"eV\" , \"<- TBg |\" if (. not . thermal_multiplicity ) then if ( thermal_vbm_k == thermal_cbm_k ) then write ( stdout , '(1x,a1,a32,1x,f10.5,1x,f10.5,1x,f10.5,4x,a8)' ) \"|\" , \"At kpoint :\" , & all_kpoints ( 1 : 3 , thermal_vbm_k ), \"       |\" write ( stdout , '(1x,a78)' ) '|             ==> Direct Gap                                                  |' else write ( stdout , '(1x,a1,a32,1x,f10.5,1x,f10.5,1x,f10.5,4x,a8)' ) \"|\" , \"Between VBM kpoint :\" , & all_kpoints ( 1 : 3 , thermal_vbm_k ), \"       |\" write ( stdout , '(1x,a1,a32,1x,f10.5,1x,f10.5,1x,f10.5,4x,a8)' ) \"|\" , \"and CBM kpoint:\" , & all_kpoints ( 1 : 3 , thermal_cbm_k ), \"       |\" write ( stdout , '(1x,a78)' ) '|             ==> Indirect Gap                                               |' end if else ! thermal_mutiplicty=.true. write ( stdout , '(1x,a78)' ) '|          ==> Multiple Band Minima and Maxima -- Gap unknown                |' end if ! We allocated this in elec_read_band_energy but kept it if compute_band_gap=T deallocate ( all_kpoints , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoints in read_band_energy' ) ! Write out the Optical gap indo write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a1,a45,a32)' ) \"|\" , \"Optical Bandgap  \" , \"|\" do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,1x,f15.10,1x,a3,16x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , optical_bandgap ( is ),& & \"eV\" , \"<- OBg |\" end do write ( stdout , '(1x,1a,a50, 19x, a8)' ) \"|\" , \"Number of kpoints with this gap         \" , \"       |\" ! The multiplicity info here is just for reference. do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,6x,i5,25x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , optical_multiplicity ( is ), \"       |\" end do ! Write out the average bandgap write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a1,a45,a32)' ) \"|\" , \"Average Bandgap  \" , \"|\" do is = 1 , nspins write ( stdout , '(1x,a1,a25,1x,i3,1x,a3,1x,f15.10,1x,a3,16x,a8)' ) \"|\" , \" Spin :\" , is , \" : \" , & & average_bandgap ( is ), \"eV\" , \"<- ABg |\" end do ! If we have more then one spin, then we need some way to combine the up and down spin bandgaps ! At Richard Needs' suggestion we use the weighted sum. if ( nspins > 1 ) then weighted_average = ( average_bandgap ( 1 ) * num_electrons ( 1 ) + average_bandgap ( 2 ) * num_electrons ( 2 )) & & / ( num_electrons ( 1 ) + num_electrons ( 2 )) write ( stdout , '(1x,a1,a33,1x,f15.10,1x,a3,16x,a8)' ) \"|\" , \" Weighted Average : \" , weighted_average , \"eV\" , \"<- wAB |\" end if end if ! Let not have these other arrays hanging around a moment longer than we need them if ( on_root ) then deallocate ( average_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating average_bandgap in dos_utils: compute_bandgap' ) deallocate ( optical_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating optical_bandgap in dos_utils: compute_bandgap' ) deallocate ( kpoint_bandgap , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating kpoint_bandgap in dos_utils: compute_bandgap' ) deallocate ( thermal_vbm_multiplicity , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating thermal_vbm_multiplicity in dos_utils: compute_bandgap' ) deallocate ( thermal_cbm_multiplicity , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocatingthermal_cbm_multiplicity in dos_utils: compute_bandgap' ) deallocate ( optical_multiplicity , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating optical_multiplicity in dos_utils: compute_bandgap' ) end if if ( on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to calculate Bandgap ' , time1 - time0 , ' (sec)' end subroutine dos_utils_compute_bandgap !=============================================================================== !=============================================================================== function calc_band_energies ( dos ) !=============================================================================== ! Function to return the band energy of a DOS by summing DOS*Energy up to ! Fermi energy !------------------------------------------------------------------------------- ! Arguments: dos (in) : Density of States array !------------------------------------------------------------------------------- ! Parent Module Varables Used: E !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: none beyond the parent module variables !------------------------------------------------------------------------------- ! Necessary Conditions: efermi must be set in od_electonic !                       E must be set !------------------------------------------------------------------------------- ! Known Worries: !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_electronic , only : nspins use od_parameters , only : dos_nbins use od_electronic , only : efermi implicit none real ( kind = dp ), intent ( in ) :: dos ( 1 : dos_nbins , 1 : nspins ) real ( kind = dp ) :: gband , calc_band_energies integer :: is , idos gband = 0.0_dp do is = 1 , nspins do idos = 1 , dos_nbins if ( E ( idos ) . le . efermi ) then gband = gband + dos ( idos , is ) * E ( idos ) * delta_bins else exit end if end do end do calc_band_energies = gband end function calc_band_energies !=============================================================================== function calc_efermi_from_intdos ( INTDOS ) !=============================================================================== ! Function to calculate the Fermi energy from an intgrated DOS by serching for ! the bin which contains the correct number of electrons !------------------------------------------------------------------------------- ! Arguments: intdos (in) : Density of States array !------------------------------------------------------------------------------- ! Parent Module Varables Used: E !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: E must be set !------------------------------------------------------------------------------- ! Known Worries: !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 Modified from LinDOS !=============================================================================== use od_electronic , only : num_electrons , nspins use od_parameters , only : dos_nbins use od_io , only : stdout use od_comms , only : on_root implicit none real ( kind = dp ), intent ( in ) :: INTDOS ( 1 : dos_nbins , 1 : nspins ) real ( kind = dp ) :: calc_efermi_from_intdos real ( kind = dp ) :: efermi real ( kind = dp ) :: tolerance = 0.0001_dp ! Has the effect of forcing the efermi to ! be in the middle of the band gap, and not ! the leading edge. integer :: idos , i , j do idos = 1 , dos_nbins if ( sum ( INTDOS ( idos , :)) . gt . ( sum ( num_electrons (:)) + ( tolerance / 2.0_dp ))) exit end do efermi = E ( idos ) do i = idos , 1 , - 1 if ( sum ( INTDOS ( i , :)) . lt . ( sum ( INTDOS ( idos - 1 , :)) - ( tolerance / 2.0_dp ))) exit end do calc_efermi_from_intdos = ( efermi + E ( i )) / 2.0_dp if ( on_root ) then do j = 1 , nspins write ( stdout , '(1x,a1,a20,i1,a20,f10.5,a4,1x,f10.5,3x,a8)' ) \"|\" , \"Spin Component : \" , j ,& & \" occupation between \" , INTDOS ( i , j ), \"and\" , INTDOS ( idos , j ), \"<- Occ |\" end do end if end function calc_efermi_from_intdos !=============================================================================== subroutine dos_utils_compute_band_energies !=============================================================================== ! High-level subroutine to compute band energies of the DOS calculated. ! Calculates using the band_energies directly and compares with the ! function calc_band_energies which does the low level computation on the DOS. !------------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------------- ! Parent Module Varables Used: E,dos_fixed,dos_adaptive,dos_linear !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: E must be set !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_parameters , only : adaptive , linear , fixed , iprint use od_electronic , only : electrons_per_state , efermi , nbands , nspins , band_energy use od_cell , only : kpoint_weight , num_kpoints_on_node use od_comms , only : comms_reduce , my_node_id , on_root use od_io , only : stdout , io_time implicit none real ( kind = dp ) :: eband real ( kind = dp ) :: time0 , time1 integer :: ik , is , ib time0 = io_time () if ( on_root ) then write ( stdout , '(1x,a78)' ) '+--------------------------- Band Energy Analysis ---------------------------+' if ( fixed ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , & \" Band energy (Fixed broadening)  : \" , calc_band_energies ( dos_fixed ), \"eV\" , \"<- BEF |\" end if if ( adaptive ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , & \" Band energy (Adaptive broadening) : \" , calc_band_energies ( dos_adaptive ), \"eV\" , \"<- BEA |\" end if if ( linear ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , & \" Band energy (Linear broadening) : \" , calc_band_energies ( dos_linear ), \"eV\" , \"<- BEL |\" end if end if eband = 0.0_dp do ik = 1 , num_kpoints_on_node ( my_node_id ) do is = 1 , nspins do ib = 1 , nbands if ( band_energy ( ib , is , ik ) . le . efermi ) eband = eband + band_energy ( ib , is , ik ) * electrons_per_state & & * kpoint_weight ( ik ) end do end do end do call comms_reduce ( eband , 1 , 'SUM' ) if ( on_root ) then write ( stdout , '(1x,a1,a46,f12.4,a3,8x,a8)' ) \"|\" , \" Band energy (From CASTEP) : \" , eband , \"eV\" , \"<- BEC |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' time1 = io_time () if ( iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Band Energies                        & &      ' , time1 - time0 , ' (sec) +' end if write ( stdout , '(1x,a78)' ) end if end subroutine dos_utils_compute_band_energies !=============================================================================== subroutine setup_energy_scale !=============================================================================== ! Sets up all broadening independent DOS concerns. That is basically the energy ! scale, E, and the width of its bins, delta_bins !------------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------------- ! Parent Module Varables Used: delta_bins !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: band_energy in od_electronic must be set !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_parameters , only : dos_nbins , dos_min_energy , dos_max_energy , dos_spacing , iprint use od_electronic , only : band_energy use od_io , only : io_error , stdout use od_comms , only : comms_reduce , comms_bcast , on_root implicit none real ( kind = dp ) :: min_band_energy , max_band_energy integer :: idos , ierr if ( allocated ( E )) then deallocate ( E , stat = ierr ) if ( ierr /= 0 ) call io_error ( \"cannot deallocate E in dos_utils setup_energy_scale\" ) end if ! If we do have dos_min_energy and dos_max_energy set, then we'd better ! use them. If not, let's set some sensible values. if ( dos_min_energy == - huge ( dos_min_energy )) then !Do it automatically min_band_energy = minval ( band_energy ) - 5.0_dp else min_band_energy = dos_min_energy end if call comms_reduce ( min_band_energy , 1 , 'MIN' ) call comms_bcast ( min_band_energy , 1 ) if ( dos_max_energy == huge ( dos_max_energy )) then !Do it automatically max_band_energy = maxval ( band_energy ) + 5.0_dp else max_band_energy = dos_max_energy end if call comms_reduce ( max_band_energy , 1 , 'MAX' ) call comms_bcast ( max_band_energy , 1 ) ! If dos_nbins is set, then we'd better use that if ( dos_nbins < 0 ) then ! we'll have to work it out dos_nbins = abs ( ceiling (( max_band_energy - min_band_energy ) / dos_spacing )) ! Now modify the max_band_energy if ( on_root . and . ( iprint > 2 )) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a40,f11.3,13x,a14)' ) '| max_band_energy (before correction) : ' , max_band_energy , \"<-- DOS Grid |\" end if max_band_energy = min_band_energy + dos_nbins * dos_spacing end if allocate ( E ( 1 : dos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"cannot allocate E in dos_utils setup_energy_scale\" ) delta_bins = ( max_band_energy - min_band_energy ) / real ( dos_nbins - 1 , dp ) do idos = 1 , dos_nbins E ( idos ) = min_band_energy + real ( idos - 1 , dp ) * delta_bins end do if ( on_root . and . ( iprint > 2 )) then write ( stdout , '(1x,1a,a39,e11.5,13x,a14)' ) '|' , 'dos_min_energy : ' , dos_min_energy , \"<-- DOS Grid |\" write ( stdout , '(1x,1a,a39,e11.5,13x,a14)' ) '|' , 'dos_max_energy : ' , dos_max_energy , \"<-- DOS Grid |\" write ( stdout , '(1x,1a,a39,f11.3,13x,a14)' ) '|' , 'min_band_energy : ' , min_band_energy , \"<-- DOS Grid |\" write ( stdout , '(1x,1a,a39,f11.3,13x,a14)' ) '|' , 'max_band_energy : ' , max_band_energy , \"<-- DOS Grid |\" write ( stdout , '(1x,1a,a39,i11,13x,a14)' ) '|' , 'dos_nbins : ' , dos_nbins , \"<-- DOS Grid |\" write ( stdout , '(1x,1a,a39,f11.3,13x,a14)' ) '|' , 'dos_spacing : ' , dos_spacing , \"<-- DOS Grid |\" write ( stdout , '(1x,1a,a39,f11.3,13x,a14)' ) '|' , 'delta_bins : ' , delta_bins , \"<-- DOS Grid |\" write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if end subroutine setup_energy_scale !=============================================================================== subroutine dos_utils_merge ( dos , weighted_dos ) !=============================================================================== ! The DOS was calculated accross nodes. Now give them all back to root ! and free up the memeory on the slaves !------------------------------------------------------------------------------- ! Arguments: dos          (in - slaves) (inout -  root)       : The DOS !            weighted_dos (in - slaves) (inout -  root) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_comms , only : comms_reduce use od_electronic , only : nspins use od_parameters , only : dos_nbins implicit none real ( kind = dp ), intent ( inout ), allocatable , optional :: weighted_dos (:, :, :) ! bins.spins, orbitals real ( kind = dp ), allocatable , intent ( inout ) :: dos (:, :) call comms_reduce ( dos ( 1 , 1 ), nspins * dos_nbins , \"SUM\" ) if ( present ( weighted_dos )) call comms_reduce ( weighted_dos ( 1 , 1 , 1 ), mw % nspins * dos_nbins * mw % norbitals , \"SUM\" ) !    if(.not.on_root) then !       if(allocated(dos)) deallocate(dos,stat=ierr) !       if (ierr/=0) call io_error (\" ERROR : dos : merge_dos : cannot deallocate dos\") !       if(present(weighted_dos))  then !          if(allocated(weighted_dos)) deallocate(weighted_dos,stat=ierr) !          if (ierr/=0) call io_error (\" ERROR : dos : merge_dos : cannot deallocate weighted_dos\") !       end if !    endif end subroutine dos_utils_merge !=============================================================================== subroutine allocate_dos ( dos , intdos , w_dos ) !=============================================================================== ! Allocate the dos, intdos and w_dos if necessary. !------------------------------------------------------------------------------- ! Arguments: dos    (inout)       : The Density of States !            intdos (inout)       : The Integrated DOS !            w_dos  (inout) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_electronic , only : nspins use od_parameters , only : dos_nbins use od_io , only : io_error implicit none real ( kind = dp ), allocatable , intent ( inout ) :: dos (:, :) real ( kind = dp ), allocatable , intent ( inout ) :: intdos (:, :) real ( kind = dp ), intent ( out ), optional , allocatable :: w_dos (:, :, :) ! bins.spins, orbitals integer :: ierr allocate ( dos ( dos_nbins , nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"error in allocating dos\" ) dos = 0.0_dp allocate ( intdos ( dos_nbins , nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"error in allocating intdos\" ) intdos = 0.0_dp if ( present ( w_dos )) then allocate ( w_dos ( dos_nbins , mw % nspins , mw % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"error in allocating weighted_dos\" ) w_dos = 0.0_dp end if end subroutine allocate_dos subroutine dos_utils_deallocate use od_io , only : io_error implicit none integer :: ierr if ( allocated ( dos_adaptive )) then deallocate ( dos_adaptive , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate dos_adaptive' ) end if if ( allocated ( dos_fixed )) then deallocate ( dos_fixed , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate dos_fixed' ) end if if ( allocated ( dos_linear )) then deallocate ( dos_linear , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate dos_linear' ) end if if ( allocated ( intdos_adaptive )) then deallocate ( intdos_adaptive , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate intdos_adaptive' ) end if if ( allocated ( intdos_fixed )) then deallocate ( intdos_fixed , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate intdos_fixed' ) end if if ( allocated ( intdos_linear )) then deallocate ( intdos_linear , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate intdos_fixed' ) end if if ( allocated ( E )) then deallocate ( E , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: dos_utils_deallocate - failed to deallocate E' ) end if end subroutine dos_utils_deallocate !=============================================================================== subroutine calculate_dos ( dos_type , dos , intdos , matrix_weights , weighted_dos ) !=============================================================================== ! Once everything is set up this is the main workhorse of the module. ! It accumulates the DOS and WDOS be looping over spins, kpoints and bands. !------------------------------------------------------------------------------- ! Arguments: dos           (out)       : The Density of States !                          (in)        : one of \"a\", \"f\", \"l\", \"q\" !            intdos        (out)       : The Integrated DOS !            matrix_weights(in)  (opt) : The weightings, such as LCAO for the !                                        weighted dos. !            weighted_dos  (out) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: delta_bins !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: We use local adaptive, fixed and linear variable so that if multiple ! are set, it won't always appear to do the linear scheme. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 Heavliy modified from LinDOS !=============================================================================== use od_constants , only : sqrt_two use od_algorithms , only : gaussian , algorithms_erf use od_cell , only : kpoint_grid_dim , kpoint_weight , num_kpoints_on_node , recip_lattice use od_electronic , only : band_gradient , electrons_per_state , nbands , nspins , band_energy use od_parameters , only : adaptive_smearing , fixed_smearing , hybrid_linear & &, finite_bin_correction , iprint , dos_nbins , numerical_intdos , hybrid_linear_grad_tol & &, linear_smearing use od_io , only : stdout , io_error use od_comms , only : my_node_id , on_root implicit none integer :: ik , is , ib , idos , iorb , i , ierr real ( kind = dp ) :: adaptive_smearing_temp , dos_temp , cuml , intdos_accum , width real ( kind = dp ) :: grad ( 1 : 3 ), step ( 1 : 3 ), EV ( 0 : 4 ) real ( kind = dp ) :: sub_cell_length ( 1 : 3 ) real ( kind = dp ) :: temp_debug character ( len = 1 ), intent ( in ) :: dos_type real ( kind = dp ), intent ( out ), allocatable , optional :: weighted_dos (:, :, :) real ( kind = dp ), intent ( in ), optional :: matrix_weights (:, :, :, :) real ( kind = dp ), intent ( out ), allocatable :: dos (:, :), intdos (:, :) real ( kind = dp ), allocatable :: dos_smear (:, :) logical :: linear , fixed , adaptive , force_adaptive linear = . false . fixed = . false . adaptive = . false . select case ( dos_type ) case ( \"l\" ) linear = . true . case ( \"a\" ) adaptive = . true . case ( \"f\" ) fixed = . true . case default call io_error ( \" ERROR : unknown dos_type in calculate_dos \" ) end select width = 0.0_dp if ( linear . or . adaptive ) step (:) = 1.0_dp / real ( kpoint_grid_dim (:), dp ) / 2.0_dp if ( adaptive . or . hybrid_linear ) then do i = 1 , 3 sub_cell_length ( i ) = sqrt ( recip_lattice ( i , 1 ) ** 2 + recip_lattice ( i , 2 ) ** 2 + recip_lattice ( i , 3 ) ** 2 ) * step ( i ) end do adaptive_smearing_temp = adaptive_smearing * sum ( sub_cell_length ) / 3.0_dp end if if ( fixed ) width = fixed_smearing if ( calc_weighted_dos ) then call allocate_dos ( dos , intdos , w_dos = weighted_dos ) else call allocate_dos ( dos , intdos ) end if if ( iprint > 1 . and . on_root ) then ! This is to contain the Calculating k-points block write ( stdout , '(1x,a78)' ) '+------------------------------ Calculate DOS -------------------------------+' end if do ik = 1 , num_kpoints_on_node ( my_node_id ) if ( iprint > 1 . and . on_root ) then if ( mod ( real ( ik , dp ), 1 0.0_dp ) == 0.0_dp ) write ( stdout , '(1x,a1,a28,i4,a3,i4,a14,7x,a17)' ) \"|\" ,& & \"Calculating k-point \" , ik , \" of\" , num_kpoints_on_node ( my_node_id ), \" on this node\" , \"<-- DOS |\" End if do is = 1 , nspins do ib = 1 , nbands if ( linear . or . adaptive ) grad (:) = band_gradient ( ib , :, ik , is ) ! If the band is very flat linear broadening can have problems describing it. In this case, fall back to ! adaptive smearing (and take advantage of FBCS if required). force_adaptive = . false . if ( linear . and . . not . force_adaptive ) call doslin_sub_cell_corners ( grad , step , band_energy ( ib , is , ik ), EV ) if ( adaptive . or . force_adaptive ) width = sqrt ( dot_product ( grad , grad )) * adaptive_smearing_temp ! Hybrid Adaptive -- This way we don't lose weight at very flat parts of the ! band. It's a kind of fudge that we wouldn't need if we had infinitely small bins. if ( finite_bin_correction . and . ( width < delta_bins )) width = delta_bins intdos_accum = 0.0_dp do idos = 1 , dos_nbins ! The linear method has a special way to calculate the integrated dos ! we have to take account for this here. if ( linear . and . . not . force_adaptive ) then dos_temp = doslin ( EV ( 0 ), EV ( 1 ), EV ( 2 ), EV ( 3 ), EV ( 4 ), E ( idos ), cuml ) * electrons_per_state * kpoint_weight ( ik ) intdos ( idos , is ) = intdos ( idos , is ) + electrons_per_state * kpoint_weight ( ik ) * cuml else dos_temp = gaussian ( band_energy ( ib , is , ik ), width , E ( idos )) * electrons_per_state * kpoint_weight ( ik ) if ( numerical_intdos ) then intdos_accum = intdos_accum + dos_temp intdos ( idos , is ) = intdos ( idos , is ) + intdos_accum else ! Do it (semi)-analytically intdos ( idos , is ) = intdos ( idos , is ) + 0.5_dp * ( 1.0_dp + algorithms_erf (( E ( idos ) - & & band_energy ( ib , is , ik )) / ( sqrt_two * width ))) * electrons_per_state * kpoint_weight ( ik ) end if end if dos ( idos , is ) = dos ( idos , is ) + dos_temp if ( calc_weighted_dos ) then if ( ik . le . mw % nkpoints ) then if ( ib . le . mw % nbands ) then do iorb = 1 , mw % norbitals weighted_dos ( idos , is , iorb ) = weighted_dos ( idos , is , iorb ) + & & dos_temp * matrix_weights ( iorb , ib , ik , is ) end do end if end if end if end do end do end do end do if ( linear . and . ( linear_smearing . gt . 0.0_dp )) then if ( iprint > 1 . and . on_root ) then ! This is to contain the Calculating k-points block write ( stdout , '(1x,a78)' ) '+-------------------------------- Smear DOS ---------------------------------+' end if ! Post smear the dos with a Guassian ! allocate a temporary array allocate ( dos_smear ( dos_nbins , nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"error in allocating dos_smear\" ) dos_smear = 0.0_dp ! loop over spins ! loop over temporary array ! loop over dos array do is = 1 , nspins do idos = 1 , dos_nbins if ( iprint > 1 . and . on_root ) then if ( mod ( real ( idos , dp ), 100 0.0_dp ) == 0.0_dp ) write ( stdout , '(1x,a1,a25,i14,a3,i10,a14,1x,a10)' ) \"|\" ,& & \"Calculating bin \" , idos , \" of\" , dos_nbins , \" on this node\" , \"<--sDOS |\" end if do i = 1 , dos_nbins dos_smear ( idos , is ) = dos_smear ( idos , is ) + dos ( i , is ) * gaussian ( E ( idos ), linear_smearing , E ( i )) * delta_bins end do end do end do ! copy array back dos = dos_smear ! deallocate array deallocate ( dos_smear ) end if if ( iprint > 1 . and . on_root ) then ! This is to contain the Calculating k-points block write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if if (. not . linear . and . numerical_intdos ) intdos = intdos * delta_bins end subroutine calculate_dos !=============================================================================== subroutine doslin_sub_cell_corners ( grad , step , energy , EigenV ) !=============================================================================== ! A helper subroutine for calculated_dos, which is used for the linear ! broadening method. This routine extrapolates the energies at the corner of the ! sub cells by using the gradient at the centre of the cell !------------------------------------------------------------------------------- ! Arguments: grad   (in) : The Gradient of the band at the centre of a sub-cell !            step   (in) : The directions to the edge of the sub_cell !            energy (in) : The Band energy at the centre of the sub cell !            EigenV (out): The Energies at the corners of the sub-cell !------------------------------------------------------------------------------- ! Parent Module Varables Used: None !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 Heavliy modified from LinDOS !=============================================================================== use od_algorithms , only : heap_sort use od_cell , only : recip_lattice implicit none real ( kind = dp ), intent ( in ) :: grad ( 1 : 3 ), step ( 1 : 3 ) real ( kind = dp ), intent ( out ) :: EigenV ( 0 : 4 ) real ( kind = dp ), intent ( in ) :: energy integer :: m , n , o , nn , i real ( kind = dp ) :: stepp ( 1 : 3 ), DE ( 1 : 8 ) nn = 0 do m = - 1 , 1 , 2 do n = - 1 , 1 , 2 do o = - 1 , 1 , 2 nn = nn + 1 stepp ( 1 ) = step ( 1 ) * m stepp ( 2 ) = step ( 2 ) * n stepp ( 3 ) = step ( 3 ) * o ! Reciprocal lattice in inverse Ang stepp = matmul ( recip_lattice , stepp ) ! DE in eV DE ( nn ) = dot_product ( grad , stepp ) end do end do end do ! Yes this is a hack to the sorter to work the right way around. DE = - DE call heap_sort ( 8 , DE ) DE = - DE ! WHY ARE WE STORING ALL THIS? !EV(0,ib,is,ik) = band_energy(ib,is,ik) !EV(1,ib,is,ik) = EV(0,ib,is,ik) + DE(5) !EV(2,ib,is,ik) = EV(0,ib,is,ik) + DE(6) !EV(3,ib,is,ik) = EV(0,ib,is,ik) + DE(7) !EV(4,ib,is,ik) = EV(0,ib,is,ik) + DE(8) EigenV ( 0 ) = Energy do i = 1 , 4 EigenV ( i ) = EigenV ( 0 ) + DE ( 4 + i ) end do end subroutine doslin_sub_cell_corners !=============================================================================== function doslin ( e0 , e1 , e2 , e3 , e4 , e , int ) !=============================================================================== ! Return the DoS contribution for a linear band portion and a cubic cell !------------------------------------------------------------------------------- ! Arguments: e0 (in) : Energy at centre of sub cell !   e1,e2,e3,e4 (in) : Energies of the four lowest corners of the sub cell !            e  (in) : Energy at which DOS is evaluated !          int  (out): Integrated DOS contribution for energy, E) ! (The function itself returns the DOS couribution for energy, E) !------------------------------------------------------------------------------- ! Parent Module Varables Used: None !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : C J Pickard. From LinDOS. Extra Comments A J Morris Sept 2010 !=============================================================================== implicit none ! - E X T R A   C O M M E N T S   B Y   A J M real ( kind = dp ), intent ( in ) :: e0 , e1 , e2 , e3 , e4 real ( kind = dp ), intent ( in ) :: e real ( kind = dp ), intent ( out ) :: int real ( kind = dp ) :: doslin real ( kind = dp ) :: alpha , e_use logical :: shift ! ** Check the input arguments ! The inputs must be in ascending order. These are the four lowest corners of the ! cube (sub cell) around the k-point. E_0 is the energy of the k-point which would ! in a Gaussian smearing scheme, be the only info we have about this cube of recip ! space. if (. not . (( e4 . le . e3 ) . and . ( e3 . le . e2 ) . and . ( e2 . le . e1 ) . and . ( e1 . le . e0 ))) then stop 'doslin: input arguments incorrect' end if ! ** Return if outside the range ! If the energy is below the smallest corner, then return. The CES doesn't cut this ! sub cell if ( e . le . e4 ) then doslin = 0.0_dp ! TRUE int = 0.0_dp ! TRUE return end if ! Since the energy in the sub cell is linearly extrapolated, if the energy is twice as ! big as the energy difference between the smallest corner and the middle, then this ! energy is outdside the top of the cell, and whilst this cell doesn't contribute to the ! CES, it does to the occupation. if ( e . ge . ( 2.0_dp * e0 - e4 )) then doslin = 0.0_dp ! TRUE int = 1.0_dp ! TRUE return end if ! ** Special treatment if all vertices at the same energy ! If the CES is perfectly flat in the cell, then we don't want to be dividing by zero. ! the below just catches this case and forces alpha to be 1. This is fine as the else ! block below looks for the same problem and the answer comes out correctly to if (( e1 == e2 ) . and . ( e1 == e3 ) . and . ( e3 == e4 )) then alpha = 1.0_dp else alpha = 1.0_dp / (( e1 - e3 ) * ( e1 - e4 ) + ( e3 - e4 ) ** 2 / 3.0_dp - ( e1 - e2 ) ** 2 / 3.0_dp + ( e1 + e2 - e3 - e4 ) * ( e0 - e1 )) ! TRUE end if ! ** Flip if above e0 ! If e is greater than the energy of the k-point, then we're going to subtract the ! contribution from a full cell, rather than add it to an empty one. The extrapolation ! is linear, so we can do this fine. if ( e . gt . e0 ) then e_use = 2.0_dp * e0 - e ! TRUE shift = . true . else e_use = e ! TRUE shift = . false . end if ! ** The analytic constributions to the DOS and integrated DOS if ( e_use . le . e4 ) then ! P O S S I B L E   S P E E D   U P ! If we ended up in here, something went wrong as this should already have been trapped. doslin = 0.0_dp ! TRUE int = 0.0_dp ! TRUE else if ( e_use . lt . e3 ) then ! There isn't a problem with divide by zero here. Since if e3=e4 and e_use < e3 ! we would have been caugh in the above if. doslin = ( e_use - e4 ) ** 2 / ( e3 - e4 ) / 2.0_dp ! TRUE int = ( e_use - e4 ) ** 3 / ( e3 - e4 ) / 6.0_dp ! TRUE else if ( e_use . lt . e2 ) then doslin = ( e_use - ( e3 + e4 ) / 2.0_dp ) ! TRUE int = (( e3 - e4 ) ** 2 / 3.0_dp + ( e_use - e3 ) * ( e_use - e4 )) / 2.0_dp ! TRUE else if ( e_use . lt . e1 ) then doslin = ( e1 + e2 - e3 - e4 ) / 2.0_dp ! TRUE ! Ok, so the IF costs more than the maths. But this way also catches the ! divide by zero. Clever! if ( e1 . ne . e2 ) doslin = doslin - ( e1 - e_use ) ** 2 / ( e1 - e2 ) / 2.0_dp ! TRUE int = (( e2 - e4 ) * ( e_use - e3 ) + ( e1 - e3 ) * ( e_use - e2 ) + ( e3 - e4 ) ** 2 / 3.0_dp + & (( e1 - e_use ) ** 3 - ( e1 - e2 ) ** 3 ) / ( e1 - e2 ) / 3.0_dp ) / 2.0_dp ! TRUE else if ( e_use . le . e0 ) then ! Check to see if the band is flat. if (( e1 + e2 - e3 - e4 ) . gt . 0.0_dp ) then doslin = ( e1 + e2 - e3 - e4 ) / 2.0_dp ! TRUE int = (( e1 - e3 ) * ( e1 - e4 ) + ( e3 - e4 ) ** 2 / 3.0_dp - ( e1 - e2 ) ** 2 / 3.0_dp + & ( e1 + e2 - e3 - e4 ) * ( e_use - e1 )) / 2.0_dp ! TRUE else ! This can only happen if e1=e2=e3=e4, ! in this case we stop doing what we were doing and calculate the contirbution from the ! gradient simplistically. grad E = e0-e4. doslin = 1.0_dp / ( e0 - e4 ) / 2.0_dp ! TRUE int = ( e_use - e4 ) / ( e0 - e4 ) / 2.0_dp ! SO YES, THIS DOES INTEGRATE FROM THE LINE ABOVE end if else write ( * , * ) e_use , e write ( * , * ) e0 , e1 , e2 , e3 , e4 stop 'Got here, but not supposed to!' end if ! ** Normalise doslin = doslin * alpha if ( shift ) then int = 1.0_dp - int * alpha ! TRUE else int = int * alpha ! TRUE end if return end function doslin !=============================================================================== subroutine dos_utils_calculate_at_e ( energy , dos_at_e , matrix_weights , weighted_dos_at_e ) !=============================================================================== ! Main routine in dos module, drives the calculation of density of states for ! both task : dos and also if it is required elsewhere. !------------------------------------------------------------------------------- ! Arguments: matrix_weigths (in) (opt) : LCAO or other weightings for DOS !            weighted_dos   (out)(opt) : Output DOS weigthed by matrix_weights !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw, E, dos_adaptive, dos_fixed, dos_linear ! intdos_adaptive, intdos_fixed, intdos_linear, efermi_fixed, efermi_adaptive ! efermi_linear, delta_bins, calc_weighted_dos !------------------------------------------------------------------------------- ! Modules Used: see below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: One of linear, adaptive or fixed must be .true. !------------------------------------------------------------------------------- ! Known Worries: (1) If more than one of linear, adaptive or fixed are set it ! uses the most complicated method. ! (2) It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_io , only : stdout , io_time , io_error use od_comms , only : on_root , my_node_id use od_electronic , only : band_gradient , nspins , elec_read_band_gradient use od_parameters , only : linear , adaptive , fixed , quad , iprint use od_cell , only : nkpoints , num_kpoints_on_node implicit none !------------------------------------------------------------------------------- ! I N T E R N A L   V A R I A B L E S real ( kind = dp ) :: time0 , time1 real ( kind = dp ), intent ( in ), allocatable , optional :: matrix_weights (:, :, :, :) real ( kind = dp ), intent ( out ), optional :: weighted_dos_at_e (:, :) ! spins, orbitals RJN3Jun changed real ( kind = dp ), intent ( in ) :: energy real ( kind = dp ), intent ( out ) :: dos_at_e ( 1 : 3 , nspins ) ! fixed, adaptive, linear : spins !------------------------------------------------------------------------------- if (. not . ( linear . or . adaptive . or . fixed . or . quad )) call io_error ( \" DOS: No Broadening Set\" ) calc_weighted_dos = . false . if ( present ( matrix_weights )) calc_weighted_dos = . true . if ( calc_weighted_dos ) then mw % norbitals = size ( matrix_weights , 1 ) mw % nbands = size ( matrix_weights , 2 ) mw % nkpoints = size ( matrix_weights , 3 ) mw % nspins = size ( matrix_weights , 4 ) end if if ( calc_weighted_dos ) then if ( mw % nspins . ne . nspins ) call io_error ( \"ERROR : DOS :  mw%nspins not equal to nspins.\" ) if ( mw % nkpoints . ne . num_kpoints_on_node ( my_node_id )) & & call io_error ( \"ERROR : DOS : mw%nkpoints not equal to nkpoints.\" ) end if !------------------------------------------------------------------------------- ! R E A D   B A N D   G R A D I E N T S ! If we're using one of the more accurate roadening schemes we also need to read in the ! band gradients too if ( quad . or . linear . or . adaptive ) then if (. not . allocated ( band_gradient )) call elec_read_band_gradient end if !------------------------------------------------------------------------------- ! C A L C U L A T E   D O S ! Now everything is set up, we can perform the dos accumulation in parellel time0 = io_time () if ( fixed ) then if ( calc_weighted_dos . and . (. not . adaptive ) . and . (. not . linear )) then call calculate_dos_at_e ( \"f\" , energy , dos_at_e ( 1 , :), matrix_weights = matrix_weights , & & weighted_dos_at_e = weighted_dos_at_e ) call dos_utils_merge_at_e ( dos_at_e ( 1 , :), weighted_dos_at_e = weighted_dos_at_e ) else call calculate_dos_at_e ( \"f\" , energy , dos_at_e ( 1 , :)) call dos_utils_merge_at_e ( dos_at_e ( 1 , :)) end if end if if ( adaptive ) then if ( calc_weighted_dos . and . (. not . linear )) then call calculate_dos_at_e ( \"a\" , energy , dos_at_e ( 2 , :), matrix_weights = matrix_weights , & & weighted_dos_at_e = weighted_dos_at_e ) call dos_utils_merge_at_e ( dos_at_e ( 2 , :), weighted_dos_at_e = weighted_dos_at_e ) else call calculate_dos_at_e ( \"a\" , energy , dos_at_e ( 2 , :)) call dos_utils_merge_at_e ( dos_at_e ( 2 , :)) end if end if if ( linear ) then if ( calc_weighted_dos ) then call calculate_dos_at_e ( \"l\" , energy , dos_at_e ( 3 , :), matrix_weights = matrix_weights , & & weighted_dos_at_e = weighted_dos_at_e ) call dos_utils_merge_at_e ( dos_at_e ( 3 , :), weighted_dos_at_e = weighted_dos_at_e ) else call calculate_dos_at_e ( \"l\" , energy , dos_at_e ( 3 , :)) call dos_utils_merge_at_e ( dos_at_e ( 3 , :)) end if end if ! if(quad) then ! ! endif time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate DOS at certain energy                & &      ' , time1 - time0 , ' (sec) +' end if !------------------------------------------------------------------------------- end subroutine dos_utils_calculate_at_e !=============================================================================== subroutine calculate_dos_at_e ( dos_type , energy , dos_at_e , matrix_weights , weighted_dos_at_e ) !=============================================================================== ! Once everything is set up this is the main workhorse of the module. ! It accumulates the DOS and WDOS be looping over spins, kpoints and bands. !------------------------------------------------------------------------------- ! Arguments: dos           (out)       : The Density of States !            intdos        (out)       : The Integrated DOS !            matrix_weights(in)  (opt) : The weightings, such as LCAO for the !                                        weighted dos. !            weighted_dos  (out) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: delta_bins !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: If linear, fixed and adaptive are all set. It produces the ! linear result, no matter what was intended. This would need to be modified to ! take an optinal argument, which would force only one of the above to be set ! within the subroutine. Since linear, fixed and adaptive are only non-mutually ! exculsive when debugging (such things as efermi) this isn't a priority !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 Heavliy modified from LinDOS !=============================================================================== use od_algorithms , only : gaussian use od_cell , only : kpoint_grid_dim , kpoint_weight , num_kpoints_on_node , & & recip_lattice use od_electronic , only : band_gradient , electrons_per_state , nbands , nspins , band_energy use od_parameters , only : adaptive_smearing , fixed_smearing & &, finite_bin_correction , iprint , hybrid_linear_grad_tol , hybrid_linear use od_io , only : stdout , io_error use od_comms , only : my_node_id , on_root implicit none integer :: ik , ib , is , iorb , i real ( kind = dp ) :: dos_temp , cuml , intdos_accum , width , adaptive_smearing_temp real ( kind = dp ) :: grad ( 1 : 3 ), step ( 1 : 3 ), EV ( 0 : 4 ), sub_cell_length ( 1 : 3 ) character ( len = 1 ), intent ( in ) :: dos_type !! RJN3JUN changed !    character(len=1)                   :: dos_type   !! RJN3Jun changed real ( kind = dp ), intent ( out ), optional :: weighted_dos_at_e (:, :) !! RJN3Jun changed real ( kind = dp ), intent ( in ), optional :: matrix_weights (:, :, :, :) real ( kind = dp ), intent ( in ) :: energy real ( kind = dp ), intent ( out ) :: dos_at_e ( nspins ) logical :: linear , fixed , adaptive , have_weighted_dos , force_adaptive have_weighted_dos = . false . if ( present ( weighted_dos_at_e )) have_weighted_dos = . true . linear = . false . fixed = . false . adaptive = . false . !    if(fixed)       dos_type=\"f\"     !! RJN3Jun added !    if(adaptive)  dos_type=\"a\"       !! RJN3Jun added !    if(linear)      dos_type=\"l\"     !! RJN3Jun added select case ( dos_type ) case ( \"l\" ) linear = . true . case ( \"a\" ) adaptive = . true . case ( \"f\" ) fixed = . true . case default call io_error ( \" ERROR : unknown dos_type in calculate_dos \" ) end select width = 0.0_dp ! Just in case dos_at_e = 0.0_dp if ( linear . or . adaptive ) step (:) = 1.0_dp / real ( kpoint_grid_dim (:), dp ) / 2.0_dp if ( adaptive . or . hybrid_linear ) then do i = 1 , 3 sub_cell_length ( i ) = sqrt ( recip_lattice ( i , 1 ) ** 2 + recip_lattice ( i , 2 ) ** 2 + recip_lattice ( i , 3 ) ** 2 ) * step ( i ) end do adaptive_smearing_temp = adaptive_smearing * sum ( sub_cell_length ) / 3 end if if ( fixed ) width = fixed_smearing if ( have_weighted_dos ) weighted_dos_at_e = 0.0_dp if (( iprint > 1 ) . and . on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) \"+------------------------- Calculate DOS at energy --------------------------+\" end if do ik = 1 , num_kpoints_on_node ( my_node_id ) if ( iprint > 1 . and . on_root ) then if ( mod ( real ( ik , dp ), 1 0.0_dp ) == 0.0_dp ) write ( stdout , '(1x,1a,a28,i4,a3,i4,a14,10x,a14)' ) '|' , & & \"Calculating k-point \" , ik , \" of\" , num_kpoints_on_node ( my_node_id ), \" on this node\" , \"<-- DOS at E |\" end if do is = 1 , nspins do ib = 1 , nbands if (. not . fixed ) then if ( linear . or . adaptive ) grad (:) = band_gradient ( ib , :, ik , is ) ! If the band is very flat linear broadening can have problems describing it. In this case, fall back to ! adaptive smearing (and take advantage of FBCS if required). force_adaptive = . false . if ( hybrid_linear . and . ( hybrid_linear_grad_tol > sqrt ( dot_product ( grad , grad )))) force_adaptive = . true . if ( linear . and . . not . force_adaptive ) call doslin_sub_cell_corners ( grad , step , band_energy ( ib , is , ik ), EV ) if ( adaptive . or . force_adaptive ) width = sqrt ( dot_product ( grad , grad )) * adaptive_smearing_temp end if ! Hybrid Adaptive -- This way we don't lose weight at very flat parts of the ! band. It's a kind of fudge that we wouldn't need if we had infinitely small bins. if ( finite_bin_correction ) then ! Force the compiler to do this the right way around if ( width < delta_bins ) then width = delta_bins end if end if intdos_accum = 0.0_dp ! The linear method has a special way to calculate the integrated dos ! we have to take account for this here. if ( linear . and . . not . force_adaptive ) then dos_temp = doslin ( EV ( 0 ), EV ( 1 ), EV ( 2 ), EV ( 3 ), EV ( 4 ), energy , cuml ) * electrons_per_state * kpoint_weight ( ik ) else dos_temp = gaussian ( band_energy ( ib , is , ik ), width , energy ) * electrons_per_state * kpoint_weight ( ik ) end if dos_at_e ( is ) = dos_at_e ( is ) + dos_temp if ( have_weighted_dos ) then if ( ik . le . mw % nkpoints ) then if ( ib . le . mw % nbands ) then do iorb = 1 , mw % norbitals weighted_dos_at_e ( is , iorb ) = weighted_dos_at_e ( is , iorb ) + & & dos_temp * matrix_weights ( iorb , ib , ik , is ) end do end if end if end if end do end do end do if (( iprint > 1 ) . and . on_root ) write ( stdout , '(1x,a78)' ) & & \"+----------------------------------------------------------------------------+\" end subroutine calculate_dos_at_e !=============================================================================== subroutine dos_utils_merge_at_e ( dos , weighted_dos_at_e ) !=============================================================================== ! The DOS was calculated accross nodes. Now give them all back to root ! and free up the memeory on the slaves !------------------------------------------------------------------------------- ! Arguments: dos          (in - slaves) (inout -  root)       : The DOS !            weighted_dos (in - slaves) (inout -  root) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_comms , only : comms_reduce use od_electronic , only : nspins implicit none real ( kind = dp ), intent ( inout ), optional :: weighted_dos_at_e (:, :) ! bins.spins, orbitals RJN3Jun changed real ( kind = dp ), intent ( inout ) :: dos ( nspins ) call comms_reduce ( dos ( 1 ), nspins , \"SUM\" ) if ( present ( weighted_dos_at_e )) call comms_reduce ( weighted_dos_at_e ( 1 , 1 ), mw % nspins * mw % norbitals , \"SUM\" ) !    if(.not.on_root) then !       if(present(weighted_dos_at_e))  then !          if(allocated(weighted_dos_at_e)) deallocate(weighted_dos_at_e,stat=ierr) !          if (ierr/=0) call io_error (\" ERROR : dos : merge_dos : cannot deallocate weighted_dos\") !       end if !    endif end subroutine dos_utils_merge_at_e end module od_dos_utils","tags":"","loc":"sourcefile/dos_utils.f90.html"},{"title":"parameters.f90 – OptaDOS","text":"This file depends on sourcefile~~parameters.f90~~EfferentGraph sourcefile~parameters.f90 parameters.f90 sourcefile~constants.f90 constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~io.f90 io.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~cell.f90 cell.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~comms.f90 comms.F90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~comms.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~parameters.f90~~AfferentGraph sourcefile~parameters.f90 parameters.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~dos.f90 dos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~optics.f90 optics.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_parameters Source Code parameters.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! !                                                            ! ! This module contains GPL routines from Wannier90           ! ! Copyright (C) 2007 Jonathan Yates, Arash Mostofi,          ! !  Young-Su Lee, Nicola Marzari, Ivo Souza, David Vanderbilt ! !                                                            ! ! This file is distributed under the terms of the GNU        ! ! General Public License. See the file 'COPYING' in          ! ! the root directory of the present distribution, or         ! ! http://www.gnu.org/copyleft/gpl.txt .                      ! !                                                            ! !------------------------------------------------------------! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! module od_parameters use od_constants , only : dp use od_io , only : stdout , maxlen use od_cell , only : atoms_label , num_atoms , num_species , atoms_symbol , & & atoms_species_num , atoms_pos_frac , atoms_pos_cart , num_crystal_symmetry_operations implicit none !Generic Parameters character ( len = 20 ), public , save :: output_format character ( len = 100 ), public , save :: devel_flag integer , public , save :: iprint character ( len = 20 ), public , save :: energy_unit character ( len = 20 ), public , save :: length_unit ! not exposed - but useful for BZ plots? logical , public , save :: legacy_file_format integer , public , save :: kpoint_mp_grid ( 3 ) !Task parameters logical , public , save :: dos logical , public , save :: compare_dos logical , public , save :: pdos logical , public , save :: pdis logical , public , save :: jdos logical , public , save :: compare_jdos logical , public , save :: optics logical , public , save :: core logical , public , save :: photo !Broadening parameters logical , public , save :: fixed logical , public , save :: adaptive logical , public , save :: linear logical , public , save :: quad ! Belonging to the dos module logical , public , save :: compute_band_energy real ( kind = dp ), public , save :: adaptive_smearing real ( kind = dp ), public , save :: fixed_smearing real ( kind = dp ), public , save :: linear_smearing logical , public , save :: dos_per_volume real ( kind = dp ), public , save :: efermi_user ! If the user has set efermi in the odi file character ( len = 20 ), public , save :: efermi_choice ! Where do we want to get the fermi energy from logical , public , save :: finite_bin_correction logical , public , save :: hybrid_linear real ( kind = dp ), public , save :: hybrid_linear_grad_tol logical , public , save :: numerical_intdos logical , public , save :: compute_band_gap logical , public , save :: set_efermi_zero ! Set fermi level to zero in dos plot default true real ( kind = dp ), public , save :: dos_min_energy real ( kind = dp ), public , save :: dos_max_energy real ( kind = dp ), public , save :: dos_spacing integer , public , save :: dos_nbins ! pdos & pdis character ( len = maxlen ), public , save :: projectors_string ! Belonging to the jdos module real ( kind = dp ), public , save :: jdos_max_energy real ( kind = dp ), public , save :: jdos_spacing real ( kind = dp ), public , save :: scissor_op integer , allocatable , public , save :: exclude_bands (:) integer , public , save :: num_exclude_bands ! this is set by param_write ! Optics parameters character ( len = 20 ), public , save :: optics_geom real ( kind = dp ), public , save :: optics_qdir ( 3 ) logical , public , save :: optics_intraband real ( kind = dp ), public , save :: optics_drude_broadening real ( kind = dp ), public , save :: optics_lossfn_gaussian logical , public , save :: optics_lossfn_broadening ! the is set by param_write ! Core parameters character ( len = 20 ), public , save :: core_geom real ( kind = dp ), public , save :: core_qdir ( 3 ) logical , public , save :: core_LAI_broadening character ( len = 20 ), public , save :: core_type real ( kind = dp ), public , save :: LAI_gaussian_width logical , public , save :: LAI_gaussian real ( kind = dp ), public , save :: LAI_lorentzian_width real ( kind = dp ), public , save :: LAI_lorentzian_scale real ( kind = dp ), public , save :: LAI_lorentzian_offset logical , public , save :: LAI_lorentzian real ( kind = dp ), public , save :: core_chemical_shift ! used in conjunction with miz_chemical_shift script in tools ! Photoemission parameters - V.Chang, et al. Dec-2022 character ( len = 20 ), public , save :: photo_model character ( len = 20 ), public , save :: write_photo_output character ( len = 20 ), public , save :: photo_momentum character ( len = 20 ), public , save :: photo_layer_choice integer , public , save :: photo_max_layer !logical,           public, save :: angle_resolution !character(len=20), public, save :: resolution_type real ( kind = dp ), public , save :: photo_phi_lower real ( kind = dp ), public , save :: photo_phi_upper real ( kind = dp ), public , save :: photo_theta_lower real ( kind = dp ), public , save :: photo_theta_upper real ( kind = dp ), public , save :: photo_photon_energy logical , public , save :: photo_photon_sweep real ( kind = dp ), public , save :: photo_photon_min real ( kind = dp ), public , save :: photo_photon_max real ( kind = dp ), public , save :: photo_bulk_cutoff real ( kind = dp ), public , save :: photo_temperature real ( kind = dp ), public , save :: photo_elec_field integer , public , save :: photo_len_imfp_const real ( kind = dp ), dimension (:), allocatable , public , save :: photo_imfp_const ! real(kind=dp), dimension(:), allocatable, public, save :: photo_imfp_list ! logical, public, save :: photo_e_units ! logical, public, save :: photo_mte real ( kind = dp ), public , save :: photo_work_function ! real(kind=dp), public, save :: photo_surface_area ! real(kind=dp), public, save :: photo_slab_volume real ( kind = dp ), public , save :: photo_slab_min real ( kind = dp ), public , save :: photo_slab_max logical , public , save :: photo_remove_box_states real ( kind = dp ), public , save :: lenconfac private integer :: num_lines character ( len = maxlen ), allocatable :: in_data (:) public :: param_read public :: param_write public :: param_write_header public :: param_write_atomic_coord public :: param_dealloc public :: param_dist contains !==================================================================! subroutine param_read () !==================================================================! !                                                                  ! ! Read parameters and calculate derived values                     ! !                                                                  ! !=================================================================== use od_constants , only : bohr2ang use od_io , only : io_error , seedname , stderr use od_cell , only : cell_get_atoms , cell_read_cell implicit none !local variables integer :: i_temp , loop , ierr logical :: found character ( len = 20 ), allocatable :: task_string (:) character ( len = 20 ) :: c_string call param_in_file iprint = 1 ! Verbosity call param_get_keyword ( 'iprint' , found , i_value = iprint ) legacy_file_format = . false . call param_get_keyword ( 'legacy_file_format' , found , l_value = legacy_file_format ) energy_unit = 'ev' ! call param_get_keyword ( 'energy_unit' , found , c_value = energy_unit ) if ( index ( energy_unit , 'ev' ) == 0 . and . index ( energy_unit , 'ry' ) == 0 . and . index ( energy_unit , 'ha' ) == 0 ) & call io_error ( 'Error: value of energy_unit not recognised in param_read' ) dos = . false .; pdos = . false .; pdis = . false .; jdos = . false .; optics = . false . core = . false .; compare_dos = . false .; compare_jdos = . false .; photo = . false .; photo_photon_sweep = . false . call param_get_vector_length ( 'task' , found , i_temp ) if ( found . and . i_temp > 0 ) then allocate ( task_string ( i_temp ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - allocation failed for task_string' ) call param_get_keyword_vector ( 'task' , found , i_temp , c_value = task_string ) do loop = 1 , i_temp if ( index ( task_string ( loop ), 'optics' ) > 0 ) then optics = . true . elseif ( index ( task_string ( loop ), 'core' ) > 0 ) then core = . true . elseif ( index ( task_string ( loop ), 'compare_jdos' ) > 0 ) then jdos = . true .; compare_jdos = . true . elseif ( index ( task_string ( loop ), 'jdos' ) > 0 ) then jdos = . true . elseif ( index ( task_string ( loop ), 'pdos' ) > 0 ) then pdos = . true . elseif ( index ( task_string ( loop ), 'pdispersion' ) > 0 ) then pdis = . true . elseif ( index ( task_string ( loop ), 'compare_dos' ) > 0 ) then dos = . true .; compare_dos = . true . elseif ( index ( task_string ( loop ), 'dos' ) > 0 ) then dos = . true . elseif ( index ( task_string ( loop ), 'photoemission' ) > 0 ) then photo = . true . elseif ( index ( task_string ( loop ), 'photon_sweep' ) > 0 ) then photo = . true .; photo_photon_sweep = . true . elseif ( index ( task_string ( loop ), 'none' ) > 0 ) then dos = . false .; pdos = . false .; jdos = . false .; optics = . false .; core = . false . elseif ( index ( task_string ( loop ), 'all' ) > 0 ) then dos = . true .; pdos = . true .; jdos = . true .; optics = . true .; core = . true . else call io_error ( 'Error: value of task unrecognised in param_read' ) end if end do deallocate ( task_string , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - deallocation failed for task_string' ) end if if (( compare_dos . or . compare_jdos ) . and . ( pdos . or . core . or . optics . or . photo )) & call io_error ( 'Error: compare_dos/compare_jdos are not comptable with pdos, core, optics or photoemission tasks' ) if ( pdis . and . ( optics . or . core . or . jdos . or . pdos . or . dos . or . compare_dos . or . compare_jdos . or . photo )) & call io_error ( 'Error: projected bandstructure not compatible with any other tasks' ) i_temp = 0 fixed = . false .; adaptive = . false .; linear = . false .; quad = . false . call param_get_keyword ( 'broadening' , found , c_value = c_string ) if ( found ) then if ( index ( c_string , 'fixed' ) > 0 ) then fixed = . true . elseif ( index ( c_string , 'adaptive' ) > 0 ) then adaptive = . true . elseif ( index ( c_string , 'linear' ) > 0 ) then linear = . true . elseif ( index ( c_string , 'quad' ) > 0 ) then quad = . true . !          fixed=.true.;adaptive=.true.;linear=.true. else call io_error ( 'Error: value of broadening unrecognised in param_read' ) end if end if if ( compare_dos . or . compare_jdos ) then fixed = . true .; adaptive = . true .; linear = . true . end if if (. not . pdis . and . . not . ( fixed . or . adaptive . or . linear . or . quad )) then ! Pick a default adaptive = . true . end if kpoint_mp_grid = - 999 call param_get_keyword_vector ( 'kpoint_mp_grid' , found , 3 , i_value = kpoint_mp_grid ) length_unit = 'ang' ! lenconfac = 1.0_dp call param_get_keyword ( 'length_unit' , found , c_value = length_unit ) if ( length_unit . ne . 'ang' . and . length_unit . ne . 'bohr' ) & call io_error ( 'Error: value of length_unit not recognised in param_read' ) if ( length_unit . eq . 'bohr' ) lenconfac = 1.0_dp / bohr2ang adaptive_smearing = 0.4_dp ! LinDOS default call param_get_keyword ( 'adaptive_smearing' , found , r_value = adaptive_smearing ) fixed_smearing = 0.3_dp ! LinDOS default call param_get_keyword ( 'fixed_smearing' , found , r_value = fixed_smearing ) linear_smearing = 0.0_dp call param_get_keyword ( 'linear_smearing' , found , r_value = linear_smearing ) efermi_user = - 99 9.0_dp if (. not . pdis ) then efermi_choice = \"optados\" else efermi_choice = \"file\" end if call param_get_efermi ( 'efermi' , found , efermi_choice , efermi_user ) compute_band_energy = . true . call param_get_keyword ( 'compute_band_energy' , found , l_value = compute_band_energy ) ! Here we apply a chemical shift to the core energy if supplied by the user core_chemical_shift = - 1.0_dp ! Mizoguchi chemical shift is always +ve call param_get_keyword ( 'core_chemical_shift' , found , r_value = core_chemical_shift ) if ( core_chemical_shift > 0.0_dp ) compute_band_gap = . true . ! Force all Gaussians to be greater than the width of a bin. When using numerical_indos ! this is critical for counting all of the Gaussian DOS peaks. ! When using semi-analytic integration it is desirable to show up very sharp peaks in the ! DOS. However, the intDOS will not be affected. finite_bin_correction = . true . call param_get_keyword ( 'finite_bin_correction' , found , l_value = finite_bin_correction ) ! Perform fixed and adaptive smearing summing the contribution of each Gaussian ! instead of the new and better way of taking the erf. Left in for comparison to LinDOS numerical_intdos = . false . call param_get_keyword ( 'numerical_intdos' , found , l_value = numerical_intdos ) ! Whenever very flat features are found when performing linear broadening, revert to adaptive. ! The tolerance is the gradient of the band at the kpoint. ! N.B. Finite_bin_correction may also be set, to further improve the spectra. hybrid_linear = . false . call param_get_keyword ( 'hybrid_linear' , found , l_value = hybrid_linear ) hybrid_linear_grad_tol = 0.01_dp ! Seems about right for getting semi-core states correctly integrated. call param_get_keyword ( 'hybrid_linear_grad_tol' , found , r_value = hybrid_linear_grad_tol ) set_efermi_zero = . false . if ( pdis ) set_efermi_zero = . true . call param_get_keyword ( 'set_efermi_zero' , found , l_value = set_efermi_zero ) dos_per_volume = . false . call param_get_keyword ( 'dos_per_volume' , found , l_value = dos_per_volume ) dos_min_energy = - huge ( dos_min_energy ) call param_get_keyword ( 'dos_min_energy' , found , r_value = dos_min_energy ) dos_max_energy = huge ( dos_max_energy ) call param_get_keyword ( 'dos_max_energy' , found , r_value = dos_max_energy ) dos_spacing = - 1.0_dp call param_get_keyword ( 'dos_spacing' , found , r_value = dos_spacing ) dos_nbins = - 1 ! 10001 LinDOS default call param_get_keyword ( 'dos_nbins' , found , i_value = dos_nbins ) projectors_string = '' if ( pdos ) call param_get_keyword ( 'pdos' , found , c_value = projectors_string ) if ( pdos . and . ( len_trim ( projectors_string ) == 0 )) call io_error ( 'pdos requested but pdos is not specified' ) if ( pdis ) call param_get_keyword ( 'pdispersion' , found , c_value = projectors_string ) if ( pdis . and . ( len_trim ( projectors_string ) == 0 )) & & call io_error ( 'pdispersion requested but pdispersion keyword is not specified' ) jdos_max_energy = - 1.0_dp !! change call param_get_keyword ( 'jdos_max_energy' , found , r_value = jdos_max_energy ) jdos_spacing = 0.01_dp !! change call param_get_keyword ( 'jdos_spacing' , found , r_value = jdos_spacing ) num_exclude_bands = 0 call param_get_range_vector ( 'exclude_bands' , found , num_exclude_bands , lcount = . true .) if ( found ) then if ( num_exclude_bands < 1 ) call io_error ( 'Error: problem reading exclude_bands' ) allocate ( exclude_bands ( num_exclude_bands ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating exclude_bands in param_read' ) call param_get_range_vector ( 'exclude_bands' , found , num_exclude_bands , . false ., exclude_bands ) if ( any ( exclude_bands < 1 )) & call io_error ( 'Error: exclude_bands must contain positive numbers' ) end if compute_band_gap = . true . call param_get_keyword ( 'compute_band_gap' , found , l_value = compute_band_gap ) devel_flag = ' ' call param_get_keyword ( 'devel_flag' , found , c_value = devel_flag ) output_format = 'xmgrace' call param_get_keyword ( 'output_format' , found , c_value = output_format ) if ( index ( output_format , 'xmgrace' ) == 0 . and . index ( output_format , 'gnuplot' ) == 0 ) & call io_error ( 'Error: value of output_format not recognised in param_read' ) optics_geom = 'polycrys' call param_get_keyword ( 'optics_geom' , found , c_value = optics_geom ) if ( index ( optics_geom , 'polar' ) == 0 . and . index ( optics_geom , 'polycrys' ) == 0 . and . index ( optics_geom , 'tensor' ) == 0 ) & call io_error ( 'Error: value of optics_geom not recognised in param_read' ) scissor_op = 0.0_dp !! change call param_get_keyword ( 'scissor_op' , found , r_value = scissor_op ) optics_qdir = 0.0_dp call param_get_keyword_vector ( 'optics_qdir' , found , 3 , r_value = optics_qdir ) if ( index ( optics_geom , 'polar' ) > 0 . and . . not . found ) & call io_error ( 'Error: polarised or unpolarised optics geometry requested but optics_qdir is not set' ) if (( index ( optics_geom , 'polycrys' ) > 0 . or . index ( optics_geom , 'tensor' ) > 0 ) . and . found ) & call io_error ( 'Error: polycrystalline optics geometry or full dielectric tensor requested but optics_qdir is set' ) optics_intraband = . false . call param_get_keyword ( 'optics_intraband' , found , l_value = optics_intraband ) optics_drude_broadening = 1.0e14_dp call param_get_keyword ( 'optics_drude_broadening' , found , r_value = optics_drude_broadening ) optics_lossfn_broadening = . false . optics_lossfn_gaussian = 0.0_dp call param_get_keyword ( 'optics_lossfn_broadening' , optics_lossfn_broadening , r_value = optics_lossfn_gaussian ) if ( optics_lossfn_gaussian < 0.0_dp ) call io_error ( 'Error: optics_lossfn_broadening must be positive' ) if ( abs ( optics_lossfn_gaussian ) < 1.0e-6_dp ) optics_lossfn_broadening = . false . ! trap too small values core_geom = 'polycrys' call param_get_keyword ( 'core_geom' , found , c_value = core_geom ) if (( index ( core_geom , 'polycrys' ) == 0 ) . and . ( index ( core_geom , 'polar' ) == 0 )) & call io_error ( 'Error: value of core_geom not recognised in param_read' ) core_type = 'absorption' call param_get_keyword ( 'core_type' , found , c_value = core_type ) if ( core_type . ne . 'absorption' . and . core_type . ne . 'emission' . and . core_type . ne . 'all' ) & call io_error ( 'Error: value of core_type not recognised in param_read' ) core_qdir = 0.0_dp call param_get_keyword_vector ( 'core_qdir' , found , 3 , r_value = core_qdir ) if ( index ( core_geom , 'polar' ) > 0 . and . . not . found ) & call io_error ( 'Error: polarised core geometry requested but core_qdir is not set' ) if ( index ( core_geom , 'polycrys' ) > 0 . and . found ) & call io_error ( 'Error: polycrystalline core geometry requested but core_qdir is set' ) core_LAI_broadening = . false . call param_get_keyword ( 'core_lai_broadening' , found , l_value = core_LAI_broadening ) LAI_gaussian_width = 0.0_dp LAI_gaussian = . false . call param_get_keyword ( 'lai_gaussian_width' , found , r_value = LAI_gaussian_width ) if ( LAI_gaussian_width . gt . 1E-14 ) LAI_gaussian = . true . if ( LAI_gaussian_width . lt . 0.0_dp ) call io_error ( 'Error: LAI_gaussian_width must be positive' ) LAI_lorentzian_width = 0.0_dp LAI_lorentzian = . false . call param_get_keyword ( 'lai_lorentzian_width' , found , r_value = LAI_lorentzian_width ) if ( LAI_lorentzian_width . gt . 1E-14 ) LAI_lorentzian = . true . if ( LAI_lorentzian_width . lt . 0.0_dp ) call io_error ( 'Error: LAI_lorentzian_width must be positive' ) LAI_lorentzian_scale = 0.1_dp call param_get_keyword ( 'lai_lorentzian_scale' , found , r_value = LAI_lorentzian_scale ) !    if (LAI_lorentzian_scale.gt.1E-14) LAI_lorentzian=.true. if ( LAI_lorentzian_scale . lt . 0.0_dp ) call io_error ( 'Error: LAI_lorentzian_scale must be positive' ) LAI_lorentzian_offset = 0.0_dp call param_get_keyword ( 'lai_lorentzian_offset' , found , r_value = LAI_lorentzian_offset ) if ( LAI_lorentzian_offset . lt . 0.0_dp ) call io_error ( 'Error: LAI_lorentzian_offset must be positive' ) ! Photoemission parameters - V.Chang Nov-2020 photo_momentum = 'crystal' call param_get_keyword ( 'photo_momentum' , found , c_value = photo_momentum ) if ( index ( photo_momentum , 'kp' ) == 0 . and . index ( photo_momentum , 'crystal' ) == 0 . and . index ( photo_momentum , 'operator' ) == 0 ) & call io_error ( 'Error: value of momentum not recognised in param_read' ) write_photo_output = 'off' call param_get_keyword ( 'write_photo_output' , found , c_value = write_photo_output ) if ( index ( write_photo_output , 'qe_matrix' ) == 0 . and . index ( write_photo_output , 'e_bind' ) == 0 . and . & & index ( write_photo_output , 'off' ) == 0 ) then call io_error ( 'Error: value of write_photo_output output not recognised in param_read' ) end if photo_model = '1step' call param_get_keyword ( 'photo_model' , found , c_value = photo_model ) if ( index ( photo_model , '3step' ) > 0 . and . index ( photo_model , '1step' ) > 0 . or . & index ( photo_model , '3step' ) > 0 . and . index ( photo_model , 'ds_like_pe' ) > 0 . or . & index ( photo_model , '1step' ) > 0 . and . index ( photo_model , 'ds_like_pe' ) > 0 ) then call io_error ( 'Error: value of photoemission model not recognised in param_read' ) end if call param_get_keyword ( 'photo_work_function' , found , r_value = photo_work_function ) if ( photo . and . . not . found ) & call io_error ( 'Error: please set workfunction for photoemission calculation' ) photo_theta_lower = 0.0_dp call param_get_keyword ( 'photo_theta_lower' , found , r_value = photo_theta_lower ) photo_theta_upper = 9 0.0_dp call param_get_keyword ( 'photo_theta_upper' , found , r_value = photo_theta_upper ) photo_phi_lower = 0.0_dp call param_get_keyword ( 'photo_phi_lower' , found , r_value = photo_phi_lower ) photo_phi_upper = 9 0.0_dp call param_get_keyword ( 'photo_phi_upper' , found , r_value = photo_phi_upper ) photo_photon_min = 3.0_dp call param_get_keyword ( 'photo_photon_min' , found , r_value = photo_photon_min ) photo_photon_max = 2.0_dp call param_get_keyword ( 'photo_photon_max' , found , r_value = photo_photon_max ) if ( photo_photon_min . gt . photo_photon_max . and . photo_photon_sweep ) & call io_error ( 'Error: max photon value is lower than min photon value or they have not been set' ) call param_get_keyword ( 'photo_photon_energy' , found , r_value = photo_photon_energy ) if ( found . and . photo_photon_sweep ) call io_error ( 'Error: cannot set photon energy for photon energy sweep calculation' ) if ( photo . and . . not . found . and . . not . photo_photon_sweep ) & call io_error ( 'Error: please set photon energy for photoemission calculation' ) photo_bulk_cutoff = 1 0.0_dp call param_get_keyword ( 'photo_bulk_cutoff' , found , r_value = photo_bulk_cutoff ) if ( found ) photo_bulk_cutoff = - 1 * log ( photo_bulk_cutoff ) photo_temperature = 29 8.0_dp call param_get_keyword ( 'photo_temperature' , found , r_value = photo_temperature ) ! call param_get_keyword('photo_surface_area', found, r_value=photo_surface_area) ! if (photo .and. .not. found) & ! call io_error('Error: please set surface area for photoemission calculation') ! call param_get_keyword('photo_slab_volume', found, r_value=photo_slab_volume) ! if (photo .and. .not. found) & !   call io_error('Error: please set volume of the slab for photoemission calculation') photo_slab_min = 0.0_dp call param_get_keyword ( 'photo_slab_min' , found , r_value = photo_slab_min ) ! if(photo .and. .not. found) & !     call io_error('Error: please set volume of the slab for photoemission calculation') photo_slab_max = 0.0_dp call param_get_keyword ( 'photo_slab_max' , found , r_value = photo_slab_max ) if ( photo_slab_max . lt . 0.0_dp . or . photo_slab_min . lt . 0.0_dp ) then call io_error ( 'Error: the supplied min or max values are negative, which causes faulty calculations!' ) end if if ( photo_slab_max . lt . photo_slab_min ) then call io_error ( 'Error: the supplied slab_max value is less than the slab_min value!' ) end if photo_remove_box_states = . False . call param_get_keyword ( 'photo_remove_box_states' , found , l_value = photo_remove_box_states ) photo_layer_choice = 'optados' call param_get_keyword ( 'photo_layer_choice' , found , c_value = photo_layer_choice ) photo_max_layer = - 1 call param_get_keyword ( 'photo_max_layer' , found , i_value = photo_max_layer ) if ( photo . and . index ( photo_layer_choice , 'user' ) . gt . 0 . and . . not . found ) & call io_error ( 'Error: max # of layers was set to be supplied by user, but does not exist in input' ) photo_elec_field = 0.00_dp call param_get_keyword ( 'photo_elec_field' , found , r_value = photo_elec_field ) call param_get_vector_length ( 'photo_imfp_const' , found , i_temp ) if ( found ) then photo_len_imfp_const = i_temp allocate ( photo_imfp_const ( i_temp ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - allocation failed for photo_imfp_const' ) call param_get_keyword_vector ( 'photo_imfp_const' , found , i_temp , r_value = photo_imfp_const ) else photo_len_imfp_const = 1 allocate ( photo_imfp_const ( 1 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_read - allocation failed for photo_imfp_const' ) photo_imfp_const = 0.0_dp end if if ( photo . and . . not . found ) & call io_error ( 'Error: constant imfp, but photo_imfp_const is not set' ) num_atoms = 0 num_species = 0 num_crystal_symmetry_operations = 0 if ( pdos . or . pdis . or . core . or . optics . or . photo . or . jdos ) then ! try to read in the atoms from the cell file. ! We don't need them otherwise, so let's not bother !  if(index(devel_flag,'old_filename')>0) then ! No longer need to call get_atoms as we're forcing people who use the legacy code to make an -out.cell !     call cell_get_atoms !  else call cell_read_cell !  end if end if ! check to see that there are no unrecognised keywords if ( any ( len_trim ( in_data (:)) > 0 )) then write ( stderr , '(1x,a)' ) 'The following section of file ' // trim ( seedname ) // '.odi contained unrecognised keywords' write ( stderr , * ) do loop = 1 , num_lines if ( len_trim ( in_data ( loop )) > 0 ) then write ( stderr , '(1x,a)' ) trim ( in_data ( loop )) end if end do write ( stderr , * ) call io_error ( 'Unrecognised keyword(s) in input file' ) end if call param_uppercase () deallocate ( in_data , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating in_data in param_read' ) ! =============================== ! ! Some checks and initialisations ! ! =============================== ! if ( dos_min_energy . ge . dos_max_energy ) then call io_error ( 'Error: must have dos_min_energy < dos_max_energy' ) end if if (( dos_nbins > 0 ) . and . ( dos_spacing > 0.0_dp )) then call io_error ( 'Error: only one of dos_nbins and dos_spacing may be set' ) end if if (( dos_nbins < 0 ) . and . ( dos_spacing < 0.0_dp )) then dos_spacing = 0.005 ! Roughly similar to LinDOS end if return end subroutine param_read !=================================================================== subroutine param_uppercase !=================================================================== !                                                                  ! ! Convert a few things to uppercase to look nice in the output     ! !                                                                  ! !=================================================================== implicit none integer :: nsp , ic ! Atom labels (eg, si --> Si) do nsp = 1 , num_species ic = ichar ( atoms_label ( nsp ) ( 1 : 1 )) if (( ic . ge . ichar ( 'a' )) . and . ( ic . le . ichar ( 'z' ))) & atoms_label ( nsp ) ( 1 : 1 ) = char ( ic + ichar ( 'Z' ) - ichar ( 'z' )) end do do nsp = 1 , num_species ic = ichar ( atoms_symbol ( nsp ) ( 1 : 1 )) if (( ic . ge . ichar ( 'a' )) . and . ( ic . le . ichar ( 'z' ))) & atoms_symbol ( nsp ) ( 1 : 1 ) = char ( ic + ichar ( 'Z' ) - ichar ( 'z' )) end do ! Length unit (ang --> Ang, bohr --> Bohr) ic = ichar ( length_unit ( 1 : 1 )) if (( ic . ge . ichar ( 'a' )) . and . ( ic . le . ichar ( 'z' ))) & length_unit ( 1 : 1 ) = char ( ic + ichar ( 'Z' ) - ichar ( 'z' )) return end subroutine param_uppercase !=================================================================== subroutine param_write_header use od_constants , only : optados_version , copyright implicit none write ( stdout , * ) write ( stdout , '(a78)' ) \" +===========================================================================+\" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |                OOO   PPPP  TTTTT  AA   DDD    OOO    SSS                  | \" write ( stdout , '(a78)' ) \" |               O   O  P   P   T   A  A  D  D  O   O  S                     | \" write ( stdout , '(a78)' ) \" |               O   O  PPPP    T   AAAA  D  D  O   O   SS                   | \" write ( stdout , '(a78)' ) \" |               O   O  P       T   A  A  D  D  O   O     S                  | \" write ( stdout , '(a78)' ) \" |                OOO   P       T   A  A  DDD    OOO   SSS                   | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" +---------------------------------------------------------------------------+ \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a46,a5,a28)' ) \" |                 Welcome to OptaDOS version \" , optados_version , \"   & &                     | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |         Andrew J. Morris, Rebecca Nicholls, Chris J. Pickard              | \" write ( stdout , '(a78)' ) \" |                       and Jonathan R. Yates                               | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a34,a14,a30)' ) \" |                       Copyright\" , trim ( copyright ),& & \"                             | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |  Please cite:                                                             | \" write ( stdout , '(a78)' ) \" |  Andrew J. Morris, Rebecca Nicholls, Chris J. Pickard and Jonathan Yates  | \" write ( stdout , '(a78)' ) \" |              Comp. Phys. Comm. 185, 5, 1477 (2014)                        | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |  Additionally when using the linear broadening:                           | \" write ( stdout , '(a78)' ) \" | C.J. Pickard and M.C. Payne, Phys. Rev. B, 59, 7, 4685 (1999)             | \" write ( stdout , '(a78)' ) \" | C.J. Pickard and M.C. Payne, Phys. Rev. B, 62, 7, 4383 (2000)             | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |  Additionally when using the adaptive broadening:                         | \" write ( stdout , '(a78)' ) \" | J.Yates, X.Wang, D.Vanderbilt and I.Souza, Phys. Rev. B, 75, 195121 (2007)| \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" |      in all your publications arising from your use of OptaDOS            | \" write ( stdout , '(a78)' ) \" |                                                                           | \" write ( stdout , '(a78)' ) \" +===========================================================================+ \" write ( stdout , * ) end subroutine param_write_header subroutine param_write_atomic_coord !==================================================================! !                                                                  ! ! write atomic coodes to stdout                                       ! !                                                                  ! !=================================================================== implicit none integer :: nat , nsp , atom_counter ! System if ( num_atoms > 0 ) then write ( stdout , * ) ' ' ! IT DOESN'T SEEM HELPFUL TO WRITE OUT TO MULTIPLY THE INITAL ATOMIC POSITIONS WITH THE FINAL LATTICE... if ( iprint > 2 ) then write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' if ( lenconfac . eq . 1.0_dp ) then write ( stdout , '(1x,a)' ) '|   Site       Fractional Coordinate          Cartesian Coordinate (Ang)     |' else write ( stdout , '(1x,a)' ) '|   Site       Fractional Coordinate          Cartesian Coordinate (Bohr)    |' end if write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' do nsp = 1 , num_species do nat = 1 , atoms_species_num ( nsp ) write ( stdout , '(1x,a1,1x,a2,1x,i3,3F10.5,3x,a1,1x,3F10.5,4x,a1)' ) '|' , atoms_symbol ( nsp ), nat , & atoms_pos_frac (:, nat , nsp ), '|' , atoms_pos_cart (:, nat , nsp ) * lenconfac , '|' end do end do write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a)' ) '  WARNING: These are the CASTEP input coordinates not the output -- here to   ' write ( stdout , '(1x,a)' ) '            aid advanced debugging only.' else atom_counter = 1 write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a)' ) '|             Species                  Sites                  Total Atoms    |' write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' do nsp = 1 , num_species write ( stdout , '(1x,a1,16x,a2,16x,i4,a3,i4,16x,i4,11x,a)' ) '|' , atoms_symbol ( nsp ), & & atom_counter , \"to\" , atom_counter + atoms_species_num ( nsp ) - 1 , atoms_species_num ( nsp ), \"|\" atom_counter = atom_counter + atoms_species_num ( nsp ) end do write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' end if else if ( iprint > 1 ) write ( stdout , '(25x,a)' ) 'No atom positions read' end if write ( stdout , * ) ' ' end subroutine param_write_atomic_coord !=================================================================== subroutine param_write !==================================================================! !                                                                  ! ! write parameters to stdout                                       ! !                                                                  ! !=================================================================== implicit none integer :: nat , nsp ! System ! if(num_atoms>0) then !    write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' !    if (lenconfac.eq.1.0_dp) then !       write(stdout,'(1x,a)') '|   Site       Fractional Coordinate          Cartesian Coordinate (Ang)     |' !    else !       write(stdout,'(1x,a)') '|   Site       Fractional Coordinate          Cartesian Coordinate (Bohr)    |' !    endif !    write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' !    do nsp=1,num_species !       do nat=1,atoms_species_num(nsp) !          write(stdout,'(1x,a1,1x,a2,1x,i3,3F10.5,3x,a1,1x,3F10.5,4x,a1)') '|',atoms_symbol(nsp),nat,& !               atoms_pos_frac(:,nat,nsp),'|',atoms_pos_cart(:,nat,nsp)*lenconfac,'|' !       end do !    end do !    write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' ! else !    if(iprint>1)  write(stdout,'(25x,a)') 'No atom positions read' ! end if !  write(stdout,*) ' ' !!$ !!$    write(stdout,*) ' ' !!$    if(iprint>1) then !!$       write(stdout,'(1x,a)') '*----------------------------------------------------------------------------*' !!$       if (lenconfac.eq.1.0_dp) then !!$          write(stdout,'(1x,a)') '| k-point      Fractional Coordinate        Cartesian Coordinate (Ang&#94;-1)    |' !!$       else !!$          write(stdout,'(1x,a)') '| k-point      Fractional Coordinate        Cartesian Coordinate (Bohr&#94;-1)   |' !!$       endif !!$       write(stdout,'(1x,a)') '+----------------------------------------------------------------------------+' !!$       !       do nkp=1,nkpoints !!$       !          write(stdout,'(1x,a1,i6,1x,3F10.5,3x,a1,1x,3F10.5,4x,a1)') '|',& !!$       ! nkp,kpoint_r(:,nkp),'|',kpoint_r_cart(:,nkp)/lenconfac,'|' !!$       !       end do !!$       write(stdout,'(1x,a)') '*----------------------------------------------------------------------------*' !!$       write(stdout,*) ' ' !!$    end if !!$    ! Main ! write ( stdout , '(1x,a78)' ) '+------------------------------ JOB CONTROL ---------------------------------+' ! if ( dos ) then write ( stdout , '(1x,a78)' ) '|  Output Density of States                  :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Density of States                  :  False                        |' end if if ( pdos ) then write ( stdout , '(1x,a78)' ) '|  Output Partial Density of States          :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Partial Density of States          :  False                        |' end if if ( pdis ) then write ( stdout , '(1x,a78)' ) '|  Output Projected Bandstructure            :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Projected Bandstructure            :  False                        |' end if if ( jdos ) then write ( stdout , '(1x,a78)' ) '|  Output Joint Density of States            :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Joint Density of States            :  False                        |' end if if ( optics ) then write ( stdout , '(1x,a78)' ) '|  Output Optical Response                   :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Optical Response                   :  False                        |' end if if ( core ) then write ( stdout , '(1x,a78)' ) '|  Output Core-level Spectra                 :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Output Core-level Spectra                 :  False                        |' end if !Photoemission if ( photo ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Calculation                 :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Photoemission Calculation                 :  False                        |' end if write ( stdout , '(1x,a46,2x,i3,26x,a1)' ) '|  iprint level                              :' , iprint , '|' if ( legacy_file_format ) then write ( stdout , '(1x,a78)' ) '|  Use CASTEP < 6.0 file format              :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Use CASTEP < 6.0 file format              :  False                        |' end if write ( stdout , '(1x,a78)' ) '+-------------------------------- UNITS -------------------------------------+' write ( stdout , '(1x,a46,2x,a4,25x,a1)' ) '|  Length Unit                               :' , trim ( length_unit ), '|' if ( dos . or . pdos ) then if ( dos_per_volume ) then write ( stdout , '(1x,a78)' ) '|  J/P/DOS units                             :  electrons eV&#94;-1 Ang&#94;-3       |' else write ( stdout , '(1x,a78)' ) '|  J/P/DOS units                             :  electrons eV&#94;-1              |' end if end if write ( stdout , '(1x,a78)' ) '+-------------------------- SPECTRAL PARAMETERS -----------------------------+' if ( fixed ) then write ( stdout , '(1x,a78)' ) '|  Fixed Width Smearing                      :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Smearing Width                            :' , fixed_smearing , '|' end if if ( adaptive ) then write ( stdout , '(1x,a78)' ) '|  Adaptive Width Smearing                   :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Adaptive Smearing ratio                   :' , adaptive_smearing , '|' end if if ( linear ) then write ( stdout , '(1x,a78)' ) '|  Linear Extrapolation                      :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Smearing Width                            :' , linear_smearing , '|' end if if ( quad ) & write ( stdout , '(1x,a78)' ) '|  Quadratic Extrapolation                   :  True                         |' if ( finite_bin_correction ) & write ( stdout , '(1x,a78)' ) '|  Finite Bin Correction                     :  True                         |' if ( hybrid_linear ) then write ( stdout , '(1x,a78)' ) '|  Hybrid Linear Correction                  :  True                         |' write ( stdout , '(1x,a46,1x,F10.5,20x,a1)' ) '|  Hybrid Linear Gradient Tolerance          :' , hybrid_linear_grad_tol , '|' end if if ( numerical_intdos ) & write ( stdout , '(1x,a78)' ) '|  Numerical Integration of P/DOS            :  True                         |' if ( dos_per_volume ) & write ( stdout , '(1x,a78)' ) '|  Present DOS per simulation cell volume    :  True                         |' if ( set_efermi_zero ) then write ( stdout , '(1x,a78)' ) '|  Shift energy scale so fermi_energy=0      :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Shift energy scale so fermi_energy=0      :  False                        |' end if if ( efermi_user == - 99 9.0_dp ) then ! efermi_user not set if ( index ( efermi_choice , 'optados' ) . gt . 0 ) then write ( stdout , '(1x,a78)' ) '|  Fermi energy                              :  Calculated by OptaDOS        |' elseif ( index ( efermi_choice , 'file' ) . gt . 0 ) then write ( stdout , '(1x,a78)' ) '|  Fermi energy                              :  Read from file               |' elseif ( index ( efermi_choice , 'insulator' ) . gt . 0 ) then write ( stdout , '(1x,a78)' ) '|  Fermi energy                              :  Assume insulator (n_elec/2)  |' end if else ! It is set write ( stdout , '(1x,a46,1x,1F10.5,20x,a1)' ) '|  Fermi energy                              :' , efermi_user , '|' end if if ( compute_band_energy ) then write ( stdout , '(1x,a78)' ) '|  Compute the band energy                   :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Compute the band energy                   :  False                        |' end if if ( compute_band_gap ) then write ( stdout , '(1x,a78)' ) '|  Compute the band gap                      :  True                         |' else write ( stdout , '(1x,a78)' ) '|  Compute the band gap                      :  False                        |' end if if ( photo ) then write ( stdout , '(1x,a19,26x,a2,f7.4,3x,21a)' ) '|  JDOS bin spacing' , ': ' , jdos_spacing , 'eV                  |' write ( stdout , '(1x,a22,23x,a2,f7.4,3x,21a)' ) '|  JDOS max energy bin' , ': ' , jdos_max_energy , 'eV                  |' end if if ( optics . or . photo ) then write ( stdout , '(1x,a78)' ) '+-------------------------------- OPTICS ------------------------------------+' if ( index ( optics_geom , 'polycrys' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Polycrystalline              |' elseif ( index ( optics_geom , 'unpolar' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Unpolarised                  |' write ( stdout , '(1x,a47,2x,f6.2,2x,f6.2,2x,f6.2,3x,a4)' ) '|  Direction of q-vector (un-normalised)     : ' & , optics_qdir ( 1 : 3 ), '   |' elseif ( index ( optics_geom , 'polar' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Polarised                    |' write ( stdout , '(1x,a47,2x,f6.2,2x,f6.2,2x,f6.2,3x,a4)' ) '|  Direction of q-vector (un-normalised)     : ' & , optics_qdir ( 1 : 3 ), '   |' elseif ( index ( optics_geom , 'tensor' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Optics Calculation           :  Full dielectric tensor       |' end if if ( optics_intraband ) then write ( stdout , '(1x,a78)' ) '|  Include Intraband Contribution            :  True                         |' write ( stdout , '(1x,a46,1x,1E10.3,20x,a1)' ) '|  Drude Broadening                          :' ,& & optics_drude_broadening , '|' else write ( stdout , '(1x,a78)' ) '|  Include Intraband Contribution            :  False                        |' end if if ( optics_lossfn_broadening ) then write ( stdout , '(1x,a78)' ) '|  Include Loss Function Broadening          :  True                         |' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Gaussian Width                            :' , & & optics_lossfn_gaussian , '|' else write ( stdout , '(1x,a78)' ) '|  Include Loss Function Broadening          :  False                        |' end if if ( scissor_op > 1.0e-10_dp ) & write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Scissor Operator (eV)                     :' , scissor_op , '|' end if if ( core ) then write ( stdout , '(1x,a78)' ) '+--------------------------------- CORE -------------------------------------+' if ( index ( core_geom , 'polycrys' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Core Calculation             :  Polycrystalline              |' elseif ( index ( core_geom , 'polar' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Geometry for Core Calculation             :  Polarised                    |' write ( stdout , '(1x,a47,2x,f6.2,2x,f6.2,2x,f6.2,3x,a4)' ) '|  Direction of q-vector (un-normalised)     : ' & , core_qdir ( 1 : 3 ), '   |' end if if ( index ( core_type , 'absorption' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Absorption or Emission Spectrum           :  Absorption                   |' elseif ( index ( core_type , 'emission' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Absorption or Emission Spectrum           :  Emission                     |' else write ( stdout , '(1x,a78)' ) '|  Absorption or Emission Spectrum           :  Both                         |' end if ! Write out if mizoguchi shift is applied if ( core_chemical_shift == - 1.0_dp ) then ! mizoguchi shift not set write ( stdout , '(1x,a78)' ) '|  Core chemical shift                       :  None                         |' else ! It is set write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Core chemical shift                       :' , core_chemical_shift , '|' end if if ( core_LAI_broadening ) then write ( stdout , '(1x,a78)' ) '|  Include lifetime and Instrument Broadening:  True                         |' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Gaussian Width                            :' , LAI_gaussian_width , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Lorentzian Width                          :' , LAI_lorentzian_width , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Lorentzian Scale                          :' , LAI_lorentzian_scale , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Lorentzian Offset                         :' , LAI_lorentzian_offset , '|' else write ( stdout , '(1x,a78)' ) '|  Include lifetime and Instrument Broadening:  False                        |' end if end if ! Added for Photoemission output - F. Mildner, 12/2022 if ( photo ) then write ( stdout , '(1x,a78)' ) '+----------------------- PHOTOEMISSION PARAMETERS ---------------------------+' if ( index ( photo_model , '1step' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Model                       :     1-Step Model              |' write ( stdout , '(1x,a78)' ) '|  Photoemission Final State                 :     Free Electron State       |' elseif ( index ( photo_model , '3step' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Model                       :     3-Step Model              |' write ( stdout , '(1x,a78)' ) '|  Photoemission Final State                 :     Bloch State               |' elseif ( index ( photo_model , 'ds_like_pe' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Photoemission Model                       :     Simplified PE Model       |' end if if ( photo_photon_sweep ) then write ( stdout , '(1x,a46,1x,1f10.4,a4,1f7.4,a10)' ) '|  Photon Energy Sweep                       :' , photo_photon_min ,& & ' -> ' , photo_photon_max , ' eV      |' else write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Photon Energy              (eV)           :' , photo_photon_energy , '|' end if write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Work Function              (eV)           :' , photo_work_function , '|' ! write (stdout, '(1x,a46,1x,1f10.4,20x,a1)') '|  Surface Area               (Ang**2)       :', photo_surface_area, '|' ! write (stdout, '(1x,a46,1x,1f10.4,20x,a1)') '|  Slab Volume                (Ang**3)       :', photo_slab_volume, '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Slab Max Z-Coord.          (Ang)          :' , photo_slab_max , '|' write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Slab Min Z-Coord.          (Ang)          :' , photo_slab_min , '|' if ( index ( photo_layer_choice , 'user' ) > 0 ) then write ( stdout , '(1x,a46,2x,I4,25x,a1)' ) '|  User set maximal # of layers for calc.    :' , photo_max_layer , '|' end if if ( size ( photo_imfp_const , 1 ) . eq . 1 ) then write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  IMFP Constant              (Ang)          :' , photo_imfp_const ( 1 ), '|' else write ( stdout , '(1x,a78)' ) '|  IMFP Constant              (Ang)          : Layer values provided by user |' write ( stdout , '(1x,a78)' ) '|                                              values will be printed later  |' end if write ( stdout , '(1x,a46,4x,E11.4,16x,a1)' ) '|  Approx. Bulk P_escape Cutoff              :' , exp ( - 1 * photo_bulk_cutoff ), '|' if (( photo_elec_field . gt . 1.0E-4_dp ) . or . ( photo_elec_field . lt . 1.0E-25_dp )) then write ( stdout , '(1x,a46,1x,1f10.4,20x,a1)' ) '|  Electric Field Strength    (V/Ang)        :' , photo_elec_field , '|' else write ( stdout , '(1x,a46,1x,E17.9,13x,a1)' ) '|  Electric Field Strength    (V/Ang)        :' , photo_elec_field , '|' end if write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Smearing Temperature       (K)            :' , photo_temperature , '|' write ( stdout , '(1x,a46,5x,a9,17x,a1)' ) '|  Transverse Momentum Scheme                :' , photo_momentum , '|' if ( photo_remove_box_states ) then write ( stdout , '(1x,a78)' ) '|  Identify and remove box states            :     True                      |' end if ! TODO: Edit the output to reflect the changes made to the printing subroutines if ( index ( write_photo_output , 'slab' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Writing Photoemission Matrix Elements     :     Atom Sites                |' write ( stdout , '(1x,a78)' ) '|          to *SEED*_matrix.dat ---------------------------------------------|' elseif ( index ( write_photo_output , 'all' ) > 0 ) then write ( stdout , '(1x,a78)' ) '|  Writing Photoemission Matrix Elements     :     All Elements              |' write ( stdout , '(1x,a78)' ) '|          to *SEED*_matrix.dat ---------------------------------------------|' end if write ( stdout , '(1x,a78)' ) '|  Emission Angle Bounds for writing to *SEED*_binding_energy.dat -----------|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Theta    -lower -          (deg)          :' , photo_theta_lower , '|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Theta    -upper -          (deg)          :' , photo_theta_upper , '|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Phi      -lower -          (deg)          :' , photo_phi_lower , '|' write ( stdout , '(1x,a46,1x,1f8.2,22x,a1)' ) '|  Phi      -upper -          (deg)          :' , photo_phi_upper , '|' end if write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' if ( num_exclude_bands > 0 ) write ( stdout , '(1x,a16,1x,999(1x,I3))' ) 'excluded_bands :' , exclude_bands (:) if ( scan ( devel_flag , \"AEIOUaeiou\" ) > 0 ) write ( stdout , '(1x,a12,1x,a100)' ) 'devel_flag :' , devel_flag write ( stdout , * ) ' ' end subroutine param_write !==================================================================! subroutine param_dealloc !==================================================================! !                                                                  ! ! release memory from allocated parameters                         ! !                                                                  ! !=================================================================== implicit none !    if ( allocated ( ndimwin ) ) then !       ieallocate (  ndimwin, stat=ierr  ) !       if (ierr/=0) call io_error('Error in deallocating ndimwin in param_dealloc') !    end if return end subroutine param_dealloc !=======================================! subroutine param_in_file !=======================================! ! Load the *.win file into a character  ! ! array in_file, ignoring comments and  ! ! blank lines and converting everything ! ! to lowercase characters               ! !=======================================! use od_io , only : io_file_unit , io_error , seedname , options use od_algorithms , only : utility_lowercase implicit none integer :: in_unit , tot_num_lines , ierr , line_counter , loop , in1 , in2 character ( len = maxlen ) :: dummy in_unit = io_file_unit () open ( in_unit , file = trim ( seedname ) // '.odi' , form = 'formatted' , status = 'old' , err = 101 ) num_lines = 0 ; tot_num_lines = 0 do read ( in_unit , '(a)' , iostat = ierr , err = 200 , end = 210 ) dummy dummy = adjustl ( dummy ) tot_num_lines = tot_num_lines + 1 if (. not . dummy ( 1 : 1 ) == '!' . and . . not . dummy ( 1 : 1 ) == '#' ) then if ( len ( trim ( dummy )) > 0 ) num_lines = num_lines + 1 end if end do 101 call io_error ( 'Error: Problem opening input file ' // trim ( seedname ) // '.odi' ) 200 call io_error ( 'Error: Problem reading input file ' // trim ( seedname ) // '.odi' ) 210 continue rewind ( in_unit ) allocate ( in_data ( num_lines ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating in_data in param_in_file' ) line_counter = 0 do loop = 1 , tot_num_lines read ( in_unit , '(a)' , iostat = ierr , err = 200 ) dummy dummy = utility_lowercase ( dummy ) dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '!' . or . dummy ( 1 : 1 ) == '#' ) cycle if ( len ( trim ( dummy )) == 0 ) cycle line_counter = line_counter + 1 in1 = index ( dummy , '!' ) in2 = index ( dummy , '#' ) if ( in1 == 0 . and . in2 == 0 ) in_data ( line_counter ) = dummy if ( in1 == 0 . and . in2 > 0 ) in_data ( line_counter ) = dummy (: in2 - 1 ) if ( in2 == 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: in1 - 1 ) if ( in2 > 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: min ( in1 , in2 ) - 1 ) end do close ( in_unit ) end subroutine param_in_file subroutine param_get_pdos !    call param_get_block_length('projection',found,rows) end subroutine param_get_pdos !===========================================================================! subroutine param_get_keyword ( keyword , found , c_value , l_value , i_value , r_value ) !===========================================================================! !                                                                           ! !             Finds the value of the required keyword.                      ! !                                                                           ! !===========================================================================! use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found character ( * ), optional , intent ( inout ) :: c_value logical , optional , intent ( inout ) :: l_value integer , optional , intent ( inout ) :: i_value real ( kind = dp ), optional , intent ( inout ) :: r_value integer :: kl , in , loop , itmp character ( len = maxlen ) :: dummy kl = len_trim ( keyword ) found = . false . do loop = 1 , num_lines in = index ( in_data ( loop ), trim ( keyword )) if ( in == 0 . or . in > 1 ) cycle itmp = in + len ( trim ( keyword )) if ( in_data ( loop ) ( itmp : itmp ) /= '=' & . and . in_data ( loop ) ( itmp : itmp ) /= ':' & . and . in_data ( loop ) ( itmp : itmp ) /= ' ' ) cycle if ( found ) then call io_error ( 'Error: Found keyword ' // trim ( keyword ) // ' more than once in input file' ) end if found = . true . dummy = in_data ( loop ) ( kl + 1 :) in_data ( loop ) ( 1 : maxlen ) = ' ' dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '=' . or . dummy ( 1 : 1 ) == ':' ) then dummy = dummy ( 2 :) dummy = adjustl ( dummy ) end if end do if ( found ) then if ( present ( c_value )) c_value = dummy if ( present ( l_value )) then if ( index ( dummy , 't' ) > 0 ) then l_value = . true . elseif ( index ( dummy , 'f' ) > 0 ) then l_value = . false . else call io_error ( 'Error: Problem reading logical keyword ' // trim ( keyword )) end if end if if ( present ( i_value )) read ( dummy , * , err = 220 , end = 220 ) i_value if ( present ( r_value )) read ( dummy , * , err = 220 , end = 220 ) r_value end if return 220 call io_error ( 'Error: Problem reading keyword ' // trim ( keyword )) end subroutine param_get_keyword !===========================================================================! subroutine param_get_efermi ( keyword , found , c_value , r_value ) !===========================================================================! !                                                                           ! !             Finds the value of the required keyword.                      ! !                                                                           ! !===========================================================================! use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found character ( * ), intent ( inout ) :: c_value real ( kind = dp ), intent ( inout ) :: r_value integer :: kl , in , loop , itmp character ( len = maxlen ) :: dummy kl = len_trim ( keyword ) found = . false . do loop = 1 , num_lines in = index ( in_data ( loop ), trim ( keyword )) if ( in == 0 . or . in > 1 ) cycle itmp = in + len ( trim ( keyword )) if ( in_data ( loop ) ( itmp : itmp ) /= '=' & . and . in_data ( loop ) ( itmp : itmp ) /= ':' & . and . in_data ( loop ) ( itmp : itmp ) /= ' ' ) cycle if ( found ) then call io_error ( 'Error: Found keyword ' // trim ( keyword ) // ' more than once in input file' ) end if found = . true . dummy = in_data ( loop ) ( kl + 1 :) in_data ( loop ) ( 1 : maxlen ) = ' ' dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '=' . or . dummy ( 1 : 1 ) == ':' ) then dummy = dummy ( 2 :) dummy = adjustl ( dummy ) end if end do if ( found ) then c_value = dummy if ( trim ( c_value ) == 'optados' . or . trim ( c_value ) == 'file' . or . trim ( c_value ) == 'insulator' ) then r_value = - 99 9.0_dp ! ie not set else ! assume it is a number read ( dummy , * , err = 220 , end = 220 ) r_value c_value = 'user' end if end if return 220 call io_error ( 'Error: Problem reading keyword ' // trim ( keyword )) end subroutine param_get_efermi !=========================================================================================! subroutine param_get_keyword_vector ( keyword , found , length , c_value , l_value , i_value , r_value ) !=========================================================================================! !                                                                                         ! !                  Finds the values of the required keyword vector                        ! !                                                                                         ! !=========================================================================================! use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found integer , intent ( in ) :: length character ( * ), optional , intent ( inout ) :: c_value ( length ) logical , optional , intent ( inout ) :: l_value ( length ) integer , optional , intent ( inout ) :: i_value ( length ) real ( kind = dp ), optional , intent ( inout ) :: r_value ( length ) integer :: kl , in , loop , i character ( len = maxlen ) :: dummy kl = len_trim ( keyword ) found = . false . do loop = 1 , num_lines in = index ( in_data ( loop ), trim ( keyword )) if ( in == 0 . or . in > 1 ) cycle if ( found ) then call io_error ( 'Error: Found keyword ' // trim ( keyword ) // ' more than once in input file' ) end if found = . true . dummy = in_data ( loop ) ( kl + 1 :) in_data ( loop ) ( 1 : maxlen ) = ' ' dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '=' . or . dummy ( 1 : 1 ) == ':' ) then dummy = dummy ( 2 :) dummy = adjustl ( dummy ) end if end do if ( found ) then if ( present ( c_value )) read ( dummy , * , err = 230 , end = 230 ) ( c_value ( i ), i = 1 , length ) if ( present ( l_value )) then ! I don't think we need this. Maybe read into a dummy charater ! array and convert each element to logical end if if ( present ( i_value )) read ( dummy , * , err = 230 , end = 230 ) ( i_value ( i ), i = 1 , length ) if ( present ( r_value )) read ( dummy , * , err = 230 , end = 230 ) ( r_value ( i ), i = 1 , length ) end if return 230 call io_error ( 'Error: Problem reading keyword ' // trim ( keyword ) // ' in param_get_keyword_vector' ) end subroutine param_get_keyword_vector !========================================================! subroutine param_get_vector_length ( keyword , found , length ) !======================================================! !                                                      ! !        Returns the length of a keyword vector        ! !                                                      ! !======================================================! use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found integer , intent ( out ) :: length integer :: kl , in , loop , pos character ( len = maxlen ) :: dummy kl = len_trim ( keyword ) found = . false . do loop = 1 , num_lines in = index ( in_data ( loop ), trim ( keyword )) if ( in == 0 . or . in > 1 ) cycle if ( found ) then call io_error ( 'Error: Found keyword ' // trim ( keyword ) // ' more than once in input file' ) end if found = . true . dummy = in_data ( loop ) ( kl + 1 :) dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '=' . or . dummy ( 1 : 1 ) == ':' ) then dummy = dummy ( 2 :) dummy = adjustl ( dummy ) end if end do length = 0 if ( found ) then if ( len_trim ( dummy ) == 0 ) call io_error ( 'Error: keyword ' // trim ( keyword ) // ' is blank' ) length = 1 dummy = adjustl ( dummy ) do pos = index ( dummy , ' ' ) dummy = dummy ( pos + 1 :) dummy = adjustl ( dummy ) if ( len_trim ( dummy ) > 0 ) then length = length + 1 else exit end if end do end if return end subroutine param_get_vector_length !==============================================================================================! subroutine param_get_keyword_block ( keyword , found , rows , columns , c_value , l_value , i_value , r_value ) !==============================================================================================! !                                                                                              ! !                           Finds the values of the required data block                        ! !                                                                                              ! !==============================================================================================! use od_constants , only : bohr2ang use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found integer , intent ( in ) :: rows integer , intent ( in ) :: columns character ( * ), optional , intent ( inout ) :: c_value ( columns , rows ) logical , optional , intent ( inout ) :: l_value ( columns , rows ) integer , optional , intent ( inout ) :: i_value ( columns , rows ) real ( kind = dp ), optional , intent ( inout ) :: r_value ( columns , rows ) integer :: in , ins , ine , loop , i , line_e , line_s , counter , blen logical :: found_e , found_s , lconvert character ( len = maxlen ) :: dummy , end_st , start_st found_s = . false . found_e = . false . start_st = 'begin ' // trim ( keyword ) end_st = 'end ' // trim ( keyword ) do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), 'begin' ) if ( in == 0 . or . in > 1 ) cycle line_s = loop if ( found_s ) then call io_error ( 'Error: Found ' // trim ( start_st ) // ' more than once in input file' ) end if found_s = . true . end do if (. not . found_s ) then found = . false . return end if do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), 'end' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found ' // trim ( end_st ) // ' more than once in input file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found ' // trim ( start_st ) // ' but no ' // trim ( end_st ) // ' in input file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: ' // trim ( end_st ) // ' comes before ' // trim ( start_st ) // ' in input file' ) end if ! number of lines of data in block blen = line_e - line_s - 1 !    if( blen /= rows) then !       if ( index(trim(keyword),'unit_cell_cart').ne.0 ) then !          if ( blen /= rows+1 ) call io_error('Error: Wrong number of lines in block '//trim(keyword)) !       else !          call io_error('Error: Wrong number of lines in block '//trim(keyword)) !       endif !    endif if (( blen . ne . rows ) . and . ( blen . ne . rows + 1 )) & call io_error ( 'Error: Wrong number of lines in block ' // trim ( keyword )) if (( blen . eq . rows + 1 ) . and . ( index ( trim ( keyword ), 'unit_cell_cart' ) . eq . 0 )) & call io_error ( 'Error: Wrong number of lines in block ' // trim ( keyword )) found = . true . lconvert = . false . if ( blen == rows + 1 ) then dummy = in_data ( line_s + 1 ) if ( index ( dummy , 'ang' ) . ne . 0 ) then lconvert = . false . elseif ( index ( dummy , 'bohr' ) . ne . 0 ) then lconvert = . true . else call io_error ( 'Error: Units in block ' // trim ( keyword ) // ' not recognised' ) end if in_data ( line_s ) ( 1 : maxlen ) = ' ' line_s = line_s + 1 end if !    r_value=1.0_dp counter = 0 do loop = line_s + 1 , line_e - 1 dummy = in_data ( loop ) counter = counter + 1 if ( present ( c_value )) read ( dummy , * , err = 240 , end = 240 ) ( c_value ( i , counter ), i = 1 , columns ) if ( present ( l_value )) then ! I don't think we need this. Maybe read into a dummy charater ! array and convert each element to logical end if if ( present ( i_value )) read ( dummy , * , err = 240 , end = 240 ) ( i_value ( i , counter ), i = 1 , columns ) if ( present ( r_value )) read ( dummy , * , err = 240 , end = 240 ) ( r_value ( i , counter ), i = 1 , columns ) end do if ( lconvert ) then if ( present ( r_value )) then r_value = r_value * bohr2ang end if end if in_data ( line_s : line_e ) ( 1 : maxlen ) = ' ' return 240 call io_error ( 'Error: Problem reading block keyword ' // trim ( keyword )) end subroutine param_get_keyword_block !=====================================================! subroutine param_get_block_length ( keyword , found , rows , lunits ) !=====================================================! !                                                     ! !       Finds the length of the data block            ! !                                                     ! !=====================================================! use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found integer , intent ( out ) :: rows logical , optional , intent ( out ) :: lunits integer :: i , in , ins , ine , loop , line_e , line_s logical :: found_e , found_s character ( len = maxlen ) :: end_st , start_st , dummy character ( len = 2 ) :: atsym real ( kind = dp ) :: atpos ( 3 ) found_s = . false . found_e = . false . start_st = 'begin ' // trim ( keyword ) end_st = 'end ' // trim ( keyword ) do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), 'begin' ) if ( in == 0 . or . in > 1 ) cycle line_s = loop if ( found_s ) then call io_error ( 'Error: Found ' // trim ( start_st ) // ' more than once in input file' ) end if found_s = . true . end do if (. not . found_s ) then found = . false . return end if do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), 'end' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found ' // trim ( end_st ) // ' more than once in input file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found ' // trim ( start_st ) // ' but no ' // trim ( end_st ) // ' in input file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: ' // trim ( end_st ) // ' comes before ' // trim ( start_st ) // ' in input file' ) end if rows = line_e - line_s - 1 found = . true . if ( present ( lunits )) then dummy = in_data ( line_s + 1 ) !       write(stdout,*) dummy !       write(stdout,*) trim(dummy) read ( dummy , * , end = 555 ) atsym , ( atpos ( i ), i = 1 , 3 ) lunits = . false . end if if ( rows <= 0 ) then !cope with empty blocks found = . false . in_data ( line_s : line_e ) ( 1 : maxlen ) = ' ' end if return 555 lunits = . true . if ( rows <= 1 ) then !cope with empty blocks found = . false . in_data ( line_s : line_e ) ( 1 : maxlen ) = ' ' end if return end subroutine param_get_block_length !====================================================================! subroutine param_get_range_vector ( keyword , found , length , lcount , i_value ) !====================================================================! !   Read a range vector eg. 1,2,3,4-10  or 1 3 400:100               ! !   if(lcount) we return the number of states in length              ! !====================================================================! use od_io , only : io_error implicit none character ( * ), intent ( in ) :: keyword logical , intent ( out ) :: found integer , intent ( inout ) :: length logical , intent ( in ) :: lcount integer , optional , intent ( out ) :: i_value ( length ) integer :: kl , in , loop , num1 , num2 , i_punc integer :: counter , i_digit , loop_r , range_size character ( len = maxlen ) :: dummy character ( len = 10 ), parameter :: c_digit = \"0123456789\" character ( len = 2 ), parameter :: c_range = \"-:\" character ( len = 3 ), parameter :: c_sep = \" ,;\" character ( len = 5 ), parameter :: c_punc = \" ,;-:\" character ( len = 5 ) :: c_num1 , c_num2 if ( lcount . and . present ( i_value )) call io_error ( 'param_get_range_vector: incorrect call' ) kl = len_trim ( keyword ) found = . false . do loop = 1 , num_lines in = index ( in_data ( loop ), trim ( keyword )) if ( in == 0 . or . in > 1 ) cycle if ( found ) then call io_error ( 'Error: Found keyword ' // trim ( keyword ) // ' more than once in input file' ) end if found = . true . dummy = in_data ( loop ) ( kl + 1 :) dummy = adjustl ( dummy ) if (. not . lcount ) in_data ( loop ) ( 1 : maxlen ) = ' ' if ( dummy ( 1 : 1 ) == '=' . or . dummy ( 1 : 1 ) == ':' ) then dummy = dummy ( 2 :) dummy = adjustl ( dummy ) end if end do if (. not . found ) return counter = 0 if ( len_trim ( dummy ) == 0 ) call io_error ( 'Error: keyword ' // trim ( keyword ) // ' is blank' ) dummy = adjustl ( dummy ) do i_punc = scan ( dummy , c_punc ) if ( i_punc == 0 ) call io_error ( 'Error parsing keyword ' // trim ( keyword )) c_num1 = dummy ( 1 : i_punc - 1 ) read ( c_num1 , * , err = 101 , end = 101 ) num1 dummy = adjustl ( dummy ( i_punc :)) !look for range if ( scan ( dummy , c_range ) == 1 ) then i_digit = scan ( dummy , c_digit ) dummy = adjustl ( dummy ( i_digit :)) i_punc = scan ( dummy , c_punc ) c_num2 = dummy ( 1 : i_punc - 1 ) read ( c_num2 , * , err = 101 , end = 101 ) num2 dummy = adjustl ( dummy ( i_punc :)) range_size = abs ( num2 - num1 ) + 1 do loop_r = 1 , range_size counter = counter + 1 if (. not . lcount ) i_value ( counter ) = min ( num1 , num2 ) + loop_r - 1 end do else counter = counter + 1 if (. not . lcount ) i_value ( counter ) = num1 end if if ( scan ( dummy , c_sep ) == 1 ) dummy = adjustl ( dummy ( 2 :)) if ( scan ( dummy , c_range ) == 1 ) call io_error ( 'Error parsing keyword ' // trim ( keyword ) // ' incorrect range' ) if ( index ( dummy , ' ' ) == 1 ) exit end do if ( lcount ) length = counter if (. not . lcount ) then do loop = 1 , counter - 1 do loop_r = loop + 1 , counter if ( i_value ( loop ) == i_value ( loop_r )) & call io_error ( 'Error parsing keyword ' // trim ( keyword ) // ' duplicate values' ) end do end do end if return 101 call io_error ( 'Error parsing keyword ' // trim ( keyword )) end subroutine param_get_range_vector subroutine param_dist !----------------------------------------------------- ! Send the parameters from the root node to all others !----------------------------------------------------- use od_comms , only : comms_bcast , on_root use od_io , only : io_error implicit none integer :: ierr call comms_bcast ( output_format , len ( output_format )) call comms_bcast ( devel_flag , len ( devel_flag )) call comms_bcast ( iprint , 1 ) call comms_bcast ( energy_unit , len ( energy_unit )) call comms_bcast ( length_unit , len ( length_unit )) call comms_bcast ( dos , 1 ) call comms_bcast ( pdos , 1 ) call comms_bcast ( jdos , 1 ) call comms_bcast ( optics , 1 ) call comms_bcast ( photo , 1 ) call comms_bcast ( photo_photon_sweep , 1 ) call comms_bcast ( core , 1 ) call comms_bcast ( compare_dos , 1 ) call comms_bcast ( compare_jdos , 1 ) call comms_bcast ( fixed , 1 ) call comms_bcast ( adaptive , 1 ) call comms_bcast ( linear , 1 ) call comms_bcast ( quad , 1 ) call comms_bcast ( dos_nbins , 1 ) call comms_bcast ( compute_band_energy , 1 ) call comms_bcast ( compute_band_gap , 1 ) call comms_bcast ( adaptive_smearing , 1 ) call comms_bcast ( fixed_smearing , 1 ) call comms_bcast ( linear_smearing , 1 ) call comms_bcast ( hybrid_linear , 1 ) call comms_bcast ( hybrid_linear_grad_tol , 1 ) call comms_bcast ( dos_per_volume , 1 ) call comms_bcast ( efermi_user , 1 ) call comms_bcast ( efermi_choice , len ( efermi_choice )) call comms_bcast ( finite_bin_correction , 1 ) call comms_bcast ( numerical_intdos , 1 ) call comms_bcast ( jdos_max_energy , 1 ) call comms_bcast ( jdos_spacing , 1 ) call comms_bcast ( scissor_op , 1 ) call comms_bcast ( optics_geom , len ( optics_geom )) call comms_bcast ( optics_qdir ( 1 ), 3 ) call comms_bcast ( optics_intraband , 1 ) call comms_bcast ( optics_drude_broadening , 1 ) call comms_bcast ( core_chemical_shift , 1 ) call comms_bcast ( core_geom , len ( core_geom )) call comms_bcast ( core_type , len ( core_type )) call comms_bcast ( core_qdir ( 1 ), 3 ) call comms_bcast ( core_LAI_broadening , 1 ) call comms_bcast ( LAI_gaussian_width , 1 ) call comms_bcast ( LAI_gaussian , 1 ) call comms_bcast ( LAI_lorentzian_width , 1 ) call comms_bcast ( LAI_lorentzian_scale , 1 ) call comms_bcast ( LAI_lorentzian_offset , 1 ) call comms_bcast ( LAI_lorentzian , 1 ) call comms_bcast ( dos_per_volume , 1 ) call comms_bcast ( dos_min_energy , 1 ) call comms_bcast ( dos_max_energy , 1 ) call comms_bcast ( dos_spacing , 1 ) call comms_bcast ( legacy_file_format , 1 ) call comms_bcast ( projectors_string , len ( projectors_string )) call comms_bcast ( set_efermi_zero , 1 ) ! ! Photoemission ! TODO: Broadcast the rest of the photoemission parameters!! call comms_bcast ( photo_model , len ( photo_model )) call comms_bcast ( photo_momentum , len ( photo_momentum )) call comms_bcast ( photo_photon_energy , 1 ) if ( photo_photon_sweep ) then call comms_bcast ( photo_photon_min , 1 ) call comms_bcast ( photo_photon_max , 1 ) end if call comms_bcast ( photo_work_function , 1 ) ! call comms_bcast(photo_surface_area, 1) ! call comms_bcast(photo_slab_volume, 1) call comms_bcast ( photo_slab_max , 1 ) call comms_bcast ( photo_slab_min , 1 ) call comms_bcast ( photo_layer_choice , len ( photo_layer_choice )) call comms_bcast ( photo_max_layer , 1 ) call comms_bcast ( photo_elec_field , 1 ) call comms_bcast ( photo_remove_box_states , 1 ) call comms_bcast ( photo_len_imfp_const , 1 ) if (. not . on_root ) then allocate ( photo_imfp_const ( photo_len_imfp_const ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: param_dist - allocation failed for photo_imfp_const' ) end if call comms_bcast ( photo_imfp_const ( 1 ), photo_len_imfp_const ) call comms_bcast ( photo_bulk_cutoff , 1 ) call comms_bcast ( photo_temperature , 1 ) call comms_bcast ( write_photo_output , len ( write_photo_output )) call comms_bcast ( photo_theta_lower , 1 ) call comms_bcast ( photo_theta_upper , 1 ) call comms_bcast ( photo_phi_lower , 1 ) call comms_bcast ( photo_phi_upper , 1 ) call comms_bcast ( num_exclude_bands , 1 ) if ( num_exclude_bands > 1 ) then if (. not . on_root ) then allocate ( exclude_bands ( num_exclude_bands ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating exclude_bands in param_read' ) end if call comms_bcast ( exclude_bands ( 1 ), num_exclude_bands ) end if end subroutine param_dist end module od_parameters","tags":"","loc":"sourcefile/parameters.f90.html"},{"title":"build.f90 – OptaDOS","text":"Files dependent on this one sourcefile~~build.f90~~AfferentGraph sourcefile~build.f90 build.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~build.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_build Source Code build.f90 Source Code module od_build implicit none private ! unless otherwise stated type , public :: build_info_type character ( len = 20 ) :: build = '' character ( len = 20 ) :: compiler = 'gfortran' character ( len = 20 ) :: build_type = 'debug' character ( len = 20 ) :: comms_arch = 'serial' character ( len = 20 ) :: source_time = '16:47:50' character ( len = 20 ) :: source_date = 'Mon 28 Aug 2023' character ( len = 20 ) :: compile_date = 'Mon 28 Aug 2023' character ( len = 20 ) :: compile_time = '16:49 BST' end type build_info_type type ( build_info_type ), public , save :: build_info endmodule od_build","tags":"","loc":"sourcefile/build.f90.html"},{"title":"od2od.f90 – OptaDOS","text":"This file depends on sourcefile~~od2od.f90~~EfferentGraph sourcefile~od2od.f90 od2od.f90 sourcefile~constants.f90 constants.f90 sourcefile~od2od.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~io.f90 io.f90 sourcefile~od2od.f90->sourcefile~io.f90 sourcefile~cell.f90 cell.f90 sourcefile~od2od.f90->sourcefile~cell.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~comms.f90 comms.F90 sourcefile~od2od.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs od2od Modules od_conv Source Code od2od.f90 Source Code !-*- mode: F90 -*-! module od_conv !! Helper module for od2od used for file conversions. use od_constants , only : dp use od_electronic , only : elec_read_optical_mat , elec_read_band_gradient , elec_read_elnes_mat ,& & elec_pdos_read , elec_read_band_energy , omefile_header , domefile_header , pdosfile_header ,& & elnesfile_header , elec_read_foptical_mat , femfile_header use od_parameters , only : iprint use od_io , only : stdout , io_error , seedname implicit none character ( len = 80 ), save :: outseedname !! It's conceivable that you might not !!  want to write over what you already have. character ( len = 80 ), save :: infile !! Type of file to convert from. character ( len = 80 ), save :: outfile !! Type of file to convert to. character ( len = 10 ), save :: format_precision = \"es23.10\" !! Things get messy below 10 s.f. between bin files and fmt files contains !========================================================================= subroutine print_usage () !! Writes the usage of the program to stdout write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" OptaDOS od2od \" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" Usage: od2od -i/--in_file <in_type> -o/--out_file <out_type> -w/--out_seedname [seedout] [seedname] \" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" [seedname] and [seedout] are optional input and output seednames\" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" <in_type> and <out_type> is one of: \" write ( stdout , '(A)' ) \"       ome_fmt : a formatted optical matrix element file\" write ( stdout , '(A)' ) \"       ome_bin : an unformatted optical matrix element file\" ! Added by F. Mildner (04/2023) for photoemission write ( stdout , '(A)' ) \"       fem_fmt : a formatted free electron optical matrix element file\" write ( stdout , '(A)' ) \"       fem_bin : an unformatted free electron optical matrix element file\" write ( stdout , '(A)' ) \"      dome_fmt : a formatted diagonal optical matrix element file\" write ( stdout , '(A)' ) \"      dome_bin : an unformatted diagonal optical matrix element file\" write ( stdout , '(A)' ) \"      pdos_fmt : a formatted projected density of states file\" write ( stdout , '(A)' ) \"      pdos_bin : an unformatted projected density of states file\" write ( stdout , '(A)' ) \"     elnes_fmt : an formatted ELNES file\" write ( stdout , '(A)' ) \"     elnes_bin : an unformatted ELNES file\" write ( stdout , '(A)' ) \"         dummy : no input or output file (for testing)\" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" Known issues: (1) a seedname.bands file also needs to be present until\" write ( stdout , '(A)' ) \"    I've thought of a better way to do it.\" write ( stdout , '(A)' ) \"      (3) It only works in serial.\" write ( stdout , '(A)' ) \"      (4) It only decides if the output format is sane after it's\" write ( stdout , '(A)' ) \"     read the input.\" write ( stdout , '(A)' ) \"      (5) I need to think more about the amount of precision in in a formatted\" write ( stdout , '(A)' ) \"     out file.\" write ( stdout , '(A)' ) \"      (6) File versions and headers could be better stored and reproduced.\" write ( stdout , '(A)' ) write ( stdout , '(A)' ) \" Features: (1) Ability to convert a ome into a dome.\" write ( stdout , '(A)' ) end subroutine print_usage !========================================================================= subroutine conv_get_seedname !! Set the seedname from the command line use od_io , only : seedname implicit none integer :: num_arg integer :: i !! Temporary variable character ( len = 50 ) :: ctemp num_arg = command_argument_count () outseedname = 'optados' seedname = 'optados' !! set to optados until proven otherwise i = 1 do while ( i . le . num_arg ) call get_command_argument ( i , ctemp ) select case ( trim ( ctemp )) case ( \"-i\" , \"--in_file\" ) i = i + 1 call get_command_argument ( i , infile ) case ( \"-o\" , \"--out_file\" ) i = i + 1 call get_command_argument ( i , outfile ) case ( \"-w\" , \"--out_seedname\" ) i = i + 1 call get_command_argument ( i , outseedname ) case ( \"--\" ) !! End of flags i = i + 1 call get_command_argument ( i , seedname ) case default if ( seedname == 'optados' ) then seedname = trim ( ctemp ) i = i + 1 else !! We've already set the seedname so it can't be that again! call print_usage call io_error ( 'Wrong command line arguments, see logfile for usage' ) end if end select i = i + 1 end do if ( outseedname == 'optados' ) then outseedname = seedname end if end subroutine conv_get_seedname !========================================================================= ! O P T I C A L   M A T R I X   E L E M E N T S !========================================================================= !========================================================================= subroutine read_ome_fmt () !! Read a formatted Optical Matrix Elements file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , optical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string , string2 integer :: ik , is , ib , i , jb , ome_unit = 6 write ( stdout , * ) \" Read a formatted ome file. \" if (. not . allocated ( optical_mat )) then write ( stdout , * ) \" Allocating optical_mat.\" allocate ( optical_mat ( nbands , nbands , 3 , nkpoints , nspins )) end if open ( unit = ome_unit , form = 'formatted' , recl = 1073741824 , file = trim ( seedname ) // \".ome_fmt\" ) ! Total number of elements of ome write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * nbands * nbands , trim ( format_precision ) ! write(stdout,*) string ! write(string,'(a)') trim(format_precision) read ( ome_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( ome_unit , '(a80)' ) omefile_header ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins read ( ome_unit , '(' // trim ( string ) // ')' ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), & & jb = 1 , nbands ), i = 1 , 3 ) end do end do optical_mat = optical_mat * ( bohr2ang * H2eV ) close ( unit = ome_unit ) write ( stdout , * ) trim ( seedname ) // \".ome_fmt\" // \"--> Formatted ome sucessfully read. \" end subroutine read_ome_fmt !========================================================================= subroutine write_ome_fmt () !! Write a formatted ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , optical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , ome_unit = 6 write ( stdout , * ) \" Write a formatted ome file. \" optical_mat = optical_mat / ( bohr2ang * H2eV ) open ( unit = ome_unit , form = 'formatted' , file = trim ( outseedname ) // \".ome_fmt\" ) write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * nbands * nbands , trim ( format_precision ) !   write(stdout,*) string write ( stdout , '(a80)' ) omefile_header write ( stdout , '(a80)' ) adjustl ( omefile_header ) write ( ome_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( ome_unit , '(a80)' ) adjustl ( omefile_header ) do ik = 1 , nkpoints do is = 1 , nspins write ( ome_unit , '(' // trim ( string ) // ')' ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), & & jb = 1 , nbands ), i = 1 , 3 ) end do end do close ( unit = ome_unit ) write ( stdout , * ) \" Sucesfully written a formatted ome file --> \" // trim ( outseedname ) // \".ome_fmt\" end subroutine write_ome_fmt !========================================================================= subroutine read_ome_bin () !! Read a binary ome file. Wrapper to keep the naming tidy. implicit none write ( stdout , * ) \" Read a formatted ome file. \" call elec_read_optical_mat () write ( stdout , * ) \" \" // trim ( seedname ) // \".ome_bin\" // \"--> Unformatted ome sucessfully read. \" end subroutine read_ome_bin !========================================================================= subroutine write_ome_bin () !! Write a binary ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , optical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , ome_unit = 6 write ( stdout , * ) \" Write a binary ome file.\" optical_mat = optical_mat / ( bohr2ang * H2eV ) open ( unit = ome_unit , form = 'unformatted' , file = trim ( outseedname ) // \".ome_bin\" ) write ( stdout , * ) \"-> Omefile_version \" , file_version write ( ome_unit ) file_version write ( stdout , * ) \"-> Omefile_header \" , trim ( omefile_header ) write ( ome_unit ) adjustl ( omefile_header ) ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins write ( ome_unit ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), & & jb = 1 , nbands ), i = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written an unformatted ome file --> \" // trim ( outseedname ) // \".ome_bin\" end subroutine write_ome_bin !========================================================================= ! F R E E   E L E C T R O N   O P T I C A L   M A T R I X   E L E M E N T S !========================================================================= !========================================================================= subroutine read_fem_fmt () !! Read a formatted Optical Matrix Elements file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , foptical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string , string2 integer :: ik , is , ib , i , jb , fem_unit = 6 write ( stdout , * ) \" Read a formatted .fem file. \" if (. not . allocated ( foptical_mat )) then write ( stdout , * ) \" Allocating foptical_mat.\" allocate ( foptical_mat ( nbands + 1 , nbands + 1 , 3 , nkpoints , nspins )) end if open ( unit = fem_unit , form = 'formatted' , recl = 1073741824 , file = trim ( seedname ) // \".fem_fmt\" ) ! Total number of elements of ome write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * ( nbands + 1 ) * ( nbands + 1 ), trim ( format_precision ) ! write(stdout,*) string ! write(string,'(a)') trim(format_precision) read ( fem_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( fem_unit , '(a80)' ) omefile_header ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins read ( fem_unit , '(' // trim ( string ) // ')' ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), & & jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do foptical_mat = foptical_mat * ( bohr2ang * H2eV ) close ( unit = fem_unit ) write ( stdout , * ) trim ( seedname ) // \".fem_fmt\" // \"--> Formatted fem sucessfully read. \" end subroutine read_fem_fmt !========================================================================= subroutine write_fem_fmt () !! Write a formatted ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , foptical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , fem_unit = 6 write ( stdout , * ) \" Write a formatted .fem file. \" foptical_mat = foptical_mat / ( bohr2ang * H2eV ) open ( unit = fem_unit , form = 'formatted' , file = trim ( outseedname ) // \".fem_fmt\" ) write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * ( nbands + 1 ) * ( nbands + 1 ), trim ( format_precision ) !   write(stdout,*) string write ( stdout , '(a80)' ) femfile_header write ( stdout , '(a80)' ) adjustl ( femfile_header ) write ( fem_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( fem_unit , '(a80)' ) adjustl ( femfile_header ) do ik = 1 , nkpoints do is = 1 , nspins write ( fem_unit , '(' // trim ( string ) // ')' ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), & & jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do close ( unit = fem_unit ) write ( stdout , * ) \" Sucesfully written a formatted fem file --> \" // trim ( outseedname ) // \".fem_fmt\" end subroutine write_fem_fmt !========================================================================= subroutine read_fem_bin () !! Read a binary ome file. Wrapper to keep the naming tidy. implicit none write ( stdout , * ) \" Read a formatted ome file. \" call elec_read_foptical_mat () write ( stdout , * ) \" \" // trim ( seedname ) // \".fem_bin\" // \"--> Unformatted ome sucessfully read. \" end subroutine read_fem_bin !========================================================================= subroutine write_fem_bin () !! Write a binary ome file. use od_constants , only : dp , bohr2ang , H2eV use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , foptical_mat use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , fem_unit = 6 write ( stdout , * ) \" Write a binary fem file.\" foptical_mat = foptical_mat / ( bohr2ang * H2eV ) open ( unit = fem_unit , form = 'unformatted' , file = trim ( outseedname ) // \".fem_bin\" ) write ( stdout , * ) \"-> Femfile_version \" , file_version write ( fem_unit ) file_version write ( stdout , * ) \"-> Femfile_header \" , trim ( femfile_header ) write ( fem_unit ) adjustl ( femfile_header ) ! write(0,*) nkpoints, nspins, nbands do ik = 1 , nkpoints do is = 1 , nspins write ( fem_unit ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), & & jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written an unformatted fem file --> \" // trim ( outseedname ) // \".fem_bin\" end subroutine write_fem_bin !========================================================================= ! D I A G O N A L  O P T I C A L   M A T R I X   E L E M E N T S !========================================================================= !========================================================================= subroutine read_dome_fmt () !! Read a diagonal ome formatted file. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , dome_unit = 6 write ( stdout , * ) \" Read a formatted dome file. \" if (. not . allocated ( band_gradient )) then write ( stdout , * ) \" Allocating band_gradient\" allocate ( band_gradient ( nbands , 3 , nkpoints , nspins )) end if open ( unit = dome_unit , form = 'formatted' , file = trim ( seedname ) // \".dome_fmt\" ) write ( string , '(i0,\"(1x,\",a,\")\")' ) 3 * nbands , trim ( format_precision ) read ( dome_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( dome_unit , '(a80)' ) domefile_header do ik = 1 , nkpoints do is = 1 , nspins read ( dome_unit , '(' // trim ( string ) // ')' ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), & & i = 1 , 3 ) end do end do band_gradient = band_gradient * ( bohr2ang * H2eV ) close ( unit = dome_unit ) write ( stdout , * ) \" \" // trim ( seedname ) // \".dome_fmt\" // \"--> Formatted ome sucessfully read. \" end subroutine read_dome_fmt !========================================================================= subroutine write_dome_fmt () !! Write a diagonal ome formatted file. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version character ( len = 100 ) :: string integer :: ik , is , ib , i , jb , dome_unit = 6 write ( stdout , * ) \" Write a formatted ome file.\" open ( unit = dome_unit , form = 'formatted' , file = trim ( outseedname ) // \".dome_fmt\" ) write ( string , '(I0,\"(1x,\",a,\")\")' ) 3 * nbands , trim ( format_precision ) write ( dome_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( dome_unit , '(a80)' ) adjustl ( domefile_header ) band_gradient = band_gradient / ( bohr2ang * H2eV ) do ik = 1 , nkpoints do is = 1 , nspins write ( dome_unit , '(' // trim ( string ) // ')' ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), & i = 1 , 3 ) end do end do close ( unit = dome_unit ) write ( stdout , * ) \" Sucesfully written a formatted dome file --> \" // trim ( outseedname ) // \".dome_fmt\" end subroutine write_dome_fmt !========================================================================= subroutine read_dome_bin () !! Read a diagonal ome file. Wrapper to keep the naming scheme tidy. implicit none write ( stdout , * ) \" Read a binary dome file.\" call elec_read_band_gradient () end subroutine read_dome_bin !========================================================================= subroutine write_dome_bin () !! Write a diagonal ome file. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient use od_constants , only : bohr2ang , H2eV implicit none real ( dp ) :: file_version = 1.0_dp ! File version integer :: ik , is , ib , i , jb , dome_unit = 6 write ( stdout , * ) \" Write a binary dome file.\" open ( unit = dome_unit , form = 'unformatted' , file = trim ( outseedname ) // \".dome_bin\" ) band_gradient = band_gradient / ( bohr2ang * H2eV ) write ( dome_unit ) file_version write ( dome_unit ) adjustl ( domefile_header ) do ik = 1 , nkpoints do is = 1 , nspins write ( dome_unit ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), & & i = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written a binary dome file --> \" // trim ( outseedname ) // \".dome_bin\" end subroutine write_dome_bin !========================================================================= ! P R O J E C T E D   D O S !========================================================================= !========================================================================= subroutine write_pdos_fmt () !! Write a formatted pdos file. use od_electronic , only : pdos_mwab , nbands_occ , pdos_orbital , nspins , pdos_weights use od_cell , only : nkpoints , kpoint_r use od_io , only : stdout , seedname , io_file_unit implicit none integer :: ik , is , ib integer :: pdos_in_unit character ( len = 80 ) :: string , string2 real ( dp ) :: file_version = 1.0_dp write ( stdout , * ) \" Write a formatted pdos file.\" !-------------------------------------------------------------------------! ! W R I T E   T H E   D A T A   H E A D E R pdos_in_unit = io_file_unit () open ( unit = pdos_in_unit , file = trim ( outseedname ) // \".pdos_fmt\" , form = 'formatted' ) write ( pdos_in_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( pdos_in_unit , '(a80)' ) adjustl ( pdosfile_header ) write ( pdos_in_unit , '(a10, i6)' ) \"Kpoints\" , pdos_mwab % nkpoints write ( pdos_in_unit , '(a10, i6)' ) \"Spins\" , pdos_mwab % nspins write ( pdos_in_unit , '(a10, i6)' ) \"Orbials\" , pdos_mwab % norbitals write ( pdos_in_unit , '(a10, i6)' ) \"Bands\" , pdos_mwab % nbands !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%nkpoints= \",pdos_mwab%nkpoints !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%nspins= \",pdos_mwab%nspins !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%norbitals= \",pdos_mwab%norbitals !write(stdout,'(a30,i6)') \"DEBUG: pdos_mwab%nbands= \",pdos_mwab%nbands ! These should all be allocated! !allocate(pdos_orbital%species_no(pdos_mwab%norbitals),stat=ierr) !if(ierr/=0) call io_error(\" Error : cannot allocate pdos_orbital\") !allocate(pdos_orbital%rank_in_species(pdos_mwab%norbitals),stat=ierr) !if(ierr/=0) call io_error(\" Error : cannot allocate pdos_orbital\") !allocate(pdos_orbital%am_channel(pdos_mwab%norbitals),stat=ierr) !if(ierr/=0) call io_error(\" Error : cannot allocate pdos_orbital\") write ( string , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , trim ( format_precision ) write ( pdos_in_unit , '(a60)' ) \" Species number for each orbital\" write ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) write ( pdos_in_unit , '(a60)' ) \" Species rank for each orbital\" write ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) write ( pdos_in_unit , '(a60)' ) \" AM channel for each orbital\" write ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A ! These should already be alloacted ! allocate(nbands_occ(1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate nbands_occ\" ! allocate(pdos_weights(1:pdos_mwab%norbitals,1:pdos_mwab%nbands, & !     1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate pdos_weights\" do ik = 1 , nkpoints ! The kpoint number, followed by the kpoint-vector write ( pdos_in_unit , '(i6,3' // trim ( format_precision ) // ')' ) ik , kpoint_r (:, ik ) do is = 1 , pdos_mwab % nspins write ( pdos_in_unit , '(i6)' ) is ! this is the spin number write ( pdos_in_unit , '(i6)' ) nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) !      write(stdout,*) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" !      write(stdout,*) \" DEBUG:\", ib, ik, is !      write(stdout,*) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" write ( pdos_in_unit , '(' // trim ( string2 ) // ')' ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) end do end do end do close ( pdos_in_unit ) write ( stdout , * ) \" Sucesfully written a formtted pdos file --> \" // trim ( outseedname ) // \".dome_bin\" end subroutine write_pdos_fmt !========================================================================= subroutine read_pdos_fmt () !! Read a formatted pdos file. use od_electronic , only : pdos_mwab , nbands_occ , pdos_orbital , nspins , pdos_weights use od_cell , only : nkpoints , kpoint_r , num_kpoints_on_node use od_io , only : stdout , seedname , io_file_unit use od_comms , only : my_node_id implicit none integer :: ik , is , ib , idummy , ierr , io integer :: pdos_in_unit character ( len = 80 ) :: string , dummy , string2 real ( dp ) :: file_version write ( stdout , * ) \" Read a formatted pdos file.\" !-------------------------------------------------------------------------! ! R E A D   T H E   D A T A   H E A D E R file_version = 1.0_dp pdos_in_unit = io_file_unit () open ( unit = pdos_in_unit , file = trim ( seedname ) // \".pdos_fmt\" , form = 'formatted' ) read ( pdos_in_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( pdos_in_unit , '(a80)' ) pdosfile_header read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % nkpoints read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % nspins read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % norbitals read ( pdos_in_unit , '(a10, i6)' ) dummy , pdos_mwab % nbands !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%nkpoints= \",pdos_mwab%nkpoints !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%nspins= \",pdos_mwab%nspins !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%norbitals= \",pdos_mwab%norbitals !write(stdout,'(a, i6)') \"DEBUG: pdos_mwab%nbands= \",pdos_mwab%nbands write ( string , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) pdos_mwab % norbitals , trim ( format_precision ) ! These should all be allocated! allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( nbands_occ ( 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate nbands_occ\" allocate ( pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate pdos_weights\" read ( pdos_in_unit , '(a60)' ) dummy read ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit , '(a60)' ) dummy read ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit , '(a60)' ) dummy read ( pdos_in_unit , '(' // trim ( string ) // ')' ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A ! These should already be alloacted ! allocate(nbands_occ(1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate nbands_occ\" ! allocate(pdos_weights(1:pdos_mwab%norbitals,1:pdos_mwab%nbands, & !     1:num_kpoints_on_node(my_node_id),1:pdos_mwab%nspins),stat=ierr) ! if(ierr/=0) stop \" Error : cannot allocate pdos_weights\" do ik = 1 , nkpoints ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit , '(i6,3' // trim ( format_precision ) // ')' ) idummy , kpoint_r (:, ik ) do is = 1 , pdos_mwab % nspins read ( pdos_in_unit , '(i6)' ) idummy ! this is the spin number read ( pdos_in_unit , '(i6)' ) nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) !      write(stdout,*) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" !      write(stdout,*) \" DEBUG:\", ib, ik, is !      write(stdout,*) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" read ( pdos_in_unit , '(' // trim ( string2 ) // ')' ) ( pdos_weights ( io , ib , ik , is ), io = 1 , pdos_mwab % norbitals ) end do end do end do close ( pdos_in_unit ) write ( stdout , * ) \" \" // trim ( seedname ) // \".pdos_fmt\" // \"--> Formatted pdos sucessfully read. \" end subroutine read_pdos_fmt !========================================================================= subroutine read_pdos_bin () !! Wrapper to read a pdos binary file. Useful to keep the code tidy. implicit none write ( stdout , * ) \" Read a binary pdos file.\" call elec_pdos_read () end subroutine read_pdos_bin !========================================================================= subroutine write_pdos_bin () !! Write a binary pdos file use od_constants , only : dp use od_electronic , only : pdos_mwab , nbands_occ , pdos_orbital , nspins , pdos_weights use od_cell , only : nkpoints , kpoint_r use od_io , only : io_file_unit implicit none !  integer,parameter:: num_popn_orb=1          ! Number of LCAO projectors ! integer,parameter:: max_eigenv=1       ! Number of bands included in matrix elements real ( dp ) :: file_version = 1.0_dp ! File version ! integer:: species(1:num_popn_orb)! Atomic species associated with each projector ! integer:: ion(1:num_popn_orb)    ! Ion associated with each projector ! integer:: am_channel(1:num_popn_orb)     ! Angular momentum channel ! integer:: num_eigenvalues(1:nspins)   ! Number of eigenvalues per spin channel ! real(dp):: kpoint_positions(1:nkpoints,1:3) ! k_x, k_y, k_z in fractions of BZ ! real(dp):: pdos_weights(1:num_popn_orb,max_eigenv,num_kpoints,num_spins)!Matrix elements !character(len=80):: file_header ! File header comment integer :: ik , is , ib , pdos_file , io , idex pdos_file = io_file_unit () open ( unit = pdos_file , file = trim ( outseedname ) // \".pdos_bin\" , form = 'unformatted' ) write ( stdout , * ) \" Write a binary pdos file.\" write ( pdos_file ) file_version write ( pdos_file ) adjustl ( pdosfile_header ) write ( pdos_file ) pdos_mwab % nkpoints write ( pdos_file ) pdos_mwab % nspins write ( pdos_file ) pdos_mwab % norbitals write ( pdos_file ) pdos_mwab % nbands write ( pdos_file ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) write ( pdos_file ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) write ( pdos_file ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) write ( stdout , * ) pdos_mwab % nkpoints write ( stdout , * ) pdos_mwab % nspins write ( stdout , * ) pdos_mwab % norbitals write ( stdout , * ) pdos_mwab % nbands write ( stdout , * ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) write ( stdout , * ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) write ( stdout , * ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) do ik = 1 , pdos_mwab % nkpoints write ( stdout , * ) \"loop\" , ik write ( pdos_file ) ik , ( kpoint_r ( idex , ik ), idex = 1 , 3 ) do is = 1 , pdos_mwab % nspins write ( pdos_file ) is write ( pdos_file ) nbands_occ ( ik , is ) write ( stdout , * ) is , nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) write ( pdos_file ) ( pdos_weights ( io , ib , ik , is ), io = 1 , pdos_mwab % norbitals ) end do end do end do write ( stdout , * ) \" Sucesfully written a binary pdos file --> \" // trim ( outseedname ) // \".pdos_bin\" end subroutine write_pdos_bin !========================================================================= ! E L N E S   M A T R I X   E L E M E N T S !========================================================================= !========================================================================= subroutine read_elnes_fmt () !! Read a formatted elnes file. use od_electronic , only : elec_elnes_find_channel_names , elnes_orbital , & & elnes_mwab , elnes_mat use od_io , only : io_file_unit , seedname use od_cell , only : num_kpoints_on_node implicit none character ( len = 20 ) :: dummy20 , dummy10 real ( dp ) :: file_version !! The file verioson format to write. Currently we're on version 1. integer :: elnes_unit , ik , is , iorb , ib , indx , ierr !! Loop variable. character ( len = 80 ) :: string , string2 !! Tempory string manipulation variable. write ( stdout , * ) \" Read a formatted elnes file.\" elnes_unit = io_file_unit () open ( unit = elnes_unit , file = trim ( seedname ) // \".elnes_fmt\" , form = 'formatted' ) read ( elnes_unit , '(' // trim ( format_precision ) // ')' ) file_version read ( elnes_unit , '(a80)' ) elnesfile_header read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % norbitals read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % nbands read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % nkpoints read ( elnes_unit , '(a20,1x,i5)' ) dummy20 , elnes_mwab % nspins write ( string , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals * elnes_mwab % nbands * 3 , trim ( format_precision ) allocate ( elnes_orbital % ion_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%ion_no' ) allocate ( elnes_orbital % species_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%species_no' ) allocate ( elnes_orbital % rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbitall%rank_in_species' ) allocate ( elnes_orbital % shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbitall%shell' ) allocate ( elnes_orbital % am_channel ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%am_channel' ) allocate ( elnes_orbital % am_channel_name ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : read_elnes_fmt cannot allocate elnes_orbital%am_channel_name' ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) read ( elnes_unit , '(a10,' // trim ( string ) // ')' ) dummy10 , elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) allocate ( elnes_mat ( 1 : elnes_mwab % norbitals , 1 : elnes_mwab % nbands , 1 : 3 , & 1 : num_kpoints_on_node ( 0 ), 1 : elnes_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating elnes_mat in read_elnes_fmt' ) do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , elnes_mwab % nspins read ( elnes_unit , '(' // trim ( string2 ) // ')' ) ((( elnes_mat ( iorb , ib , indx , ik , is ), iorb = 1 , elnes_mwab % norbitals ), & ib = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do call elec_elnes_find_channel_names () write ( stdout , * ) \" \" // trim ( seedname ) // \".elnes_fmt\" // \"--> Formatted elnes sucessfully read. \" end subroutine read_elnes_fmt !========================================================================= subroutine write_elnes_fmt () !! Soubroute to write a formatted elnes file. use od_electronic , only : elnes_mwab , elnes_orbital , elnes_mat , & & elec_elnes_find_channel_numbers use od_cell , only : num_kpoints_on_node use od_io , only : io_file_unit implicit none real ( dp ) :: file_version = 1.0_dp !! The file verioson format to write. Currently we're on version 1. integer :: elnes_unit !! File unit number to write to. integer :: ik , is , iorb , ib , indx !! Loop variables. character ( len = 80 ) :: string , string2 !! Tempory string manipulation variables. write ( stdout , * ) \" Write a formatted elnes file.\" ! CASTEP (hence the bin file) and OptaDOS think about am_channel numbers ! differently. To keep consistent we convert to CASTEP's numbering scheme ! before we write out. call elec_elnes_find_channel_numbers () elnes_unit = io_file_unit () open ( unit = elnes_unit , file = trim ( outseedname ) // \".elnes_fmt\" , form = 'formatted' ) write ( elnes_unit , '(' // trim ( format_precision ) // ')' ) file_version write ( elnes_unit , '(a80)' ) adjustl ( elnesfile_header ) write ( elnes_unit , '(a20,1x,i5)' ) \"Norbitals\" , elnes_mwab % norbitals write ( elnes_unit , '(a20,1x,i5)' ) \"Nbands\" , elnes_mwab % nbands write ( elnes_unit , '(a20,1x,i5)' ) \"Nkpoints\" , elnes_mwab % nkpoints write ( elnes_unit , '(a20,1x,i5)' ) \"Nspins\" , elnes_mwab % nspins write ( string , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals , \"i5\" write ( string2 , '(i7,\"(1x,\",a,\")\")' ) elnes_mwab % norbitals * elnes_mwab % nbands * 3 , trim ( format_precision ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Species_no\" , elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Rank\" , elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Shell\" , elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) write ( elnes_unit , '(a10,' // trim ( string ) // ')' ) \"Am_channel\" , elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , elnes_mwab % nspins write ( elnes_unit , '(' // trim ( string2 ) // ')' ) ((( elnes_mat ( iorb , ib , indx , ik , is ), iorb = 1 , elnes_mwab % norbitals ), & ib = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do close ( elnes_unit ) write ( stdout , * ) \" Sucesfully written a formatted elnes file --> \" // trim ( outseedname ) // \".elnes_fmt\" end subroutine write_elnes_fmt !========================================================================= subroutine read_elnes_bin () !! Wrapper to read a binary elnes file. The wrapping allows us to have !! consistent names within the module, which makes life easier. implicit none write ( stdout , * ) \" Read a binary elnes file.\" call elec_read_elnes_mat () end subroutine read_elnes_bin !========================================================================= subroutine write_elnes_bin () !! Writes a binary elnes file. use od_electronic , only : elec_elnes_find_channel_numbers , elnes_orbital ,& & elnes_mat , elnes_mwab use od_cell , only : num_kpoints_on_node use od_io , only : io_file_unit implicit none real ( dp ) :: file_version = 1.0_dp !! The file verioson format to write. Currently we're on version 1. integer :: ik , is , ib , iorb , indx !! Loop variables integer :: elnes_unit !! File unit number to write to. write ( stdout , * ) \" Write a binary elnes file.\" !write !! Some headers here? ! CASTEP (hence the bin file) and OptaDOS think about am_channel numbers ! differently. To keep consistent we convert to CASTEP's numbering scheme ! before we write out. call elec_elnes_find_channel_numbers () elnes_unit = io_file_unit () open ( unit = elnes_unit , file = trim ( outseedname ) // \".elnes_bin\" , form = 'unformatted' ) write ( elnes_unit ) file_version write ( elnes_unit ) adjustl ( elnesfile_header ) write ( elnes_unit ) elnes_mwab % norbitals write ( elnes_unit ) elnes_mwab % nbands write ( elnes_unit ) elnes_mwab % nkpoints write ( elnes_unit ) elnes_mwab % nspins ! write(string,'(i7,\"(1x,\",a,\")\")') elnes_mwab%norbitals,\"i5\" ! write(string2,'(i7,\"(1x,\",a,\")\")') elnes_mwab%norbitals*elnes_mwab%nbands*3, trim(format_precision) write ( elnes_unit ) elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) write ( elnes_unit ) elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) write ( elnes_unit ) elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) write ( elnes_unit ) elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , elnes_mwab % nspins write ( elnes_unit ) ((( elnes_mat ( iorb , ib , indx , ik , is ), iorb = 1 , elnes_mwab % norbitals ), & ib = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do write ( stdout , * ) \" Sucesfully written a binary elnes file --> \" // trim ( outseedname ) // \".elnes_bin\" close ( elnes_unit ) end subroutine write_elnes_bin !========================================================================= subroutine slice_an_ome () !! This routine takes OptaDOS's internal representation of an ome and !! puts its diagonal into its internal representation of a dome. !! It's useful for testing. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient , optical_mat implicit none integer :: loop !! Loop variable write ( stdout , * ) \" Slicing an ome into a dome.\" if (. not . allocated ( band_gradient )) then write ( stdout , * ) \" Allocating band_gradient\" allocate ( band_gradient ( nbands , 3 , nkpoints , nspins )) end if do loop = 1 , nbands band_gradient ( loop , :, :, :) = real ( optical_mat ( loop , loop , :, :, :), dp ) end do end subroutine slice_an_ome !========================================================================= subroutine pad_an_ome () !! This routine takes OptaDOS's internal representation of an dome file, and !! uses it to construct an ome file, where the off diagonal elements are !! padded with zeros. !! It might be helpful if we're reading in other codes' input files. !! It might also be useful for testing OptaDOS itself. use od_constants , only : dp use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_electronic , only : nspins , nbands , band_gradient , optical_mat implicit none integer :: loop !! Loop variable. write ( stdout , * ) \" Padding a dome into a ome.\" if (. not . allocated ( optical_mat )) then write ( stdout , * ) \" Allocating optical_mat\" allocate ( optical_mat ( nbands , nbands , 3 , nkpoints , nspins )) end if ! Pad with zeros. optical_mat = 0.0_dp do loop = 1 , nbands optical_mat ( loop , loop , :, :, :) = band_gradient ( loop , :, :, :) end do end subroutine pad_an_ome !========================================================================= subroutine report_arraysize () !! Write to stdout some info on the size of the arrays we're using. These !! are normally found in the .bands file. use od_electronic , only : nspins , nbands use od_cell , only : nkpoints use od_io , only : stdout implicit none write ( stdout , '(a40,i5)' ) \" Number of kpoints : \" , nkpoints write ( stdout , '(a40,i5)' ) \" Number of bands : \" , nbands write ( stdout , '(a40,i5)' ) \" Number of spins : \" , nspins end subroutine report_arraysize !========================================================================= subroutine get_band_energy () !! Read the band file info which is prerequisite to know about k-points !! bands etc. !! It would be nice for od2od to work this out for itself. But at least this !! way it is consistent.  The problem is that to convert, say a ome to a ome !! one also requires a .bands file. implicit none write ( stdout , * ) write ( stdout , * ) \"+----------------------------- K-point information --------------------------+\" call elec_read_band_energy () call report_arraysize () write ( stdout , * ) \"+----------------------------------------------------------------------------+\" end subroutine get_band_energy !========================================================================= subroutine write_read_file () !! Noddy routine to prettify output implicit none write ( stdout , * ) write ( stdout , * ) \"+-------------------------------- Read File ---------------------------------+\" end subroutine write_read_file end module od_conv program od2od !! Program to convert checkpoint files from formatted to unformmated !! and vice versa - useful for switching between computers. !! !! Plan is to use to convert outputs of other DFT programs to ones that !! OptaDOS can read. !! !! AJM 2019 use od_constants , only : dp use od_io , only : io_file_unit , stdout , stderr , io_error , seedname , io_time , & & io_date use od_conv use od_comms , only : num_nodes , comms_setup , comms_end implicit none logical :: file_found logical :: ome_conv , fem_conv , dome_conv , pdos_conv , elnes_conv , dummy_conv !! Flags to stop people trying to, say, read in a pdos and write out an !! elnes. That's not going to end well. real ( kind = dp ) :: time0 , time1 !! Varaibles for measuring exectuion time. character ( len = 9 ) :: pos !! Status and position of .odo file character ( len = 9 ) :: stat !! Position of .odo file character ( len = 9 ) :: ctime !! Temp. time string character ( len = 11 ) :: cdate !! Temp. date string time0 = io_time () iprint = 4 call comms_setup call conv_get_seedname stderr = io_file_unit () open ( unit = stderr , file = trim ( seedname ) // '.opt_err' ) call io_date ( cdate , ctime ) write ( stderr , * ) 'od2od: Execution started on ' , cdate , ' at ' , ctime stdout = io_file_unit () open ( unit = stdout , file = trim ( seedname ) // '.log' ) !-------------------------------------------------------------------------! write ( stdout , * ) write ( stdout , * ) 'od2od: Execution started on ' , cdate , ' at ' , ctime write ( stdout , * ) write ( stdout , * ) \"+============================================================================+ \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"|                         OO   DDD   222    OO   DDD                         | \" write ( stdout , * ) \"|                        O  O  D  D     2  O  O  D  D                        | \" write ( stdout , * ) \"|                        O  O  D  D   22   O  O  D  D                        | \" write ( stdout , * ) \"|                        O  O  D  D  2     O  O  D  D                        | \" write ( stdout , * ) \"|                         OO   DDD   2222   OO   DDD                         | \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"|                   For doing the odd thing to OptaDOS files                 | \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"|                      OptaDOS Developers Group 2019 (C)                     | \" write ( stdout , * ) \"|                             (But blame Andrew)                             | \" write ( stdout , * ) \"|                                                                            | \" write ( stdout , * ) \"+============================================================================+ \" if ( num_nodes /= 1 ) then call io_error ( 'od2od can only be used in serial...' ) end if write ( stdout , * ) write ( stdout , * ) \"+--------------------------------- JOB CONTROL ------------------------------+\" write ( stdout , '(a40,i5)' ) \"Number of nodes : \" , num_nodes write ( stdout , '(a40,a)' ) \"Convert from : \" , trim ( infile ) write ( stdout , '(a40,a)' ) \"Convert to : \" , trim ( outfile ) write ( stdout , '(a40,a)' ) \"Seedname : \" , trim ( seedname ) write ( stdout , '(a40,a)' ) \"Output Seedname : \" , trim ( outseedname ) write ( stdout , * ) \"+----------------------------------------------------------------------------+\" ome_conv = . false . fem_conv = . false . dome_conv = . false . pdos_conv = . false . elnes_conv = . false . dummy_conv = . false . ! Main case to decide what file format to read in. read_input : select case ( trim ( infile )) case ( \"ome_fmt\" ) ome_conv = . true . call get_band_energy () call write_read_file () call read_ome_fmt () case ( \"ome_bin\" ) ome_conv = . true . call get_band_energy () call write_read_file () call read_ome_bin () case ( \"fem_fmt\" ) fem_conv = . true . call get_band_energy () call write_read_file () call read_fem_fmt () case ( \"fem_bin\" ) fem_conv = . true . call get_band_energy () call write_read_file () call read_fem_bin () case ( \"dome_fmt\" ) dome_conv = . true . call get_band_energy () call write_read_file () call read_dome_fmt () case ( \"dome_bin\" ) dome_conv = . true . call get_band_energy () call write_read_file () call read_dome_bin () case ( \"pdos_fmt\" ) pdos_conv = . true . call get_band_energy () call write_read_file () call read_pdos_fmt () case ( \"pdos_bin\" ) pdos_conv = . true . call get_band_energy () call write_read_file () call read_pdos_bin () case ( \"elnes_fmt\" ) elnes_conv = . true . call get_band_energy () call write_read_file () call read_elnes_fmt () case ( \"elnes_bin\" ) elnes_conv = . true . call get_band_energy () call write_read_file () call read_elnes_bin () case ( \"dummy\" ) dummy_conv = . true . call get_band_energy () call write_read_file () write ( stdout , * ) \" Not reading any input file.\" case default call io_error ( 'Unknown Input File format speccified' ) end select read_input write ( stdout , * ) \"+----------------------------------------------------------------------------+\" write ( stdout , * ) write ( stdout , * ) \"+------------------------------- Write File ---------------------------------+\" ! Main case to decide what file format to write. write_output : select case ( trim ( outfile )) case ( \"ome_fmt\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) if ( dome_conv ) call pad_an_ome () call write_ome_fmt () case ( \"ome_bin\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) if ( dome_conv ) call pad_an_ome () call write_ome_bin () case ( \"fem_fmt\" ) if (. not . ( fem_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) call write_fem_fmt () case ( \"fem_bin\" ) if (. not . ( fem_conv )) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' & & // trim ( outfile )) call write_fem_bin () case ( \"dome_fmt\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // & & ' not compatible with output format ' // trim ( outfile )) if ( ome_conv ) call slice_an_ome () call write_dome_fmt () case ( \"dome_bin\" ) if (. not . ( dome_conv . or . ome_conv )) call io_error ( ' Input format ' // trim ( infile ) // & & ' not compatible with output format ' // trim ( outfile )) if ( ome_conv ) call slice_an_ome () call write_dome_bin () case ( \"pdos_fmt\" ) if (. not . pdos_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_pdos_fmt () case ( \"pdos_bin\" ) if (. not . pdos_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_pdos_bin () case ( \"elnes_fmt\" ) if (. not . elnes_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_elnes_fmt () case ( \"elnes_bin\" ) if (. not . elnes_conv ) call io_error ( ' Input format ' // trim ( infile ) // ' not compatible with output format ' // trim ( outfile )) call write_elnes_bin () case ( \"dummy\" ) write ( stdout , * ) \" Not writing any output file.\" if ( dummy_conv ) then write ( stdout , * ) write ( stdout , * ) \"                 Dummy in + dummy out  -- who's the dummy now ?\" else write ( stdout , * ) write ( stdout , * ) \"                No point in taking up disk space unnecessarily, eh ?\" end if case default call io_error ( 'Unknown Output File format speccified' ) end select write_output call io_date ( cdate , ctime ) write ( stdout , * ) \"+----------------------------------------------------------------------------+\" time1 = io_time () write ( stdout , '(1x,a40,f11.3,a)' ) 'Total runtime :' , time1 - time0 , ' (sec)' write ( stdout , * ) write ( stdout , * ) 'od2od: Execution complete on ' , cdate , ' at ' , ctime write ( stdout , * ) close ( stdout ) close ( stderr , status = 'delete' ) call comms_end !  close(unit=stdout,status='delete') end program od2od","tags":"","loc":"sourcefile/od2od.f90.html"},{"title":"core.f90 – OptaDOS","text":"This file depends on sourcefile~~core.f90~~EfferentGraph sourcefile~core.f90 core.f90 sourcefile~constants.f90 constants.f90 sourcefile~core.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~io.f90 io.f90 sourcefile~core.f90->sourcefile~io.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~comms.f90 comms.F90 sourcefile~core.f90->sourcefile~comms.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~cell.f90 cell.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~core.f90->sourcefile~xmgrace_utils.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~core.f90~~AfferentGraph sourcefile~core.f90 core.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~core.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_core Source Code core.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=============================================================================== module od_core use od_constants , only : dp implicit none private public :: core_calculate real ( kind = dp ), allocatable , public , dimension (:, :, :, :) :: matrix_weights real ( kind = dp ), allocatable , public , dimension (:, :, :) :: weighted_dos real ( kind = dp ), allocatable , public , dimension (:, :, :) :: weighted_dos_broadened contains subroutine core_calculate use od_electronic , only : elec_read_elnes_mat , efermi_set use od_dos_utils , only : dos_utils_calculate , dos_utils_set_efermi , & & dos_utils_compute_bandgap use od_comms , only : on_root use od_io , only : stdout use od_parameters , only : core_LAI_broadening , LAI_gaussian , LAI_lorentzian , & & set_efermi_zero , LAI_lorentzian_scale , core_chemical_shift implicit none if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                            Core Loss Calculation                           +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if ! read in the core matrix elements from disk call elec_read_elnes_mat !    (elnes_mat(orb,nb,indx,nk,ns),indx=1,3) if (. not . efermi_set ) call dos_utils_set_efermi call core_prepare_matrix_elements call dos_utils_calculate ( matrix_weights , weighted_dos ) ! Lifetime and instrumental broadening if ( core_LAI_broadening . eqv . . true .) then allocate ( weighted_dos_broadened ( size ( weighted_dos , 1 ), size ( weighted_dos , 2 ), size ( weighted_dos , 3 ))) weighted_dos_broadened = 0.0_dp if ( LAI_lorentzian . or . ( LAI_lorentzian_scale . gt . 0.00001_dp )) call core_lorentzian if ( LAI_gaussian ) call core_gaussian end if if ( set_efermi_zero . and . . not . efermi_set ) call dos_utils_set_efermi if ( on_root ) then call write_core end if end subroutine core_calculate ! Private routines subroutine core_prepare_matrix_elements use od_electronic , only : elnes_mat , elnes_mwab , nbands , nspins , num_electrons , electrons_per_state , & efermi , band_energy use od_comms , only : my_node_id use od_cell , only : num_kpoints_on_node , cell_get_symmetry , & num_crystal_symmetry_operations , crystal_symmetry_operations use od_parameters , only : core_geom , core_qdir , core_type , legacy_file_format , devel_flag use od_io , only : io_error real ( kind = dp ), dimension ( 3 ) :: qdir real ( kind = dp ) :: q_weight integer :: N , N_spin , n_eigen , orb , ierr , num_sym , j , N2 , N3 , i , N_in real ( kind = dp ), dimension ( 2 ) :: num_occ complex ( kind = dp ) :: g num_occ = 0.0_dp if (. not . legacy_file_format . and . index ( devel_flag , 'old_filename' ) > 0 ) then call cell_get_symmetry end if num_sym = num_crystal_symmetry_operations if ( num_sym > 1 ) call io_error ( 'Error: Core loss not currently able to deal with symmetry. Please & &re-run CASTEP without symmetry.' ) allocate ( matrix_weights ( elnes_mwab % norbitals , elnes_mwab % nbands , num_kpoints_on_node ( my_node_id ), nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_prepare_matrix_elements - allocation failed for matrix_weights' ) matrix_weights = 0.0_dp N_in = 1 ! 0 = no inversion, 1 = inversion if ( index ( core_geom , 'polar' ) > 0 ) then qdir = core_qdir q_weight = (( qdir ( 1 ) ** 2.0_dp ) + ( qdir ( 2 ) ** 2.0_dp ) + ( qdir ( 3 ) ** 2.0_dp )) ** 0.5_dp if ( q_weight < 0.001_dp ) & call io_error ( \"Error: core_prepare_matrix_elements.  please check core_qdir, norm close to zero\" ) end if do N = 1 , num_kpoints_on_node ( my_node_id ) ! Loop over kpoints do N_spin = 1 , nspins ! Loop over spins do n_eigen = 1 , nbands ! Loop over state 1 if ( band_energy ( n_eigen , N_spin , N ) < efermi . and . core_type == 'absorption' ) cycle ! XES if ( band_energy ( n_eigen , N_spin , N ) > efermi . and . core_type == 'emission' ) cycle ! ELNES / XANES do orb = 1 , elnes_mwab % norbitals if ( index ( core_geom , 'polar' ) > 0 ) then if ( num_sym == 0 ) then g = ((( qdir ( 1 ) * elnes_mat ( orb , n_eigen , 1 , N , N_spin )) + & ( qdir ( 2 ) * elnes_mat ( orb , n_eigen , 2 , N , N_spin )) + & ( qdir ( 3 ) * elnes_mat ( orb , n_eigen , 3 , N , N_spin ))) / q_weight ) matrix_weights ( orb , n_eigen , N , N_spin ) = real ( g * conjg ( g ), dp ) else do N2 = 1 , num_sym do N3 = 1 , 1 + N_in do i = 1 , 3 qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * core_qdir ( j )) end do end do g = 0.0_dp g = ((( qdir ( 1 ) * elnes_mat ( orb , n_eigen , 1 , N , N_spin )) + & ( qdir ( 2 ) * elnes_mat ( orb , n_eigen , 2 , N , N_spin )) + & ( qdir ( 3 ) * elnes_mat ( orb , n_eigen , 3 , N , N_spin ))) / q_weight ) matrix_weights ( orb , n_eigen , N , N_spin ) = & matrix_weights ( orb , n_eigen , N , N_spin ) + & ( 1.0_dp / Real (( num_sym * ( N_in + 1 )), dp )) * real ( g * conjg ( g ), dp ) end do end do end if else ! isotropic average matrix_weights ( orb , n_eigen , N , N_spin ) = real ( & & elnes_mat ( orb , n_eigen , 1 , N , N_spin ) * conjg ( elnes_mat ( orb , n_eigen , 1 , N , N_spin )) + & & elnes_mat ( orb , n_eigen , 2 , N , N_spin ) * conjg ( elnes_mat ( orb , n_eigen , 2 , N , N_spin )) + & & elnes_mat ( orb , n_eigen , 3 , N , N_spin ) * conjg ( elnes_mat ( orb , n_eigen , 3 , N , N_spin )), dp ) & & / 3.0_dp !                matrix_weights(orb,n_eigen,N,N_spin) = real(g*conjg(g),dp) !           matrix_weights(n_eigen,n_eigen2,N,N_spin) = 1.0_dp  ! end if end do end do end do end do end subroutine core_prepare_matrix_elements subroutine write_core !************************************************************************* ! This subroutine writes out the Core loss function !------------------------------------------------------------------------- ! Adapted by A F Harper to include an E_shift to account for core hole !========================================================================= use od_constants , only : bohr2ang , periodic_table_name , pi use od_parameters , only : dos_nbins , core_LAI_broadening , LAI_gaussian , LAI_gaussian_width , & LAI_lorentzian , LAI_lorentzian_scale , LAI_lorentzian_width , LAI_lorentzian_offset , output_format , & set_efermi_zero , core_chemical_shift use od_electronic , only : elnes_mwab , elnes_orbital , efermi , efermi_set , nspins use od_io , only : seedname , io_file_unit , io_error use od_dos_utils , only : E , dos_utils_set_efermi , vbm_energy , cbm_energy use od_cell , only : num_species , atoms_symbol , atoms_label , cell_volume use xmgrace_utils integer :: N real ( kind = dp ) :: dE , min_x , min_y , max_x , max_y , range integer :: core_unit , orb , ierr , loop , loop2 , counter , num_edge , num_sites character ( len = 20 ) :: temp character ( len = 40 ) :: temp2 character ( len = 10 ), allocatable :: elnes_symbol (:) character ( len = 10 ), allocatable :: elnes_label (:) integer , allocatable :: edge_shell (:), edge_am (:), edge_num_am (:), edge_list (:, :) integer , allocatable :: edge_species (:), edge_rank_in_species (:) integer , allocatable :: ion_species (:), ion_num_in_species (:) character ( len = 40 ), allocatable :: edge_name (:) logical :: found real ( kind = dp ), allocatable :: dos_temp (:, :), dos_temp2 (:, :) real ( kind = dp ), allocatable :: E_shift (:) real ( kind = dp ) :: epsilon2_const real ( kind = dp ), parameter :: epsilon_0 = 8.8541878176E-12_dp real ( kind = dp ), parameter :: e_charge = 1.602176487E-19_dp allocate ( E_shift ( dos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating E_shift in core_write' ) if ( set_efermi_zero ) then E_shift = E - efermi else E_shift = E end if if ( nspins == 1 ) then allocate ( dos_temp ( dos_nbins , 1 ), stat = ierr ) else allocate ( dos_temp ( dos_nbins , 3 ), stat = ierr ) end if if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of dos_temp failed' ) if ( nspins == 1 ) then allocate ( dos_temp2 ( dos_nbins , 1 ), stat = ierr ) else allocate ( dos_temp2 ( dos_nbins , 3 ), stat = ierr ) end if if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of dos_temp2 failed' ) allocate ( elnes_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of elnes_symbol failed' ) allocate ( elnes_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of elnes_label failed' ) dE = E ( 2 ) - E ( 1 ) ! This next bit of convoluted code attempts to figure out what order the ! orbitals were in the elnes file. It will be the order castep labels the atoms ! which is not the same as the cell file. Not that any species that are defined ! using labels such as B:ext B:1 etc will appear after the other elements. counter = 1 do loop = 1 , num_species do loop2 = 1 , 109 if ( atoms_label ( loop ) == periodic_table_name ( loop2 )) then elnes_symbol ( counter ) = periodic_table_name ( loop2 ) elnes_label ( counter ) = '' counter = counter + 1 exit !check atom count here end if end do end do if ( counter < num_species + 1 ) then do loop = 1 , num_species found = . false . do loop2 = 1 , 109 if ( atoms_label ( loop ) == periodic_table_name ( loop2 )) then found = . true . exit end if end do if (. not . found ) then do loop2 = 1 , 109 if ( atoms_symbol ( loop ) == periodic_table_name ( loop2 )) then elnes_symbol ( counter ) = periodic_table_name ( loop2 ) elnes_label ( counter ) = atoms_label ( loop ) counter = counter + 1 exit end if end do end if end do end if !!$ !!$    ! Open the output file !!$    core_unit = io_file_unit() !!$    open(unit=core_unit,action='write',file=trim(seedname)//'_core.dat') !!$ !!$    ! Write into the output file !!$    write(core_unit,*)'#*********************************************' !!$    write(core_unit,*)'#            Core loss function               ' !!$    write(core_unit,*)'#*********************************************' !!$    write(core_unit,*)'#' !!$    if(core_LAI_broadening) then !!$       if(LAI_gaussian) write(core_unit,*)'# Gaussian broadening: FWHM', LAI_gaussian_width !!$       if(LAI_lorentzian) then !!$          write(core_unit,*)'# Lorentzian broadening included' !!$          write(core_unit,*)'# Lorentzian scale ', LAI_lorentzian_scale !!$          write(core_unit,*)'# Lorentzian offset ', LAI_lorentzian_offset !!$          write(core_unit,*)'# Lorentzian width ', LAI_lorentzian_width !!$       end if !!$    end if !!$    write(core_unit,*)'#' !!$ !!$ !!$    do orb=1,elnes_mwab%norbitals   ! writing out doesn't include spin at the moment. !!$ !!$       write(temp,'(a2,i1,a17)') 'n=',elnes_orbital%shell(orb),' ang= '//trim(elnes_orbital%am_channel_name(orb)) !!$ !!$       write(temp2,'(a5,a2,1x,i0,a28)') 'Ion: ',trim(elnes_symbol(elnes_orbital%species_no(orb))),& !!$        & elnes_orbital%rank_in_species(orb),' State: '//trim(temp) !!$       write(core_unit,*) '# ',trim(temp2) !!$ !!$ !!$       do N=1,dos_nbins !!$          if (core_LAI_broadening) then !!$             write(core_unit,*)E(N),weighted_dos(N,1,orb),weighted_dos_broadened(N,1,orb) !!$          else !!$             write(core_unit,*)E(N),weighted_dos(N,1,orb) !!$          end if !!$       end do !!$       write(core_unit,*)'' !!$    end do !!$ !!$    close(core_unit) ! Converts units, note I don't have to worry about this in optics.f90 at electronic does it weighted_dos = weighted_dos * bohr2ang ** 2 if ( core_LAI_broadening ) weighted_dos_broadened = weighted_dos_broadened * bohr2ang ** 2 ! Units are currently (ang&#94;2)(eV&#94;-1) so need to multiply by a factor so we have a dimensionless epsilon_2 epsilon2_const = ( e_charge * pi * 1E-20 ) / ( cell_volume * 1E-30 * epsilon_0 ) weighted_dos = weighted_dos * epsilon2_const if ( core_LAI_broadening ) weighted_dos_broadened = weighted_dos_broadened * epsilon2_const allocate ( ion_species ( elnes_mwab % norbitals )) allocate ( ion_num_in_species ( elnes_mwab % norbitals )) ion_species = 0 ; ion_num_in_species = 0 !Find out what ions we have do loop = 1 , elnes_mwab % norbitals if ( loop == 1 ) then ion_species ( 1 ) = elnes_orbital % species_no ( 1 ) ion_num_in_species ( 1 ) = elnes_orbital % rank_in_species ( 1 ) counter = 1 else found = . false . do loop2 = 1 , counter if ( elnes_orbital % species_no ( loop ) == ion_species ( loop2 ) . and .& & elnes_orbital % rank_in_species ( loop ) == ion_num_in_species ( loop2 )) then found = . true . end if end do if (. not . found ) then counter = counter + 1 ion_species ( counter ) = elnes_orbital % species_no ( loop ) ion_num_in_species ( counter ) = elnes_orbital % rank_in_species ( loop ) end if end if end do num_sites = counter ! We allocate these arrays as the max possible size, and just fill in the bits we need allocate ( edge_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_species failed' ) allocate ( edge_rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_rank_in_species failed' ) allocate ( edge_shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_shell failed' ) allocate ( edge_am ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_am failed' ) allocate ( edge_num_am ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_num_am failed' ) allocate ( edge_list ( elnes_mwab % norbitals , 7 ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_list failed' ) edge_species = 0 ; edge_rank_in_species = 0 ; edge_shell = 0 ; edge_am = 0 ; edge_num_am = 0 ; edge_list = 0 counter = 1 ! Find out how many edges do loop = 1 , elnes_mwab % norbitals if ( loop == 1 ) then edge_species ( counter ) = elnes_orbital % species_no ( loop ) edge_rank_in_species ( counter ) = elnes_orbital % rank_in_species ( loop ) edge_shell ( counter ) = elnes_orbital % shell ( loop ) edge_am ( counter ) = elnes_orbital % am_channel ( loop ) edge_num_am ( counter ) = edge_num_am ( counter ) + 1 edge_list ( counter , edge_num_am ( counter )) = loop else ! else check if we have this am state found = . false . do loop2 = 1 , counter if ( edge_species ( loop2 ) == elnes_orbital % species_no ( loop ) . and .& & edge_rank_in_species ( loop2 ) == elnes_orbital % rank_in_species ( loop ) . and . & edge_shell ( loop2 ) == elnes_orbital % shell ( loop ) . and . edge_am ( loop2 ) == elnes_orbital % am_channel ( loop )) then edge_num_am ( counter ) = edge_num_am ( counter ) + 1 edge_list ( counter , edge_num_am ( counter )) = loop found = . true . end if end do if (. not . found ) then counter = counter + 1 edge_species ( counter ) = elnes_orbital % species_no ( loop ) edge_rank_in_species ( counter ) = elnes_orbital % rank_in_species ( loop ) edge_shell ( counter ) = elnes_orbital % shell ( loop ) edge_am ( counter ) = elnes_orbital % am_channel ( loop ) edge_num_am ( counter ) = edge_num_am ( counter ) + 1 edge_list ( counter , edge_num_am ( counter )) = loop end if end if end do num_edge = counter ! allocate ( edge_name ( num_edge ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: core_write - allocation of edge_name failed' ) ! fill in edge name do loop = 1 , num_edge if ( edge_shell ( loop ) == 1 ) then temp = 'K1' elseif ( edge_shell ( loop ) == 2 ) then if ( edge_am ( loop ) == 0 ) then temp = 'L1' elseif ( edge_am ( loop ) == 1 ) then temp = 'L2,3' end if elseif ( edge_shell ( loop ) == 3 ) then if ( edge_am ( loop ) == 0 ) then temp = 'M1' elseif ( edge_am ( loop ) == 1 ) then temp = 'M2,3' elseif ( edge_am ( loop ) == 2 ) then temp = 'M4,5' end if elseif ( edge_shell ( loop ) == 4 ) then if ( edge_am ( loop ) == 0 ) then temp = 'N1' elseif ( edge_am ( loop ) == 1 ) then temp = 'N2,3' elseif ( edge_am ( loop ) == 2 ) then temp = 'N4,5' elseif ( edge_am ( loop ) == 3 ) then temp = 'N6,7' end if elseif ( edge_shell ( loop ) == 5 ) then if ( edge_am ( loop ) == 0 ) then temp = 'O1' elseif ( edge_am ( loop ) == 1 ) then temp = 'O2,3' elseif ( edge_am ( loop ) == 2 ) then ! after this point I think we've drifted beyond what is physical! temp = 'O4,5' elseif ( edge_am ( loop ) == 3 ) then temp = 'O6,7' end if elseif ( edge_shell ( loop ) == 6 ) then if ( edge_am ( loop ) == 0 ) then temp = 'P1' elseif ( edge_am ( loop ) == 1 ) then temp = 'P2,3' elseif ( edge_am ( loop ) == 2 ) then temp = 'P4,5' elseif ( edge_am ( loop ) == 3 ) then temp = 'P6,7' end if end if if ( elnes_label ( edge_species ( loop )) == '' ) then write ( edge_name ( loop ), '(a2,1x,i0,1x,a5)' ) trim ( elnes_symbol ( edge_species ( loop ))), & & edge_rank_in_species ( loop ), trim ( temp ) else write ( edge_name ( loop ), '(a2,1x,i0,1x,a5,a10)' ) trim ( elnes_symbol ( edge_species ( loop ))), & edge_rank_in_species ( loop ), trim ( temp ), trim ( elnes_label ( edge_species ( loop ))) end if end do ! Now we know how many edges we have we can write them to a file ! Open the output file core_unit = io_file_unit () open ( unit = core_unit , action = 'write' , file = trim ( seedname ) // '_core_edge.dat' ) ! Write into the output file write ( core_unit , * ) '#*********************************************' write ( core_unit , * ) '#            Core loss function               ' write ( core_unit , * ) '#*********************************************' write ( core_unit , * ) '#' if ( core_LAI_broadening ) then if ( LAI_gaussian ) write ( core_unit , * ) '# Gaussian broadening: FWHM' , LAI_gaussian_width if ( LAI_lorentzian ) then write ( core_unit , * ) '# Lorentzian broadening included' write ( core_unit , * ) '# Lorentzian scale ' , LAI_lorentzian_scale write ( core_unit , * ) '# Lorentzian offset ' , LAI_lorentzian_offset write ( core_unit , * ) '# Lorentzian width ' , LAI_lorentzian_width end if end if write ( core_unit , * ) '#' do loop = 1 , num_edge write ( core_unit , * ) '# ' , trim ( edge_name ( loop )) dos_temp = 0.0_dp ; dos_temp2 = 0.0_dp ! Have had to reallocate this in order to do the core_chemical_shift below if ( set_efermi_zero ) then E_shift = E - efermi else E_shift = E end if if ( nspins == 1 ) then do loop2 = 1 , edge_num_am ( loop ) dos_temp (:, 1 ) = dos_temp (:, 1 ) + weighted_dos (:, 1 , edge_list ( loop , loop2 )) / real ( edge_num_am ( loop ), dp ) if ( core_LAI_broadening ) then dos_temp2 (:, 1 ) = dos_temp2 (:, 1 ) + weighted_dos_broadened (:, 1 , edge_list ( loop , loop2 ))& & / real ( edge_num_am ( loop ), dp ) end if end do else do loop2 = 1 , edge_num_am ( loop ) dos_temp (:, 1 ) = dos_temp (:, 1 ) + weighted_dos (:, 1 , edge_list ( loop , loop2 )) / real ( edge_num_am ( loop ), dp ) dos_temp (:, 2 ) = dos_temp (:, 2 ) + weighted_dos (:, 2 , edge_list ( loop , loop2 )) / real ( edge_num_am ( loop ), dp ) dos_temp (:, 3 ) = dos_temp (:, 3 ) + dos_temp (:, 1 ) + dos_temp (:, 2 ) if ( core_LAI_broadening ) then dos_temp2 (:, 1 ) = dos_temp2 (:, 1 ) + weighted_dos_broadened (:, 1 , edge_list ( loop , loop2 )) / & & real ( edge_num_am ( loop ), dp ) dos_temp2 (:, 2 ) = dos_temp2 (:, 2 ) + weighted_dos_broadened (:, 2 , edge_list ( loop , loop2 )) / & & real ( edge_num_am ( loop ), dp ) dos_temp2 (:, 3 ) = dos_temp2 (:, 3 ) + dos_temp2 (:, 1 ) + dos_temp2 (:, 2 ) end if end do end if !Originally written to calculate the first nonzero term in the edge !elnes_edge = 0.0_dp !do N = 1, dos_nbins !doing this because we want to find the last 0.0000 value before the start of the peak edge !  if (dos_temp(N, 1) > 0.0_dp) then !    elnes_edge = E_shift(N) !    exit !  end if !end do !write (core_unit, *) elnes_edge !test to write out elnes_edge !write (core_unit, *) cbm_energy ! test to see if cbm calculated !write (core_unit, *) vbm_energy! test to see if cbm calculated ! Applies mizoguchi chemical shift if added to dos if ( core_chemical_shift /= - 1.0_dp ) then E_shift = E + core_chemical_shift - cbm_energy end if do N = 1 , dos_nbins if ( nspins == 1 ) then if ( core_LAI_broadening ) then write ( core_unit , * ) E_shift ( N ), dos_temp ( N , 1 ), dos_temp2 ( N , 1 ) else write ( core_unit , * ) E_shift ( N ), dos_temp ( N , 1 ) end if else if ( core_LAI_broadening ) then write ( core_unit , '(7(E21.13,2x))' ) E_shift ( N ), dos_temp ( N , 1 ), dos_temp ( N , 2 ),& & dos_temp ( N , 3 ), dos_temp2 ( N , 1 ), dos_temp2 ( N , 2 ), dos_temp2 ( N , 3 ) else write ( core_unit , '(4(E21.13,2x))' ) E_shift ( N ), dos_temp ( N , 1 ), dos_temp ( N , 2 ), dos_temp ( N , 3 ) end if end if end do write ( core_unit , * ) '' end do close ( core_unit ) if ( num_sites == 1 ) then ! if only one site we write out plot script files if ( trim ( output_format ) == \"xmgrace\" ) then core_unit = io_file_unit () open ( unit = core_unit , file = trim ( seedname ) // '_' // 'core_edge' // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in core: write_core_xmgrace\" ) min_x = minval ( E_shift ) max_x = maxval ( E_shift ) min_y = minval ( weighted_dos ) max_y = maxval ( weighted_dos ) ! For aesthetic reasons we make the axis range 1% larger than the data range range = abs ( max_y - min_y ) max_y = max_y + 0.01_dp * range min_y = 0.0_dp !min_y-0.01_dp*range call xmgu_setup ( core_unit ) call xmgu_legend ( core_unit ) call xmgu_title ( core_unit , min_x , max_x , min_y , max_y , 'Core-loss Spectrum' ) call xmgu_axis ( core_unit , \"y\" , 'Units' ) call xmgu_axis ( core_unit , \"x\" , 'Energy (eV)' ) do loop = 1 , num_edge dos_temp = 0.0_dp ; dos_temp2 = 0.0_dp do loop2 = 1 , edge_num_am ( loop ) if ( nspins == 1 ) then dos_temp (:, 1 ) = dos_temp (:, 1 ) + weighted_dos (:, 1 , edge_list ( loop , loop2 )) / real ( edge_num_am ( loop ), dp ) else dos_temp (:, 1 ) = dos_temp (:, 1 ) + weighted_dos (:, 1 , edge_list ( loop , loop2 )) / real ( edge_num_am ( loop ), dp ) dos_temp (:, 2 ) = dos_temp (:, 2 ) + weighted_dos (:, 2 , edge_list ( loop , loop2 )) / real ( edge_num_am ( loop ), dp ) dos_temp (:, 3 ) = dos_temp (:, 1 ) + dos_temp (:, 1 ) + dos_temp (:, 2 ) end if end do call xmgu_data_header ( core_unit , loop , loop , trim ( edge_name ( loop ))) call xmgu_data ( core_unit , loop , E_shift (:), dos_temp (:, 1 )) ! only 1 element at the moment RJN 28Aug14 end do if ( core_LAI_broadening ) then core_unit = io_file_unit () open ( unit = core_unit , file = trim ( seedname ) // '_' // 'core_edge_broad' // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in core: write_core_xmgrace\" ) min_x = minval ( E_shift ) max_x = maxval ( E_shift ) min_y = minval ( weighted_dos ) max_y = maxval ( weighted_dos ) ! For aesthetic reasons we make the axis range 1% larger than the data range range = abs ( max_y - min_y ) max_y = max_y + 0.01_dp * range min_y = 0.0_dp !min_y-0.01_dp*range call xmgu_setup ( core_unit ) call xmgu_legend ( core_unit ) call xmgu_title ( core_unit , min_x , max_x , min_y , max_y , 'Core-loss Spectrum' ) call xmgu_axis ( core_unit , \"y\" , 'Units' ) call xmgu_axis ( core_unit , \"x\" , 'Energy (eV)' ) do loop = 1 , num_edge dos_temp = 0.0_dp ; dos_temp2 = 0.0_dp do loop2 = 1 , edge_num_am ( loop ) if ( nspins == 1 ) then dos_temp (:, 1 ) = dos_temp (:, 1 ) + weighted_dos_broadened (:, 1 , edge_list ( loop , loop2 )) / & & real ( edge_num_am ( loop ), dp ) else dos_temp (:, 1 ) = dos_temp (:, 1 ) + weighted_dos_broadened (:, 1 , edge_list ( loop , loop2 )) / & & real ( edge_num_am ( loop ), dp ) dos_temp (:, 2 ) = dos_temp (:, 2 ) + weighted_dos_broadened (:, 2 , edge_list ( loop , loop2 )) / & & real ( edge_num_am ( loop ), dp ) dos_temp (:, 3 ) = dos_temp (:, 1 ) + dos_temp (:, 1 ) + dos_temp (:, 2 ) end if end do call xmgu_data_header ( core_unit , loop , loop , trim ( edge_name ( loop ))) call xmgu_data ( core_unit , loop , E_shift (:), dos_temp (:, 1 )) ! Only 1 part for now RJN 28Aug14 end do end if end if end if deallocate ( E_shift , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating E_shift in write_core' ) end subroutine write_core subroutine core_gaussian !************************************************************** ! This subroutine adds in instrumental (Gaussian) broadening use od_constants , only : pi , dp , bohr2ang use od_parameters , only : LAI_gaussian_width , dos_nbins , LAI_lorentzian , LAI_lorentzian_scale use od_dos_utils , only : E use od_electronic , only : nspins , elnes_mwab , band_energy integer :: N , N_spin , N_energy , N_energy2 real ( kind = dp ) :: G_width , g , dE real ( kind = dp ), allocatable , dimension (:, :, :) :: weighted_dos_temp G_width = LAI_gaussian_width ! FWHM of Gaussian dE = E ( 2 ) - E ( 1 ) allocate ( weighted_dos_temp ( size ( weighted_dos , 1 ), size ( weighted_dos , 2 ), size ( weighted_dos , 3 ))) weighted_dos_temp = 0.0_dp if ( LAI_lorentzian . or . ( LAI_lorentzian_scale . gt . 0.00001_dp )) then weighted_dos_temp = weighted_dos_broadened ! In case we've already done Lorentzian broadening weighted_dos_broadened = 0.0_dp else weighted_dos_temp = weighted_dos end if do N = 1 , elnes_mwab % norbitals ! Loop over orbitals do N_spin = 1 , nspins ! Loop over spins do N_energy = 1 , dos_nbins ! Loop over energy do N_energy2 = 1 , dos_nbins ! Turn each energy value into a function g = ((( 4.0_dp * log ( 2.0_dp )) / pi ) ** ( 0.5_dp )) * ( 1 / G_width ) * exp ( - 4.0_dp * ( log ( 2.0_dp )) * & ((( E ( N_energy2 ) - E ( N_energy )) / G_width ) ** 2.0_dp )) ! Gaussian weighted_dos_broadened ( N_energy2 , N_spin , N ) = weighted_dos_broadened ( N_energy2 , N_spin , N ) & + ( g * weighted_dos_temp ( N_energy , N_spin , N ) * dE ) end do end do ! End loop over energy end do ! End loop over spins end do ! End loop over orbitals end subroutine core_gaussian subroutine core_lorentzian !************************************************************** ! This subroutine adds in life-time (Lorentzian) broadening use od_constants , only : pi , dp use od_parameters , only : LAI_lorentzian_width , LAI_lorentzian_scale , LAI_lorentzian_offset , & LAI_gaussian_width , dos_nbins , LAI_gaussian , adaptive , linear , fixed use od_dos_utils , only : E use od_electronic , only : nspins , elnes_mwab , efermi use od_dos_utils , only : efermi_fixed , efermi_adaptive , efermi_linear integer :: N , N_spin , N_energy , N_energy2 real ( kind = dp ) :: L_width , l , dE dE = E ( 2 ) - E ( 1 ) do N = 1 , elnes_mwab % norbitals ! Loop over orbitals do N_spin = 1 , nspins ! Loop over spins do N_energy = 1 , dos_nbins ! Loop over energy if ( E ( N_energy ) . ge . ( LAI_lorentzian_offset + efermi )) then L_width = 0.5_dp * ( LAI_lorentzian_width & ! HWHW of Lorentzian + (( E ( N_energy ) - efermi - LAI_lorentzian_offset ) * LAI_lorentzian_scale )) else L_width = 0.5_dp * LAI_lorentzian_width end if if (( L_width * pi ) . lt . dE ) then ! to get rid of spikes caused by L_width too small L_width = dE / pi end if do N_energy2 = 1 , dos_nbins ! Turn each energy value into a function l = weighted_dos ( N_energy , N_spin , N ) * L_width / ( pi * ((( E ( N_energy2 ) - E ( N_energy )) ** 2 ) + ( L_width ** 2 ))) ! Lorentzian weighted_dos_broadened ( N_energy2 , N_spin , N ) = weighted_dos_broadened ( N_energy2 , N_spin , N ) + ( l * dE ) end do !  end if end do ! End look over energy end do ! End loop over spins end do ! End loop over orbitals end subroutine core_lorentzian !!$ !!$  !=============================================================================== !!$  subroutine write_core_gnuplot(label,E,column1,column2,column3) !!$    !=============================================================================== !!$    use od_io,         only : io_file_unit,io_error,seedname !!$    implicit none !!$ !!$    type(graph_labels),intent(in) :: label !!$ !!$    real(dp),  intent(in) :: E(:) !!$    real(dp),  intent(in)  :: column1(:) !!$    real(dp),  optional, intent(in) :: column2(:) !!$    real(dp),  optional, intent(in) :: column3(:) !!$ !!$    integer :: gnu_unit,ierr !!$ !!$    gnu_unit=io_file_unit() !!$    open(unit=gnu_unit,file=trim(seedname)//'_'//trim(label%name)//'.gnu',iostat=ierr) !!$    if(ierr.ne.0) call io_error(\" ERROR: Cannot open gnuplot batch file in optics: write_optics_gnupot\") !!$ !!$    gnu_unit = io_file_unit() !!$    open(unit=gnu_unit,action='write',file=trim(seedname)//'_'//trim(label%name)//'.gnu') !!$    write(gnu_unit,*) 'set xlabel ','\"'//trim(label%x_label)//'\"' !!$    write(gnu_unit,*) 'set ylabel ','\"'//trim(label%y_label)//'\"' !!$    write(gnu_unit,*) 'set title ','\"'//trim(label%title)//'\"' !!$    if(present(column3)) then !!$       write(gnu_unit,*) 'plot ','\"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:2 t ','\"'//trim(label%legend_a)//'\"',' w l, \\' !!$       write(gnu_unit,*) '       \"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:3 t ','\"'//trim(label%legend_b)//'\"',' w l, \\' !!$       write(gnu_unit,*) '       \"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:4 t ','\"'//trim(label%legend_c)//'\"',' w l' !!$    elseif(present(column2)) then !!$       write(gnu_unit,*) 'plot ','\"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:2 t ','\"'//trim(label%legend_a)//'\"',' w l, \\' !!$       write(gnu_unit,*) '       \"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:3 t ','\"'//trim(label%legend_b)//'\"',' w l' !!$    else !!$       write(gnu_unit,*) 'plot ','\"'//trim(seedname)//'_'//trim(label%name)//'.dat'//'\"',' u 1:2 t ','\"'//trim(label%legend_a)//'\"',' w l' !!$    endif !!$    close(gnu_unit) !!$ !!$  end subroutine write_optics_gnuplot !!$ end module od_core","tags":"","loc":"sourcefile/core.f90.html"},{"title":"xmgrace_utils.f90 – OptaDOS","text":"This file depends on sourcefile~~xmgrace_utils.f90~~EfferentGraph sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~io.f90 io.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~constants.f90 constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~io.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~xmgrace_utils.f90~~AfferentGraph sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~jdos.f90->sourcefile~xmgrace_utils.f90 sourcefile~dos.f90 dos.f90 sourcefile~dos.f90->sourcefile~xmgrace_utils.f90 sourcefile~optics.f90 optics.f90 sourcefile~optics.f90->sourcefile~xmgrace_utils.f90 sourcefile~core.f90 core.f90 sourcefile~core.f90->sourcefile~xmgrace_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~optados.f90->sourcefile~core.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules xmgrace_utils Source Code xmgrace_utils.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! module xmgrace_utils ! use od_constants, only : dp implicit none public :: xmgu_setup public :: xmgu_legend public :: xmgu_title public :: xmgu_subtitle public :: xmgu_axis public :: xmgu_data public :: xmgu_data_header public :: xmgu_vertical_line !(unit,x_coord,y_max,y_min) private contains !==================================================================! subroutine xmgu_setup ( unit ) !==================================================================! use od_io , only : io_date implicit none integer , intent ( in ) :: unit character ( len = 9 ) :: ctime ! Temp. time string character ( len = 11 ) :: cdate ! Temp. date string call io_date ( cdate , ctime ) write ( unit , * ) '# Grace project file' write ( unit , * ) '# Autogenrated by OptaDOS on ' , cdate , ' at ' , ctime write ( unit , * ) '@version 50122' write ( unit , * ) '@page size 792, 612' write ( unit , * ) '@page scroll 5%' write ( unit , * ) '@page inout 5%' write ( unit , * ) '@link page off' write ( unit , * ) '@map font 0 to \"Times-Roman\", \"Times-Roman\"' write ( unit , * ) '@map font 1 to \"Times-Italic\", \"Times-Italic\"' write ( unit , * ) '@map font 2 to \"Times-Bold\", \"Times-Bold\"' write ( unit , * ) '@map font 3 to \"Times-BoldItalic\", \"Times-BoldItalic\"' write ( unit , * ) '@map font 4 to \"Helvetica\", \"Helvetica\"' write ( unit , * ) '@map font 5 to \"Helvetica-Oblique\", \"Helvetica-Oblique\"' write ( unit , * ) '@map font 6 to \"Helvetica-Bold\", \"Helvetica-Bold\"' write ( unit , * ) '@map font 7 to \"Helvetica-BoldOblique\", \"Helvetica-BoldOblique\"' write ( unit , * ) '@map font 8 to \"Courier\", \"Courier\"' write ( unit , * ) '@map font 9 to \"Courier-Oblique\", \"Courier-Oblique\"' write ( unit , * ) '@map font 10 to \"Courier-Bold\", \"Courier-Bold\"' write ( unit , * ) '@map font 11 to \"Courier-BoldOblique\", \"Courier-BoldOblique\"' write ( unit , * ) '@map font 12 to \"Symbol\", \"Symbol\"' write ( unit , * ) '@map font 13 to \"ZapfDingbats\", \"ZapfDingbats\"' write ( unit , * ) '@map color 0 to (255, 255, 255), \"white\"' write ( unit , * ) '@map color 1 to (0, 0, 0), \"black\"' write ( unit , * ) '@map color 2 to (255, 0, 0), \"red\"' write ( unit , * ) '@map color 3 to (0, 255, 0), \"green\"' write ( unit , * ) '@map color 4 to (0, 0, 255), \"blue\"' write ( unit , * ) '@map color 5 to (255, 255, 0), \"yellow\"' write ( unit , * ) '@map color 6 to (188, 143, 143), \"brown\"' write ( unit , * ) '@map color 7 to (220, 220, 220), \"grey\"' write ( unit , * ) '@map color 8 to (148, 0, 211), \"violet\"' write ( unit , * ) '@map color 9 to (0, 255, 255), \"cyan\"' write ( unit , * ) '@map color 10 to (255, 0, 255), \"magenta\"' write ( unit , * ) '@map color 11 to (255, 165, 0), \"orange\"' write ( unit , * ) '@map color 12 to (114, 33, 188), \"indigo\"' write ( unit , * ) '@map color 13 to (103, 7, 72), \"maroon\"' write ( unit , * ) '@map color 14 to (64, 224, 208), \"turquoise\"' write ( unit , * ) '@default linewidth 1.0' write ( unit , * ) '@default linestyle 1' write ( unit , * ) '@default color 1' write ( unit , * ) '@default pattern 1' write ( unit , * ) '@default font 0' write ( unit , * ) '@default char size 1.000000' write ( unit , * ) '@default symbol size 1.000000' write ( unit , * ) '@default sformat \"%.8g\"' write ( unit , * ) '@background color 0' write ( unit , * ) '@page background fill on' write ( unit , * ) '@g0 on' write ( unit , * ) '@g0 hidden false' write ( unit , * ) '@g0 type XY' write ( unit , * ) '@g0 stacked false' write ( unit , * ) '@g0 bar hgap 0.000000' write ( unit , * ) '@g0 fixedpoint off' write ( unit , * ) '@g0 fixedpoint type 0' write ( unit , * ) '@g0 fixedpoint xy 0.000000, 0.000000' write ( unit , * ) '@g0 fixedpoint format general general' write ( unit , * ) '@g0 fixedpoint prec 6, 6' !     write(unit,*) 'autoscale' !     write(unit,*) 'world xmin 0.0' !     write(unit,*) 'world xmax 1.0' !    write(unit,*) 'world ymax 0.1' !    write(unit,*) 'frame linestyle 1' !   write(unit,*) 'frame linewidth 2.5' !   write(unit,*) 'frame color 1' !   write(unit,*) 'frame pattern 1' !   write(unit,*) 'frame background color 0' !   write(unit,*) 'frame background pattern 0' !   write(unit,*) 'altxaxis  off' !   write(unit,*) 'altyaxis  off' end subroutine xmgu_setup !==================================================================! !==================================================================! subroutine xmgu_legend ( unit ) !==================================================================! implicit none integer , intent ( in ) :: unit write ( unit , * ) '@    legend on' write ( unit , * ) '@    legend loctype view' write ( unit , * ) '@    legend 0.85, 0.8' write ( unit , * ) '@    legend box color 1' write ( unit , * ) '@    legend box pattern 1' write ( unit , * ) '@    legend box linewidth 2.0' write ( unit , * ) '@    legend box linestyle 1' write ( unit , * ) '@    legend box fill color 0' write ( unit , * ) '@    legend box fill pattern 1' write ( unit , * ) '@    legend font 4' write ( unit , * ) '@    legend char size 1.000000' write ( unit , * ) '@    legend color 1' write ( unit , * ) '@    legend length 4' write ( unit , * ) '@    legend vgap 1' write ( unit , * ) '@    legend hgap 1' write ( unit , * ) '@    legend invert false' end subroutine xmgu_legend !==================================================================! !==================================================================! subroutine xmgu_title ( unit , min_x , max_x , min_y , max_y , title ) !==================================================================! use od_constants , only : dp implicit none integer , intent ( in ) :: unit character ( * ), intent ( in ) :: title real ( dp ), intent ( in ) :: min_x , max_x , min_y , max_y character ( 20 ) :: min_x_char , min_y_char , max_x_char , max_y_char write ( min_x_char , '(F20.6)' ) min_x write ( max_x_char , '(F20.6)' ) max_x write ( min_y_char , '(F20.6)' ) min_y write ( max_y_char , '(F20.6)' ) max_y min_x_char = trim ( adjustl (( min_x_char ))) max_x_char = trim ( adjustl (( max_x_char ))) min_y_char = trim ( adjustl (( min_y_char ))) max_y_char = trim ( adjustl (( max_y_char ))) write ( unit , * ) '    @with g0' write ( unit , * ) '@    world ' // trim ( min_x_char ) // ', ' // trim ( min_y_char )& & // ', ' // trim ( max_x_char ) // ', ' // trim ( max_y_char ) write ( unit , * ) '@    stack world 0, 0, 0, 0' write ( unit , * ) '@    znorm 1' write ( unit , * ) '@    view 0.150000, 0.150000, 1.150000, 0.850000' write ( unit , * ) '@    title \"' // trim ( title ) // '\"' write ( unit , * ) '@    title font 4' write ( unit , * ) '@    title size 1.500000' write ( unit , * ) '@    title color 1' ! write(unit,*) 'title \"'//trim(title)//'\"' ! write(unit,*) \"title font 4\" ! write(unit,*) \"title size 1.500000\" ! write(unit,*) \"title color 1\" end subroutine xmgu_title !==================================================================! !==================================================================! subroutine xmgu_subtitle ( unit , subtitle ) !==================================================================! implicit none integer , intent ( in ) :: unit character ( * ), intent ( in ) :: subtitle write ( unit , * ) '@    subtitle \"' // trim ( subtitle ) // '\"' write ( unit , * ) '@    subtitle font 4' write ( unit , * ) '@    subtitle size 1.000000' write ( unit , * ) '@    subtitle color 1' !   write(unit,*) 'subtitle '//trim(subtitle)//'\"' !   write(unit,*) \"subtitle font 4\" !   write(unit,*) \"subtitle size 1.000000\" !   write(unit,*) \"subtitle color 1\" end subroutine xmgu_subtitle !==================================================================! !==================================================================! subroutine xmgu_axis ( unit , axis , label ) !==================================================================! implicit none integer , intent ( in ) :: unit character ( * ), intent ( in ) :: label character ( * ), intent ( in ) :: axis character ( 5 ) :: axis_name if ( axis == \"x\" ) then axis_name = \"xaxis\" elseif ( axis == \"y\" ) then axis_name = \"yaxis\" end if write ( unit , * ) '@    ' // trim ( axis_name ) // ' on' write ( unit , * ) '@    ' // trim ( axis_name ) // ' type zero false' write ( unit , * ) '@    ' // trim ( axis_name ) // ' offset 0.000000 , 0.000000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar on' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar linestyle 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' bar linewidth 2.5' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label \"' // trim ( label ) // '\"' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label layout para' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label place auto' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label char size 1.000000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label font 4' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' label place normal' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick on' write ( unit , * ) '@ autoticks' !  write(unit,*)'@    '//trim(axis_name)//' tick major 10' !  write(unit,*)'@    '//trim(axis_name)//' tick minor ticks 1' !  write(unit,*)'@    '//trim(axis_name)//' tick default 6' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick place rounded true' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick in' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major size 1.000000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major linewidth 2.5' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major linestyle 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick major grid off' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor color 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor linewidth 2.5' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor linestyle 1' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor grid off' write ( unit , * ) '@    ' // trim ( axis_name ) // ' tick minor size 0.500000' write ( unit , * ) '@    ' // trim ( axis_name ) // ' ticklabel on' write ( unit , * ) '@    ' // trim ( axis_name ) // ' ticklabel format general' write ( unit , * ) '@    ' // trim ( axis_name ) // ' ticklabel font 4' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel prec 5' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel formula \"\"' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel append \"\"' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel prepend \"\"' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel angle 0' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel skip 0' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel stagger 0' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel place normal' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel offset auto' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel offset 0.000000 , 0.010000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel start type auto' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel start 0.000000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel stop type auto' ! 1write(unit,*)'@    '//trim(axis_name)//' ticklabel stop 0.000000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel char size 1.000000' ! write(unit,*)'@    '//trim(axis_name)//' ticklabel color 1' ! write(unit,*)'@    '//trim(axis_name)//' tick place both' ! write(unit,*)'@    '//trim(axis_name)//' tick spec type none' !    write(unit,*) trim(axis_name)//\" type zero true\" !    write(unit,*) trim(axis_name)//\" bar on\" !    write(unit,*) trim(axis_name)//\" bar color 1\" !    write(unit,*) trim(axis_name)//\" bar linestyle 1\" !    write(unit,*) trim(axis_name)//\" bar linewidth 2.5\" !    write(unit,*) trim(axis_name)//' label \"'//trim(label)//'\"' !    write(unit,*) trim(axis_name)//\" label layout para\" !    write(unit,*) trim(axis_name)//\" label place auto\" !    write(unit,*) trim(axis_name)//\" label char size 1.000000\" !    write(unit,*) trim(axis_name)//\" label font 4\" !    write(unit,*) trim(axis_name)//\" label color 1\" !    write(unit,*) trim(axis_name)//\" label place normal\" !    write(unit,*) trim(axis_name)//\" tick on\" !    write(unit,*) trim(axis_name)//\" tick major 0.2\" !    write(unit,*) trim(axis_name)//\" tick minor ticks 1\" !    write(unit,*) trim(axis_name)//\" tick default 6\" !    write(unit,*) trim(axis_name)//\" tick place rounded true\" !    write(unit,*) trim(axis_name)//\" tick in\" !    write(unit,*) trim(axis_name)//\" tick major size 1.000000\" !    write(unit,*) trim(axis_name)//\" tick major color 1\" !    write(unit,*) trim(axis_name)//\" tick major linewidth 2.5\" !    write(unit,*) trim(axis_name)//\" tick major linestyle 1\" !    write(unit,*) trim(axis_name)//\" tick major grid off\" !    write(unit,*) trim(axis_name)//\" tick minor color 1\" !    write(unit,*) trim(axis_name)//\" tick minor linewidth 2.5\" !    write(unit,*) trim(axis_name)//\" tick minor linestyle 1\" !    write(unit,*) trim(axis_name)//\" tick minor grid off\" !    write(unit,*) trim(axis_name)//\" tick minor size 0.500000\" !    write(unit,*) trim(axis_name)//\" ticklabel on\" !    write(unit,*) trim(axis_name)//\" ticklabel format general\" !    write(unit,*) trim(axis_name)//\" ticklabel prec 5\" !    write(unit,*) trim(axis_name)//\" ticklabel start type spec\" !    write(unit,*) trim(axis_name)//\" ticklabel start 0.200000\" !    write(unit,*) trim(axis_name)//\" ticklabel stop type spec\" !   write(unit,*) trim(axis_name)//\" ticklabel stop 0.800000\" !    write(unit,*) trim(axis_name)//\" ticklabel font 4\" end subroutine xmgu_axis !==================================================================! !==================================================================! subroutine xmgu_data ( unit , field , x_data , y_data ) !==================================================================! use od_constants , only : dp use od_io , only : io_error implicit none integer , intent ( in ) :: unit integer , intent ( in ) :: field character ( 4 ) :: char_field real ( dp ), intent ( in ) :: x_data (:) real ( dp ), intent ( in ) :: y_data (:) integer :: i write ( char_field , '(I4)' ) field char_field = trim ( \"s\" // adjustl ( char_field )) write ( unit , * ) '@target G0.' // trim ( char_field ) write ( unit , * ) '@type xy' if ( size ( x_data , 1 ) . ne . size ( y_data , 1 )) call io_error ( \"xmgu_data: x and y axes have different number of elements\" ) do i = 1 , size ( x_data , 1 ) write ( unit , * ) x_data ( i ), y_data ( i ) end do write ( unit , * ) \"&\" end subroutine xmgu_data !==================================================================! subroutine xmgu_data_header ( unit , field , colour , legend ) !==================================================================! integer , intent ( in ) :: unit integer , intent ( in ) :: field , colour character ( 4 ) :: char_field , char_colour character ( * ), intent ( in ) :: legend write ( char_field , '(I4)' ) field write ( char_colour , '(I4)' ) colour char_field = trim ( \"s\" // adjustl ( char_field )) write ( unit , * ) '@    ' // trim ( char_field ) // ' hidden false' write ( unit , * ) '@    ' // trim ( char_field ) // ' type xy' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol size 1.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol color ' // trim ( char_colour ) write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol fill color 2' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol fill pattern 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol linewidth 1.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol char 65' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol char font 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' symbol skip 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' line type 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' line linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' line linewidth 2.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' line color  ' // trim ( char_colour ) write ( unit , * ) '@    ' // trim ( char_field ) // ' line pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' baseline type 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' baseline off' write ( unit , * ) '@    ' // trim ( char_field ) // ' dropline off' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill type 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill rule 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill color 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' fill pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue off' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue type 2' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue char size 1.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue font 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue color 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue rot 0' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue format general' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue prec 3' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue prepend \"\"' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue append \"\"' write ( unit , * ) '@    ' // trim ( char_field ) // ' avalue offset 0.000000 , 0.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar on' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar place both' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar color 2' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar pattern 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar size 1.000000' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar linewidth 1.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser linewidth 1.0' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser linestyle 1' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser clip off' write ( unit , * ) '@    ' // trim ( char_field ) // ' errorbar riser clip length 0.100000' write ( unit , * ) '@    ' // trim ( char_field ) // ' legend \"' // trim ( legend ) // '\"' ! write(unit,*) trim(char_field)//\" hidden false\" ! write(unit,*) trim(char_field)//\" type xy\" ! write(unit,*) trim(char_field)//\" symbol 9\" ! write(unit,*) trim(char_field)//\" symbol size 1.000000\" ! write(unit,*) trim(char_field)//\" symbol color \"//trim(char_colour) ! write(unit,*) trim(char_field)//\" symbol pattern 1\" ! write(unit,*) trim(char_field)//\" symbol fill color 4\" ! write(unit,*) trim(char_field)//\" symbol fill pattern 1\" ! write(unit,*) trim(char_field)//\" symbol linewidth 1.5\" ! write(unit,*) trim(char_field)//\" symbol linestyle 1\" ! write(unit,*) trim(char_field)//\" symbol char 65\" ! write(unit,*) trim(char_field)//\" symbol char font 0\" ! write(unit,*) trim(char_field)//\" symbol skip 0\" ! write(unit,*) trim(char_field)//\" line type 0\" ! write(unit,*) trim(char_field)//\" line linestyle 1\" ! write(unit,*) trim(char_field)//\" lyine linewidth 1.0\" !s0 legend  \"\" !s0 avalue on !s0 avalue type 4 !s0 avalue char size 0.80000 !s0 avalue font 4 !s0 avalue color 1 !s0 avalue rot 0 !s0 avalue format general !s0 avalue prec 4 !s0 avalue prepend \"\" !s0 avalue append \"\" !s0 avalue offset 0.000000 , 0.01000 end subroutine xmgu_data_header !==================================================================! subroutine xmgu_vertical_line ( unit , x_coord , y_max , y_min ) !==================================================================! use od_constants , only : dp implicit none integer , intent ( in ) :: unit real ( dp ), intent ( in ) :: x_coord , y_max , y_min character ( 20 ) :: x_coord_char , y_max_char , y_min_char write ( x_coord_char , '(F20.6)' ) x_coord write ( y_max_char , '(F20.6)' ) y_max write ( y_min_char , '(F20.6)' ) y_min x_coord_char = trim ( adjustl (( x_coord_char ))) y_max_char = trim ( adjustl (( y_max_char ))) y_min_char = trim ( adjustl (( y_min_char ))) write ( unit , * ) '@with line' write ( unit , * ) '@    line on' write ( unit , * ) '@    line loctype world' write ( unit , * ) '@    line g0' write ( unit , * ) '@    line ' // trim ( x_coord_char ) // ', ' // trim ( y_min_char )& & // ', ' // trim ( x_coord_char ) // ', ' // trim ( y_max_char ) write ( unit , * ) '@    line linewidth 1.5' write ( unit , * ) '@    line linestyle 3' write ( unit , * ) '@    line color 2' write ( unit , * ) '@    line arrow 0' write ( unit , * ) '@    line arrow type 0' write ( unit , * ) '@    line arrow length 1.000000' write ( unit , * ) '@    line arrow layout 1.000000, 1.000000' write ( unit , * ) '@line def' end subroutine xmgu_vertical_line end module xmgrace_utils","tags":"","loc":"sourcefile/xmgrace_utils.f90.html"},{"title":"cell.f90 – OptaDOS","text":"This file depends on sourcefile~~cell.f90~~EfferentGraph sourcefile~cell.f90 cell.f90 sourcefile~constants.f90 constants.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~io.f90 io.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~comms.f90 comms.F90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~comms.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~cell.f90~~AfferentGraph sourcefile~cell.f90 cell.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~cell.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~optics.f90 optics.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~dos.f90 dos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~cell.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~dos.f90->sourcefile~parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_cell Source Code cell.f90 Source Code ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! Module: Cell                                                            ! ! For dealing with the real and reciprocal space cell                     ! !-------------------------------------------------------------------------! ! Modules used:  constants                                                ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! ! Described below                                                         ! !-------------------------------------------------------------------------! ! Necessary conditions:                                                   ! !-------------------------------------------------------------------------! ! Written by Andrew Morris (So far)                            11/10/2010 ! !=========================================================================! module od_cell use od_constants , only : dp use od_io , only : maxlen implicit none private !-------------------------------------------------------------------------! ! R E A L   S P A C E   V A R I A B L E S real ( kind = dp ), public , save :: real_lattice ( 1 : 3 , 1 : 3 ) real ( kind = dp ), public , save :: recip_lattice ( 1 : 3 , 1 : 3 ) real ( kind = dp ), public , save :: cell_volume !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! R E C I P R O C A L   S P A C E   V A R I A B L E S real ( kind = dp ), allocatable , public , save :: kpoint_r (:, :) real ( kind = dp ), allocatable , public , save :: kpoint_r_cart (:, :) real ( kind = dp ), allocatable , public , save :: kpoint_weight (:) integer , allocatable , public , save :: num_kpoints_on_node (:) integer , public , save :: nkpoints integer , public , save :: kpoint_grid_dim ( 3 ) !-------------------------------------------------------------------------! ! Symmetry Operations integer , public , save :: num_crystal_symmetry_operations real ( kind = dp ), allocatable , public , save :: crystal_symmetry_disps (:, :) real ( kind = dp ), allocatable , public , save :: crystal_symmetry_operations (:, :, :) ! Atom sites real ( kind = dp ), allocatable , public , save :: atoms_pos_frac (:, :, :) real ( kind = dp ), allocatable , public , save :: atoms_pos_cart (:, :, :) integer , allocatable , public , save :: atoms_species_num (:) character ( len = maxlen ), allocatable , public , save :: atoms_label (:) character ( len = 2 ), allocatable , public , save :: atoms_symbol (:) integer , public , save :: num_atoms integer , public , save :: num_species character ( len = maxlen ), allocatable , public , save :: atoms_label_tmp (:) ! Added for photoemission real ( kind = dp ), allocatable , public , save :: atoms_pos_cart_photo (:, :) !-------------------------------------------------------------------------! ! G L O B A L L Y   A V A I L A B L E   F U N C T I O N S public :: cell_find_MP_grid public :: cell_calc_lattice public :: cell_report_parameters public :: cell_get_atoms public :: cell_read_cell public :: cell_get_symmetry public :: cell_dist ! Added for photoemission public :: cell_get_real_lattice public :: cell_calc_kpoint_r_cart !-------------------------------------------------------------------------! contains !=========================================================================! subroutine cell_find_MP_grid ( kpoints , num_kpts , kpoint_grid_dim , kpoint_offset ) ! WARNING the kpoint_offset is only +/- the true kpoint offset. We need to ! do some more work to find out its sign ! A J Morris 29th September 2011 !=========================================================================! use od_io , only : io_error , stdout implicit none integer , intent ( out ) :: kpoint_grid_dim ( 1 : 3 ) integer , intent ( in ) :: num_kpts real ( kind = dp ), intent ( in ) :: kpoints ( 1 : 3 , 1 : num_kpts ) real ( kind = dp ), intent ( out ), optional :: kpoint_offset ( 1 : 3 ) real ( kind = dp ) :: kpoint_TR ( 1 : 3 , 1 : num_kpts * 2 ) real ( kind = dp ) :: unique_kpoints ( 1 : 3 , num_kpts * 2 ) integer :: nunique_kpoints , iunique_kpoints integer :: ikpt , idim , jkpt , i real ( kind = dp ) :: subtraction_tol , min_img , min_img2 real ( kind = dp ) :: min_img3 , image , min_img_tol integer :: iprint = 1 ! We can't use the global iprint as it's higher that this ! in the module heirarchy. ! Before time reversal symmetry we could any combintaion of kpoints !--------------------X------------- !                  0.25 ! We apply TR to make we have a complete set (and add periodic images) !------X------X------X------X------ !    -0.75  -0.25   0.25  0.75 ! ! In this case the answer is easy. The minimim image is 0.5. Hence the grid is ! 1/0.5 = 2x MP. ! However the fun comes when shifts are applied. In this case applying TR makes ! things more complicated. Consider the same grid with a +ve 0.05 shift. ! ! Now CASTEP had to give us more kpoints !------------------X------X------ !                0.20   0.70 ! ! We couldn't know that an offset had been applied so we appy TR and get !   -0.70     -0.20  0.30    0.80 !----X-X-----X-X----X-X----X-X---- !  -0.80  -0.30  0.20   0.70 ! ! Hence now the 1st minimum image is 0.10, double the offset !           the 2nd    \"      \"   is 0.40 !           the 3rd    \"      \"   is 0.50  the reciprocal of the MP grid ! One can now image the case where the offset is 3/(4n) where n is the MP grid number. ! in this case 3/8=0.375 !                 (shifted -0.75)  (shifted -0.25) !------------------------X-------------X------------------------- !                     -0.375        0.125 ! ! After TR !                           -0.125        0.375 !------------------------X-----X------X-----X-------------------- !                     -0.375        0.125 ! ! So these are all equally spaced so algorithm sees this like the first example, easy, 0.25. Hence ! grid is 1/0.25 = 4x MP. Wrong! ! ! This is a known bug -- and without having the symmetry ops, we can't build the shifted 2xMP grid to ! show that it is not a 4x MP.  AJM 15/9/2014 ! When two numbers are the same subtraction_tol = epsilon ( subtraction_tol ) !write(*,*) \"subtraction_tol=\", subtraction_tol ! When one number is larger than another one min_img_tol = 0.000001_dp if ( iprint > 3 ) then write ( stdout , * ) write ( stdout , * ) \"+----------------------------------------------------------------------------+\" write ( stdout , * ) \"                              MP grid finder \" write ( stdout , * ) write ( stdout , * ) \" Kpoints found:\" , num_kpts end if ! Add time reversal kpoint_TR ( 1 : 3 , 1 : num_kpts ) = kpoints ( 1 : 3 , 1 : num_kpts ) kpoint_TR ( 1 : 3 , num_kpts + 1 : num_kpts * 2 ) = - kpoints ( 1 : 3 , 1 : num_kpts ) ! Act on each dimension independently do idim = 1 , 3 ! Fold all kpoints between (-0.5,0.5] do ikpt = 1 , num_kpts * 2 kpoint_TR ( idim , ikpt ) = kpoint_TR ( idim , ikpt ) - floor ( kpoint_TR ( idim , ikpt ) + 0.5_dp ) end do end do unique_kpoints = 0.0_dp over_dim : do idim = 1 , 3 ! Make unique if ( iprint > 3 ) write ( stdout , * ) \" ----- Dimension \" , idim , \" -----\" nunique_kpoints = 1 unique_kpoints ( idim , 1 ) = kpoint_TR ( idim , 1 ) over_kpts : do ikpt = 2 , 2 * num_kpts do iunique_kpoints = 1 , nunique_kpoints if ( abs ( unique_kpoints ( idim , iunique_kpoints ) - kpoint_TR ( idim , ikpt )) . le . subtraction_tol ) then !We've seen this before cycle over_kpts end if end do ! If we ended up here then, this is new nunique_kpoints = nunique_kpoints + 1 if ( iprint > 3 ) write ( stdout , * ) \" ikpt= \" , ikpt , \"nunique_kpoints= \" , nunique_kpoints unique_kpoints ( idim , nunique_kpoints ) = kpoint_TR ( idim , ikpt ) end do over_kpts if ( iprint > 3 ) write ( stdout , * ) \" Number of unique kpoints:\" , nunique_kpoints ! write(*,*) \"------------------------ KPOINTS IN+TR+FOLDING+UNIQUE -----------\" ! do i=1,nunique_kpoints !    write(*,*) i, idim, unique_kpoints(idim,i) ! enddo ! write(*,*) \"-----------------------------------------------------------\" if ( iprint > 3 ) write ( stdout , * ) \" Looking for special cases for dimension:\" , idim ! Look at special cases. These are largely necessary because the general finder needs to get to ! second nearest neighbour before it can work correctly. Except in the case of if ( nunique_kpoints == 1 ) then ! There is only 1 k-point ! The shift is it's position (either 0 or 0.5) if ( present ( kpoint_offset )) kpoint_offset ( idim ) = unique_kpoints ( idim , 1 ) kpoint_grid_dim ( idim ) = 1 cycle over_dim elseif ( nunique_kpoints == 2 ) then min_img = abs ( unique_kpoints ( idim , 1 ) - unique_kpoints ( idim , 2 )) if ( abs ( min_img - 0.5_dp ) . le . min_img_tol ) then ! If the 1stMI is 0.5 then there are 2 k-points ! The shift is it's position (either 0 or 0.25) if ( present ( kpoint_offset )) kpoint_offset ( idim ) = unique_kpoints ( idim , 1 ) kpoint_grid_dim ( idim ) = 2 cycle over_dim else ! If the 1stMI .ne.0.5 then there is 1 kpoint ! It's offset is min_img/2 if ( present ( kpoint_offset )) kpoint_offset ( idim ) = min_img / 2 kpoint_grid_dim ( idim ) = 1 cycle over_dim end if elseif ( nunique_kpoints == 3 ) then ! This is the case of a MP3 grid with a point at Gamma !! AJM COMMENTED OUT AS A TEST AGAINST !! HEXAGONAL CELLS !      if(present(kpoint_offset)) kpoint_offset(idim)=0.0_dp !      kpoint_grid_dim(idim)=3 !      cycle over_dim continue end if if ( iprint > 3 ) write ( stdout , * ) \" Left the special-case kpoint finder for dimension:\" , idim if ( iprint > 3 ) write ( stdout , * ) \" Now trying to use the general solver...\" ! Get 1st, 2nd and 3rd minimum images ! Get 1st min image min_img = huge ( min_img ) do ikpt = 1 , nunique_kpoints do jkpt = ikpt + 1 , nunique_kpoints image = abs ( unique_kpoints ( idim , ikpt ) - unique_kpoints ( idim , jkpt )) if ( image < min_img ) min_img = image end do end do if ( abs ( min_img - huge ( min_img )) . le . subtraction_tol ) & & call io_error ( 'cell_find_MP_grid: Failed to find a 1st min image' ) ! Get 2nd min image min_img2 = huge ( min_img2 ) do ikpt = 1 , nunique_kpoints do jkpt = ikpt , nunique_kpoints image = abs ( unique_kpoints ( idim , ikpt ) - unique_kpoints ( idim , jkpt )) if (( image < min_img2 ) . and . image > min_img + min_img_tol ) min_img2 = image end do end do if ( abs ( min_img2 - huge ( min_img2 )) . le . subtraction_tol ) & & call io_error ( 'cell_find_MP_grid: Failed to find a 2nd min image' ) ! Get 3rd min image min_img3 = huge ( min_img3 ) do ikpt = 1 , nunique_kpoints do jkpt = ikpt , nunique_kpoints image = abs ( unique_kpoints ( idim , ikpt ) - unique_kpoints ( idim , jkpt )) if (( image < min_img3 ) . and . image > min_img2 + min_img_tol ) min_img3 = image end do end do if ( abs ( min_img3 - huge ( min_img3 )) . le . subtraction_tol ) then ! It's possible in CASTEP 6 and 7 to have 3 kpoints only for a 5 MP grid ! the specieal case solver then got confused. if ( abs ( 2.0_dp * min_img - min_img2 ) < min_img_tol ) then ! If 1stMI==2ndMI then 1/1stMP is the grid density and we're still ok. Carry on. ! we'll catch this scenario further down the code. if ( iprint > 3 ) write ( stdout , * ) \" Couldn't find a third minimum image, but since we don't think\" if ( iprint > 3 ) write ( stdout , * ) \" there's an offset, it looks like a\" , 1.0_dp / min_img , \" kpoint grid\" continue else call io_error ( 'cell_find_MP_grid: Failed to find a 3rd min image' ) end if end if if ( iprint > 3 ) then write ( stdout , * ) \" Min images for dimension:\" , idim write ( stdout , * ) \" 1st:\" , min_img write ( stdout , * ) \" 2nd:\" , min_img2 write ( stdout , * ) \" 3rd:\" , min_img3 write ( stdout , * ) \" 1st&#94;-1:\" , 1.0_dp / min_img end if if ( abs ( 2.0_dp * min_img - min_img2 ) < min_img_tol ) then ! If 1stMI==2ndMI then 1/1stMP is the grid density if ( present ( kpoint_offset )) kpoint_offset ( idim ) = 0.0_dp kpoint_grid_dim ( idim ) = int ( 1.0_dp / min_img ) ! WARNING could also have a shifted grid with a perfect shift 3/(4n) ! this would be a known bug else ! If 1stMI.ne.2ndMI then 1/3rdMP is the grid density ! and 1stMI/2 is the shift if ( present ( kpoint_offset )) kpoint_offset ( idim ) = min_img / 2.0_dp kpoint_grid_dim ( idim ) = int ( 1.0_dp / min_img3 ) end if end do over_dim if ( iprint > 3 ) write ( stdout , * ) \" Conclusion = kpoint_grid_dim: \" , kpoint_grid_dim ! if(present(kpoint_offset))  write(*,*) \"kpoint_offset= \",  kpoint_offset if ( iprint > 3 ) & & write ( stdout , * ) \"+----------------------------------------------------------------------------+\" end subroutine cell_find_MP_grid !=========================================================================! !=========================================================================! subroutine cell_get_symmetry !=========================================================================! ! Read in the cell symmetries                                             ! !-------------------------------------------------------------------------! ! Arguments: kpoints - an array of kpoints                                ! !            num_kpts - size of the kpoint array                          ! !-------------------------------------------------------------------------! ! Returns: kpint_grid_dim - the number of kpoints in each dimension       ! !-------------------------------------------------------------------------! ! Parent module variables used: None                                      ! !-------------------------------------------------------------------------! ! Modules used:  None                                                     ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! ! Described below                                                         ! !-------------------------------------------------------------------------! ! Necessary conditions: None !-------------------------------------------------------------------------- ! Known Worries: None !-------------------------------------------------------------------------! ! JRY, April 2011                                                         ! !=========================================================================! use od_comms , only : on_root , comms_bcast use od_io , only : filename_len , io_file_unit , seedname , io_error , stdout implicit none integer :: ierr , sym_file logical :: exists character ( filename_len ) :: sym_filename !check if we already have the symmetries if ( allocated ( crystal_symmetry_operations )) return sym_file = io_file_unit () sym_filename = trim ( seedname ) // \".sym\" if ( on_root ) inquire ( file = sym_filename , exist = exists ) call comms_bcast ( exists , 1 ) if (. not . exists ) then if ( on_root ) then write ( stdout , '(1x,78a)' ) '!--------------------------------- WARNING ----------------------------------!' write ( stdout , '(1x,78a)' ) '!                Symmetry Operations file (.sym) not found                   !' write ( stdout , '(1x,78a)' ) '!                       Proceeding without symmetry                          !' write ( stdout , '(1x,78a)' ) '!----------------------------------------------------------------------------!' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if num_crystal_symmetry_operations = 0 return end if if ( on_root ) then open ( unit = sym_file , file = sym_filename , form = 'unformatted' , err = 100 , status = 'old' ) read ( sym_file ) num_crystal_symmetry_operations if ( num_crystal_symmetry_operations > 0 ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_get_symmetry\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_get_symmetry\" ) read ( sym_file ) crystal_symmetry_operations read ( sym_file ) crystal_symmetry_disps end if end if call comms_bcast ( num_crystal_symmetry_operations , 1 ) if ( num_crystal_symmetry_operations > 0 ) then if (. not . on_root ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_get_symmetry\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_get_symmetry\" ) end if call comms_bcast ( crystal_symmetry_operations ( 1 , 1 , 1 ), 9 * num_crystal_symmetry_operations ) call comms_bcast ( crystal_symmetry_disps ( 1 , 1 ), 3 * num_crystal_symmetry_operations ) end if return 100 call io_error ( 'Error: Problem opening sym file in cell_get_symmetry' ) end subroutine cell_get_symmetry !=========================================================================! !=========================================================================! subroutine cell_read_cell !=========================================================================! use od_constants , only : bohr2ang use od_io , only : io_file_unit , io_error , seedname , maxlen use od_algorithms , only : utility_cart_to_frac , utility_frac_to_cart , utility_lowercase implicit none real ( kind = dp ), allocatable :: atoms_pos_frac_tmp (:, :) real ( kind = dp ), allocatable :: atoms_pos_cart_tmp (:, :) character ( len = 20 ) :: keyword integer :: in , in1 , in2 , ins , ine , loop , i , line_e , line_s , counter , tot_num_lines integer :: loop2 , max_sites , ierr , ic , num_lines , line_counter , in_unit logical :: found_e , found_s , frac character ( len = maxlen ) :: dummy character ( len = maxlen ), allocatable :: ctemp (:) !character(len=maxlen), allocatable :: atoms_label_tmp(:) logical :: lconvert character ( len = maxlen ), allocatable :: in_data (:) ! read in the cell file ! count the lines in_unit = io_file_unit () open ( in_unit , file = trim ( seedname ) // '-out.cell' , form = 'formatted' , status = 'old' , err = 101 ) num_lines = 0 ; tot_num_lines = 0 do read ( in_unit , '(a)' , iostat = ierr , err = 200 , end = 210 ) dummy dummy = adjustl ( dummy ) tot_num_lines = tot_num_lines + 1 if (. not . dummy ( 1 : 1 ) == '!' . and . . not . dummy ( 1 : 1 ) == '#' ) then if ( len ( trim ( dummy )) > 0 ) num_lines = num_lines + 1 end if end do 101 call io_error ( 'Error: Problem opening input file ' // trim ( seedname ) // '-out.cell' ) 200 call io_error ( 'Error: Problem reading input file ' // trim ( seedname ) // '-out.cell' ) 210 continue rewind ( in_unit ) ! now read in for real - ignoring comments allocate ( in_data ( num_lines ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating in_data in cell_get_atoms' ) line_counter = 0 do loop = 1 , tot_num_lines read ( in_unit , '(a)' , iostat = ierr , err = 200 ) dummy dummy = utility_lowercase ( dummy ) dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '!' . or . dummy ( 1 : 1 ) == '#' ) cycle if ( len ( trim ( dummy )) == 0 ) cycle line_counter = line_counter + 1 in1 = index ( dummy , '!' ) in2 = index ( dummy , '#' ) if ( in1 == 0 . and . in2 == 0 ) in_data ( line_counter ) = dummy if ( in1 == 0 . and . in2 > 0 ) in_data ( line_counter ) = dummy (: in2 - 1 ) if ( in2 == 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: in1 - 1 ) if ( in2 > 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: min ( in1 , in2 ) - 1 ) end do close ( in_unit ) ! let's look for the atoms block (remember everything is lower case) keyword = 'positions' found_s = . false . do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), '%block' ) if ( in == 0 . or . in > 1 ) cycle if ( index ( in_data ( loop ), 'frac' ) > 0 ) then frac = . true . elseif ( index ( in_data ( loop ), 'abs' ) > 0 ) then frac = . false . else cycle end if line_s = loop if ( found_s ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_s = . true . end do if ( frac ) then keyword = 'positions_frac' else keyword = 'positions_abs' end if found_e = . false . do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), '%endblock' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' but no %endblock' // trim ( keyword ) // ' in cell file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: %endblock' // trim ( keyword ) // ' comes before %block' // trim ( keyword ) // ' in input file' ) end if ! now we know where the atoms block is lconvert = . false . dummy = in_data ( line_s + 1 ) if ( index ( dummy , 'ang' ) . ne . 0 ) then lconvert = . false . line_s = line_s + 1 elseif ( index ( dummy , 'bohr' ) . ne . 0 ) then lconvert = . true . line_s = line_s + 1 end if num_atoms = line_e - 1 - ( line_s + 1 ) + 1 allocate ( atoms_pos_frac_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac_tmp in cell_get_atoms' ) allocate ( atoms_pos_cart_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_tmp in cell_get_atoms' ) allocate ( ctemp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating ctemp in cell_get_atoms' ) allocate ( atoms_label_tmp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label_tmp in cell_get_atoms' ) counter = 0 do loop = line_s + 1 , line_e - 1 dummy = in_data ( loop ) counter = counter + 1 if ( frac ) then read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_frac_tmp ( i , counter ), i = 1 , 3 ) else read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_cart_tmp ( i , counter ), i = 1 , 3 ) end if end do if ( lconvert ) then atoms_pos_cart_tmp = atoms_pos_cart_tmp * bohr2ang end if call cell_get_real_lattice if ( frac ) then do loop = 1 , num_atoms call utility_frac_to_cart ( atoms_pos_frac_tmp (:, loop ), atoms_pos_cart_tmp (:, loop ), real_lattice ) end do else do loop = 1 , num_atoms call utility_cart_to_frac ( atoms_pos_cart_tmp (:, loop ), atoms_pos_frac_tmp (:, loop ), recip_lattice ) end do end if ! Now we sort the data into the proper structures num_species = 1 ctemp ( 1 ) = atoms_label_tmp ( 1 ) do loop = 2 , num_atoms do loop2 = 1 , loop - 1 if ( trim ( atoms_label_tmp ( loop )) == trim ( atoms_label_tmp ( loop2 ))) exit if ( loop2 == loop - 1 ) then num_species = num_species + 1 ctemp ( num_species ) = atoms_label_tmp ( loop ) end if end do end do allocate ( atoms_species_num ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_species_num in cell_get_atoms' ) allocate ( atoms_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label in cell_get_atoms' ) allocate ( atoms_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_symbol in cell_get_atoms' ) atoms_species_num (:) = 0 do loop = 1 , num_species atoms_label ( loop ) = ctemp ( loop ) do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then atoms_species_num ( loop ) = atoms_species_num ( loop ) + 1 end if end do end do max_sites = maxval ( atoms_species_num ) allocate ( atoms_pos_frac ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac in cell_get_atoms' ) allocate ( atoms_pos_cart ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart in cell_get_atoms' ) allocate ( atoms_pos_cart_photo ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_photo in cell_get_atoms' ) ! Making a copy to use in the photo.f90 subroutine \"analyse_geometry\" atoms_pos_cart_photo = atoms_pos_cart_tmp do loop = 1 , num_species counter = 0 do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then counter = counter + 1 atoms_pos_frac (:, counter , loop ) = atoms_pos_frac_tmp (:, loop2 ) atoms_pos_cart (:, counter , loop ) = atoms_pos_cart_tmp (:, loop2 ) end if end do end do ! Strip any numeric characters from atoms_label to get atoms_symbol do loop = 1 , num_species atoms_symbol ( loop ) ( 1 : 2 ) = atoms_label ( loop ) ( 1 : 2 ) ic = ichar ( atoms_symbol ( loop ) ( 2 : 2 )) if (( ic . lt . ichar ( 'a' )) . or . ( ic . gt . ichar ( 'z' ))) & atoms_symbol ( loop ) ( 2 : 2 ) = ' ' end do ! let's look for the symmetry_ops block keyword = 'symmetry_ops' num_crystal_symmetry_operations = 0 found_s = . false . do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), '%block' ) if ( in == 0 . or . in > 1 ) cycle line_s = loop if ( found_s ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in out.cell file' ) end if found_s = . true . end do if ( found_s ) then found_e = . false . do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), '%endblock' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in out.cell file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' but no %endblock' // trim ( keyword ) // ' in out.cell file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: %endblock' // trim ( keyword ) // ' comes before %block' // trim ( keyword ) // ' in input file' ) end if ! now we know where the block is num_crystal_symmetry_operations = ( line_e - line_s - 1 ) / 4 if (( 4 * num_crystal_symmetry_operations ) /= ( line_e - line_s - 1 )) & call io_error ( 'Error: Something wrong with symmetry_ops block in -out.cell file' ) if ( num_crystal_symmetry_operations > 0 ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_read_cell\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_read_cell\" ) counter = 0 do loop = line_s + 1 , line_e - 1 , 4 dummy = in_data ( loop ) counter = counter + 1 dummy = in_data ( loop ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_operations ( 1 , 1 , counter ), & crystal_symmetry_operations ( 2 , 1 , counter ), crystal_symmetry_operations ( 3 , 1 , counter ) dummy = in_data ( loop + 1 ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_operations ( 1 , 2 , counter ), & crystal_symmetry_operations ( 2 , 2 , counter ), crystal_symmetry_operations ( 3 , 2 , counter ) dummy = in_data ( loop + 2 ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_operations ( 1 , 3 , counter ), & crystal_symmetry_operations ( 2 , 3 , counter ), crystal_symmetry_operations ( 3 , 3 , counter ) dummy = in_data ( loop + 3 ) read ( dummy , * , err = 240 , end = 240 ) crystal_symmetry_disps ( 1 , counter ), & crystal_symmetry_disps ( 2 , counter ), crystal_symmetry_disps ( 3 , counter ) end do end if else call io_error ( 'Error: Cannot find %block ' // trim ( keyword ) // ' in ' // trim ( seedname ) // '-out.cell' ) end if return 240 call io_error ( 'Error: Problem reading block keyword ' // trim ( keyword )) end subroutine cell_read_cell !=========================================================================! !=========================================================================! subroutine cell_get_atoms !=========================================================================! use od_constants , only : bohr2ang use od_io , only : io_file_unit , io_error , seedname , maxlen use od_algorithms , only : utility_cart_to_frac , utility_frac_to_cart , utility_lowercase implicit none real ( kind = dp ), allocatable :: atoms_pos_frac_tmp (:, :) real ( kind = dp ), allocatable :: atoms_pos_cart_tmp (:, :) character ( len = 20 ) :: keyword integer :: in , in1 , in2 , ins , ine , loop , i , line_e , line_s , counter , tot_num_lines integer :: loop2 , max_sites , ierr , ic , num_lines , line_counter , in_unit logical :: found_e , found_s , frac character ( len = maxlen ) :: dummy character ( len = maxlen ), allocatable :: ctemp (:) character ( len = maxlen ), allocatable :: atoms_label_tmp (:) logical :: lconvert character ( len = maxlen ), allocatable :: in_data (:) ! read in the cell file ! count the lines in_unit = io_file_unit () open ( in_unit , file = trim ( seedname ) // '.cell' , form = 'formatted' , status = 'old' , err = 101 ) num_lines = 0 ; tot_num_lines = 0 do read ( in_unit , '(a)' , iostat = ierr , err = 200 , end = 210 ) dummy dummy = adjustl ( dummy ) tot_num_lines = tot_num_lines + 1 if (. not . dummy ( 1 : 1 ) == '!' . and . . not . dummy ( 1 : 1 ) == '#' ) then if ( len ( trim ( dummy )) > 0 ) num_lines = num_lines + 1 end if end do 101 call io_error ( 'Error: Problem opening input file ' // trim ( seedname ) // '.cell' ) 200 call io_error ( 'Error: Problem reading input file ' // trim ( seedname ) // '.cell' ) 210 continue rewind ( in_unit ) ! now read in for real - ignoring comments allocate ( in_data ( num_lines ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating in_data in cell_get_atoms' ) line_counter = 0 do loop = 1 , tot_num_lines read ( in_unit , '(a)' , iostat = ierr , err = 200 ) dummy dummy = utility_lowercase ( dummy ) dummy = adjustl ( dummy ) if ( dummy ( 1 : 1 ) == '!' . or . dummy ( 1 : 1 ) == '#' ) cycle if ( len ( trim ( dummy )) == 0 ) cycle line_counter = line_counter + 1 in1 = index ( dummy , '!' ) in2 = index ( dummy , '#' ) if ( in1 == 0 . and . in2 == 0 ) in_data ( line_counter ) = dummy if ( in1 == 0 . and . in2 > 0 ) in_data ( line_counter ) = dummy (: in2 - 1 ) if ( in2 == 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: in1 - 1 ) if ( in2 > 0 . and . in1 > 0 ) in_data ( line_counter ) = dummy (: min ( in1 , in2 ) - 1 ) end do close ( in_unit ) ! let's look for the atoms block (remember everything is lower case) keyword = 'positions' found_s = . false . do loop = 1 , num_lines ins = index ( in_data ( loop ), trim ( keyword )) if ( ins == 0 ) cycle in = index ( in_data ( loop ), '%block' ) if ( in == 0 . or . in > 1 ) cycle if ( index ( in_data ( loop ), 'frac' ) > 0 ) then frac = . true . elseif ( index ( in_data ( loop ), 'abs' ) > 0 ) then frac = . false . else cycle end if line_s = loop if ( found_s ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_s = . true . end do if ( frac ) then keyword = 'positions_frac' else keyword = 'positions_abs' end if found_e = . false . do loop = 1 , num_lines ine = index ( in_data ( loop ), trim ( keyword )) if ( ine == 0 ) cycle in = index ( in_data ( loop ), '%endblock' ) if ( in == 0 . or . in > 1 ) cycle line_e = loop if ( found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' more than once in cell file' ) end if found_e = . true . end do if (. not . found_e ) then call io_error ( 'Error: Found %block' // trim ( keyword ) // ' but no %endblock' // trim ( keyword ) // ' in cell file' ) end if if ( line_e <= line_s ) then call io_error ( 'Error: %endblock' // trim ( keyword ) // ' comes before %block' // trim ( keyword ) // ' in input file' ) end if ! now we know where the atoms block is lconvert = . false . dummy = in_data ( line_s + 1 ) if ( index ( dummy , 'ang' ) . ne . 0 ) then lconvert = . false . line_s = line_s + 1 elseif ( index ( dummy , 'bohr' ) . ne . 0 ) then lconvert = . true . line_s = line_s + 1 end if num_atoms = line_e - 1 - ( line_s + 1 ) + 1 allocate ( atoms_pos_frac_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac_tmp in cell_get_atoms' ) allocate ( atoms_pos_cart_tmp ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_tmp in cell_get_atoms' ) allocate ( ctemp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating ctemp in cell_get_atoms' ) allocate ( atoms_label_tmp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label_tmp in cell_get_atoms' ) counter = 0 do loop = line_s + 1 , line_e - 1 dummy = in_data ( loop ) counter = counter + 1 if ( frac ) then read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_frac_tmp ( i , counter ), i = 1 , 3 ) else read ( dummy , * , err = 240 , end = 240 ) atoms_label_tmp ( counter ), ( atoms_pos_cart_tmp ( i , counter ), i = 1 , 3 ) end if end do if ( lconvert ) then atoms_pos_cart_tmp = atoms_pos_cart_tmp * bohr2ang end if call cell_get_real_lattice if ( frac ) then do loop = 1 , num_atoms call utility_frac_to_cart ( atoms_pos_frac_tmp (:, loop ), atoms_pos_cart_tmp (:, loop ), real_lattice ) end do else do loop = 1 , num_atoms call utility_cart_to_frac ( atoms_pos_cart_tmp (:, loop ), atoms_pos_frac_tmp (:, loop ), recip_lattice ) end do end if ! Now we sort the data into the proper structures num_species = 1 ctemp ( 1 ) = atoms_label_tmp ( 1 ) do loop = 2 , num_atoms do loop2 = 1 , loop - 1 if ( trim ( atoms_label_tmp ( loop )) == trim ( atoms_label_tmp ( loop2 ))) exit if ( loop2 == loop - 1 ) then num_species = num_species + 1 ctemp ( num_species ) = atoms_label_tmp ( loop ) end if end do end do allocate ( atoms_species_num ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_species_num in cell_get_atoms' ) allocate ( atoms_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label in cell_get_atoms' ) allocate ( atoms_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_symbol in cell_get_atoms' ) atoms_species_num (:) = 0 do loop = 1 , num_species atoms_label ( loop ) = ctemp ( loop ) do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then atoms_species_num ( loop ) = atoms_species_num ( loop ) + 1 end if end do end do max_sites = maxval ( atoms_species_num ) allocate ( atoms_pos_frac ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac in cell_get_atoms' ) allocate ( atoms_pos_cart ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart in cell_get_atoms' ) do loop = 1 , num_species counter = 0 do loop2 = 1 , num_atoms if ( trim ( atoms_label ( loop )) == trim ( atoms_label_tmp ( loop2 ))) then counter = counter + 1 atoms_pos_frac (:, counter , loop ) = atoms_pos_frac_tmp (:, loop2 ) atoms_pos_cart (:, counter , loop ) = atoms_pos_cart_tmp (:, loop2 ) end if end do end do ! Strip any numeric characters from atoms_label to get atoms_symbol do loop = 1 , num_species atoms_symbol ( loop ) ( 1 : 2 ) = atoms_label ( loop ) ( 1 : 2 ) ic = ichar ( atoms_symbol ( loop ) ( 2 : 2 )) if (( ic . lt . ichar ( 'a' )) . or . ( ic . gt . ichar ( 'z' ))) & atoms_symbol ( loop ) ( 2 : 2 ) = ' ' end do return 240 call io_error ( 'Error: Problem reading block keyword ' // trim ( keyword )) end subroutine cell_get_atoms !=========================================================================! subroutine cell_calc_lattice !=========================================================================! ! Begin with a real lattice. Convert from bohr. Calculate a reciprocal ! lattice and the volume of the cell !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables used: real_lattice, recip_lattice, cell_volume !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by Andrew Morris from the LinDOS program             11/10/2010 !========================================================================= use od_constants , only : pi , bohr2ang implicit none ! THESE ARE IN BOHR, DON'T GET TRIPPED UP AGAIN! real_lattice = real_lattice * bohr2ang call cell_get_real_lattice recip_lattice ( 1 , 1 ) = real_lattice ( 2 , 2 ) * real_lattice ( 3 , 3 ) - & real_lattice ( 3 , 2 ) * real_lattice ( 2 , 3 ) recip_lattice ( 2 , 1 ) = real_lattice ( 2 , 3 ) * real_lattice ( 3 , 1 ) - & real_lattice ( 3 , 3 ) * real_lattice ( 2 , 1 ) recip_lattice ( 3 , 1 ) = real_lattice ( 2 , 1 ) * real_lattice ( 3 , 2 ) - & real_lattice ( 3 , 1 ) * real_lattice ( 2 , 2 ) recip_lattice ( 1 , 2 ) = real_lattice ( 3 , 2 ) * real_lattice ( 1 , 3 ) - & real_lattice ( 1 , 2 ) * real_lattice ( 3 , 3 ) recip_lattice ( 2 , 2 ) = real_lattice ( 3 , 3 ) * real_lattice ( 1 , 1 ) - & real_lattice ( 1 , 3 ) * real_lattice ( 3 , 1 ) recip_lattice ( 3 , 2 ) = real_lattice ( 3 , 1 ) * real_lattice ( 1 , 2 ) - & real_lattice ( 1 , 1 ) * real_lattice ( 3 , 2 ) recip_lattice ( 1 , 3 ) = real_lattice ( 1 , 2 ) * real_lattice ( 2 , 3 ) - & real_lattice ( 2 , 2 ) * real_lattice ( 1 , 3 ) recip_lattice ( 2 , 3 ) = real_lattice ( 1 , 3 ) * real_lattice ( 2 , 1 ) - & real_lattice ( 2 , 3 ) * real_lattice ( 1 , 1 ) recip_lattice ( 3 , 3 ) = real_lattice ( 1 , 1 ) * real_lattice ( 2 , 2 ) - & real_lattice ( 2 , 1 ) * real_lattice ( 1 , 2 ) ! * Calculate cell volume cell_volume = real_lattice ( 1 , 1 ) * recip_lattice ( 1 , 1 ) + & real_lattice ( 2 , 1 ) * recip_lattice ( 1 , 2 ) + & real_lattice ( 3 , 1 ) * recip_lattice ( 1 , 3 ) if ( cell_volume < 0.0_dp ) then ! Left handed set cell_volume = - cell_volume end if ! Scale reciprocal lattice by 2*pi/volume recip_lattice (:, :) = recip_lattice (:, :) * pi * 2.0_dp / cell_volume end subroutine cell_calc_lattice !=========================================================================! subroutine cell_report_parameters !========================================================================= ! Begin with a real lattice. Convert from bohr. Calculate a reciprocal ! lattice and the volume of the cell !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables used: real_lattice, recip_lattice, cell_volume !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by J R Yates, modified A J Morris                     Dec 2010 !========================================================================= use od_io , only : stdout implicit none integer :: i write ( stdout , '(30x,a21)' ) 'Lattice Vectors (Ang)' write ( stdout , 101 ) 'a_1' , ( real_lattice ( 1 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'a_2' , ( real_lattice ( 2 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'a_3' , ( real_lattice ( 3 , I ), i = 1 , 3 ) write ( stdout , * ) write ( stdout , '(24x,a33)' ) 'Reciprocal-Space Vectors (Ang&#94;-1)' write ( stdout , 101 ) 'b_1' , ( recip_lattice ( 1 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'b_2' , ( recip_lattice ( 2 , I ), i = 1 , 3 ) write ( stdout , 101 ) 'b_3' , ( recip_lattice ( 3 , I ), i = 1 , 3 ) write ( stdout , * ) write ( stdout , '(19x,a17,3x,f11.5)' , advance = 'no' ) & 'Unit Cell Volume:' , cell_volume write ( stdout , '(2x,a7)' ) '(Ang&#94;3)' write ( stdout , * ) return 101 format ( 20 x , a3 , 2 x , 3 F11 . 6 ) end subroutine cell_report_parameters subroutine cell_dist use od_comms , only : comms_bcast , on_root use od_io , only : io_error implicit none integer :: max_sites , ierr call comms_bcast ( real_lattice ( 1 , 1 ), 9 ) call comms_bcast ( recip_lattice ( 1 , 1 ), 9 ) call comms_bcast ( cell_volume , 1 ) !call comms_bcast(kpoint_r(:,:) !call comms_bcast(kpoint_r_cart(:,:) !call comms_bcast(kpoint_weight(:) call comms_bcast ( nkpoints , 1 ) call comms_bcast ( kpoint_grid_dim ( 1 ), 3 ) !-------------------------------------------------------------------------! call comms_bcast ( num_atoms , 1 ) call comms_bcast ( num_species , 1 ) if ( num_atoms > 0 ) then if (. not . on_root ) then allocate ( atoms_species_num ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_species_num in cell_dist' ) end if call comms_bcast ( atoms_species_num ( 1 ), num_species ) max_sites = maxval ( atoms_species_num ) if (. not . on_root ) then allocate ( atoms_pos_frac ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_frac in cell_dist' ) allocate ( atoms_pos_cart ( 3 , max_sites , num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart in cell_dist' ) allocate ( atoms_label ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label in cell_dist' ) allocate ( atoms_symbol ( num_species ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_symbol in cell_dist' ) ! For Photoemission allocate ( atoms_pos_cart_photo ( 3 , num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_pos_cart_photo in cell_dist' ) allocate ( atoms_label_tmp ( num_atoms ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating atoms_label_tmp in cell_dist' ) end if call comms_bcast ( atoms_pos_frac ( 1 , 1 , 1 ), 3 * num_species * max_sites ) call comms_bcast ( atoms_pos_cart ( 1 , 1 , 1 ), 3 * num_species * max_sites ) call comms_bcast ( atoms_label ( 1 ), len ( atoms_label ( 1 )) * num_species ) call comms_bcast ( atoms_symbol ( 1 ), len ( atoms_symbol ( 1 )) * num_species ) ! For Photoemission call comms_bcast ( atoms_pos_cart_photo ( 1 , 1 ), 3 * num_atoms ) call comms_bcast ( atoms_label_tmp ( 1 ), maxlen * num_atoms ) end if call comms_bcast ( num_crystal_symmetry_operations , 1 ) if ( num_crystal_symmetry_operations > 0 ) then if (. not . on_root ) then allocate ( crystal_symmetry_operations ( 3 , 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_operations in cell_dist\" ) allocate ( crystal_symmetry_disps ( 3 , num_crystal_symmetry_operations ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate crystal_symmetry_disps in cell_dist\" ) end if call comms_bcast ( crystal_symmetry_operations ( 1 , 1 , 1 ), 3 * 3 * num_crystal_symmetry_operations ) call comms_bcast ( crystal_symmetry_disps ( 1 , 1 ), 3 * num_crystal_symmetry_operations ) end if end subroutine cell_dist !=========================================================================! subroutine cell_get_real_lattice !========================================================================= ! This subroutine reads the lattice parameters from the bands file in ! order to have them stored when the frac_to_cart and cart_frac subroutines ! are called. Independently of having used the elec_read_band_energy ! subroutine before. use od_comms , only : on_root use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time , & io_error use od_constants , only : bohr2ang integer :: band_unit character ( filename_len ) :: band_filename !Open the bands file band_unit = io_file_unit () band_filename = trim ( seedname ) // \".bands\" !    print*,'band_filename=',band_filename ! Read the header from the bands file if ( on_root ) then open ( unit = band_unit , file = band_filename , status = \"old\" , form = 'formatted' ) !,err=100) !100    call io_error('Error: Problem opening bands file in cell_get_real_lattice') read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) read ( band_unit , * ) real_lattice (:, 1 ) read ( band_unit , * ) real_lattice (:, 2 ) read ( band_unit , * ) real_lattice (:, 3 ) end if real_lattice = real_lattice * bohr2ang if ( on_root ) close ( unit = band_unit ) end subroutine cell_get_real_lattice !=========================================================================! subroutine cell_calc_kpoint_r_cart !========================================================================= ! This subroutine calculates the cartesian coordinates of the k points use od_algorithms , only : utility_reciprocal_frac_to_cart use od_comms , only : my_node_id use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time , & io_error !    use od_electronic, only : elec_read_band_energy integer :: i , ik , loop , ierr real ( kind = dp ), allocatable , dimension (:, :) :: kpoint_r_tmp real ( kind = dp ), allocatable , dimension (:, :) :: kpoint_r_cart_tmp allocate ( kpoint_r_tmp ( 3 , num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating kpoint_r_tmp in& &    cell_calc_kpoint_r_cart' ) allocate ( kpoint_r_cart_tmp ( 3 , num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating kpoint_r_cart_tmp in& &    cell_calc_kpoint_r_cart' ) kpoint_r_tmp = kpoint_r !This is to be sure that the k point fractional coordinates are stored. !If they are, the elec_read_band_energy will return. !    call elec_read_band_energy ! We will call this only if we have not read in the cell before. With a parallel build ! the non root nodes would not get the updated cell and perform another bohr2ang ! conversion. If I try to insert a comms_bcast in the cell_get_ ! F.Mildner 04/2023 if (. not . abs ( cell_volume ) . gt . 0.0_dp ) then call cell_get_real_lattice call cell_calc_lattice end if do loop = 1 , num_kpoints_on_node ( my_node_id ) call utility_reciprocal_frac_to_cart ( kpoint_r_tmp (:, loop ), kpoint_r_cart_tmp (:, loop ), recip_lattice ) !      print*,kpoint_r_tmp(1,loop),kpoint_r_tmp(2,loop),kpoint_r_tmp(3,loop),& !       kpoint_r_cart_tmp(1,loop),kpoint_r_cart_tmp(2,loop),kpoint_r_cart_tmp(3,loop) !print*,loop,kpoint_r_cart_tmp(:,loop),recip_lattice end do kpoint_r_cart = kpoint_r_cart_tmp !      do loop=1,num_kpoints_on_node(my_node_id) !      print*,kpoint_r_tmp(1,loop),kpoint_r_cart(1,loop),& !      kpoint_r_tmp(2,loop),kpoint_r_cart(2,loop),& !      kpoint_r_tmp(3,loop),kpoint_r_cart(3,loop) !      end do deallocate ( kpoint_r_tmp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: cell_calc_kpoint_r_cart - & &     failed to deallocate kpoint_r_tmp' ) deallocate ( kpoint_r_cart_tmp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: cell_calc_kpoint_r_cart - & &     failed to deallocate kpoint_r_cart_tmp' ) end subroutine cell_calc_kpoint_r_cart end module od_cell","tags":"","loc":"sourcefile/cell.f90.html"},{"title":"jdos_utils.f90 – OptaDOS","text":"This file depends on sourcefile~~jdos_utils.f90~~EfferentGraph sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~constants.f90 constants.f90 sourcefile~jdos_utils.f90->sourcefile~constants.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~io.f90 io.f90 sourcefile~jdos_utils.f90->sourcefile~io.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~comms.f90 comms.F90 sourcefile~jdos_utils.f90->sourcefile~comms.f90 sourcefile~cell.f90 cell.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~jdos_utils.f90~~AfferentGraph sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~optics.f90 optics.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~optados.f90->sourcefile~optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_jdos_utils Source Code jdos_utils.f90 Source Code ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=============================================================================== ! MODULE od_jdos  OptaDOS - Joint Density of States ! This is the module that contains all if the JDOS routines. It is used through ! the global jdos_calculate subroutine !------------------------------------------------------------------------------- ! NB. It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !=============================================================================== module od_jdos_utils use od_constants , only : dp implicit none !------------------------------------------------------------------------------- ! P U B L I C   V A R I A B L E S real ( kind = dp ), allocatable , public , save :: jdos_adaptive (:, :) real ( kind = dp ), allocatable , public , save :: jdos_fixed (:, :) real ( kind = dp ), allocatable , public , save :: jdos_linear (:, :) integer , save :: jdos_nbins real ( kind = dp ), allocatable , public , save :: E (:) !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! P U B L I C   F U N C T I O N S public :: jdos_utils_calculate public :: setup_energy_scale !------------------------------------------------------------------------------- real ( kind = dp ), save :: delta_bins ! Width of bins logical :: calc_weighted_jdos integer , allocatable , save :: vb_max (:) !------------------------------------------------------------------------------- contains !=============================================================================== subroutine jdos_utils_calculate ( matrix_weights , weighted_jdos ) !=============================================================================== ! Main routine in dos module, drives the calculation of Density of states for ! both task : dos and also if it is required elsewhere. !=============================================================================== use od_parameters , only : linear , fixed , adaptive , quad , iprint , dos_per_volume , photo ,& jdos_max_energy , jdos_spacing , photo use od_electronic , only : elec_read_band_gradient , band_gradient , nspins , electrons_per_state , & num_electrons , efermi_set use od_comms , only : on_root , comms_bcast use od_io , only : stdout , io_error , io_time , seedname use od_cell , only : cell_volume use od_dos_utils , only : dos_utils_set_efermi implicit none !integer :: ierr real ( kind = dp ) :: time0 , time1 real ( kind = dp ), intent ( out ), allocatable , optional :: weighted_jdos (:, :, :) !I've added this real ( kind = dp ), intent ( in ), optional :: matrix_weights (:, :, :, :, :) !I've added this calc_weighted_jdos = . false . if ( present ( matrix_weights )) calc_weighted_jdos = . true . if ( calc_weighted_jdos . eqv . . false .) then ! We are called just to provide jdos. if ( allocated ( E )) then if ( on_root . and . iprint > 1 ) write ( stdout , * ) \" Already calculated jdos, so returning...\" return ! The jdos has already been calculated previously so just return. end if end if !------------------------------------------------------------------------------- ! R E A D   B A N D   G R A D I E N T S ! If we're using one of the more accurate roadening schemes we also need to read in the ! band gradients too if ( quad . or . linear . or . adaptive ) then if (. not . allocated ( band_gradient )) call elec_read_band_gradient end if !------------------------------------------------------------------------------- if (. not . efermi_set ) call dos_utils_set_efermi !------------------------------------------------------------------------------- ! C A L C U L A T E   J D O S ! Now everything is set up, we can perform the dos accumulation in parellel time0 = io_time () call setup_energy_scale ( E ) if ( fixed ) then if ( calc_weighted_jdos ) then call calculate_jdos ( 'f' , jdos_fixed , matrix_weights , weighted_jdos = weighted_jdos ) call jdos_utils_merge ( jdos_fixed , weighted_jdos ) else call calculate_jdos ( 'f' , jdos_fixed ) call jdos_utils_merge ( jdos_fixed ) end if end if if ( adaptive ) then if ( calc_weighted_jdos ) then call calculate_jdos ( 'a' , jdos_adaptive , matrix_weights , weighted_jdos = weighted_jdos ) call jdos_utils_merge ( jdos_adaptive , weighted_jdos ) else call calculate_jdos ( 'a' , jdos_adaptive ) call jdos_utils_merge ( jdos_adaptive ) end if end if if ( linear ) then if ( calc_weighted_jdos ) then call calculate_jdos ( 'l' , jdos_linear , matrix_weights , weighted_jdos = weighted_jdos ) call jdos_utils_merge ( jdos_linear , weighted_jdos ) else call calculate_jdos ( 'l' , jdos_linear ) call jdos_utils_merge ( jdos_linear ) end if end if if ( quad ) then call io_error ( \"quadratic broadening not implemented\" ) !if(quad)    call merge_dos(dos_quad) !if(quad)    call merge_dos(intdos_quad) end if !    if(.not.on_root) then !       if(allocated(E)) deallocate(E, stat=ierr) !       if (ierr/=0) call io_error (\"cannot deallocate  E\") !    endif time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to calculate Joint Density of States              & &      ' , time1 - time0 , ' (sec) +' end if !------------------------------------------------------------------------------- if ( dos_per_volume ) then if ( photo ) then if ( fixed ) then jdos_fixed = jdos_fixed end if if ( adaptive ) then jdos_adaptive = jdos_adaptive end if if ( linear ) then jdos_linear = jdos_linear end if else if ( fixed ) then jdos_fixed = jdos_fixed / cell_volume end if if ( adaptive ) then jdos_adaptive = jdos_adaptive / cell_volume end if if ( linear ) then jdos_linear = jdos_linear / cell_volume end if end if ! if(quad) then !    dos_quad=dos_quad/cell_volume !    intdos_quad=intdos_quad/cell_volume ! endif end if end subroutine jdos_utils_calculate !=============================================================================== subroutine setup_energy_scale ( E ) !=============================================================================== ! Sets up all broadening independent DOS concerns ! Calls the relevant dos calculator. !=============================================================================== use od_dos_utils , only : dos_utils_calculate use od_parameters , only : jdos_max_energy , jdos_spacing , iprint use od_electronic , only : efermi , band_energy use od_comms , only : comms_reduce , comms_bcast , on_root use od_io , only : stdout , io_error implicit none integer :: idos , ierr real ( kind = dp ) :: max_band_energy real ( kind = dp ), intent ( out ), allocatable , optional :: E (:) if ( jdos_max_energy < 0.0_dp ) then ! we have to work it out ourselves max_band_energy = maxval ( band_energy ) call comms_reduce ( max_band_energy , 1 , 'MAX' ) call comms_bcast ( max_band_energy , 1 ) jdos_max_energy = efermi - max_band_energy if ( on_root . and . ( iprint > 2 )) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) & & '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) & & '|' , 'max_band_energy (before correction) : ' ,& & max_band_energy , \"<-- JDOS Grid |\" end if end if jdos_nbins = abs ( ceiling ( jdos_max_energy / jdos_spacing )) jdos_max_energy = jdos_nbins * jdos_spacing allocate ( E ( 1 : jdos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"Error: jdos_utils, setup_energy_scale: cannot allocate E\" ) delta_bins = jdos_max_energy / real ( jdos_nbins - 1 , dp ) do idos = 1 , jdos_nbins E ( idos ) = real ( idos - 1 , dp ) * delta_bins end do if ( on_root . and . ( iprint > 2 )) then write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'efermi : ' , efermi , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'jdos_max_energy : ' , jdos_max_energy , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,i11,13x,a15)' ) '|' , ' jdos_nbins : ' , jdos_nbins , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'jdos_spacing : ' , jdos_spacing , \"<-- JDOS Grid |\" write ( stdout , '(1x,a1,a38,f11.3,13x,a15)' ) '|' , 'delta_bins : ' , delta_bins , \"<-- JDOS Grid |\" write ( stdout , '(1x,a78)' ) & '+----------------------------------------------------------------------------+' end if end subroutine setup_energy_scale !=============================================================================== subroutine allocate_jdos ( jdos ) !=============================================================================== !=============================================================================== use od_electronic , only : nspins use od_io , only : io_error use od_parameters , only : photo implicit none real ( kind = dp ), allocatable , intent ( out ) :: jdos (:, :) integer :: ierr allocate ( jdos ( jdos_nbins , nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \"Error in allocating jdos (jdos_utils)\" ) jdos = 0.0_dp end subroutine allocate_jdos !=============================================================================== subroutine jdos_deallocate !=============================================================================== !=============================================================================== use od_io , only : io_error implicit none integer :: ierr if ( allocated ( jdos_adaptive )) then deallocate ( jdos_adaptive , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate jdos_adaptive' ) end if if ( allocated ( jdos_fixed )) then deallocate ( jdos_fixed , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate jdos_fixed' ) end if if ( allocated ( jdos_linear )) then deallocate ( jdos_linear , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate jdos_linear' ) end if if ( allocated ( E )) then deallocate ( E , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: jdos_deallocate - failed to deallocate E' ) end if end subroutine jdos_deallocate !=============================================================================== subroutine calculate_jdos ( jdos_type , jdos , matrix_weights , weighted_jdos ) !=============================================================================== !=============================================================================== use od_comms , only : my_node_id , on_root use od_cell , only : num_kpoints_on_node , kpoint_grid_dim , kpoint_weight ,& & recip_lattice use od_parameters , only : adaptive_smearing , fixed_smearing , iprint , photo , & finite_bin_correction , scissor_op , hybrid_linear_grad_tol , hybrid_linear , exclude_bands , num_exclude_bands , & photo_slab_max , photo_slab_min use od_io , only : io_error , stdout use od_electronic , only : band_gradient , nbands , band_energy , nspins , electrons_per_state , & & efermi , elec_pdos_read , pdos_weights , pdos_mwab , elec_dealloc_pdos use od_dos_utils , only : doslin , doslin_sub_cell_corners use od_algorithms , only : gaussian use od_constants , only : pi implicit none integer :: ik , is , ib , idos , jb , i integer :: N2 , N_geom , ierr real ( kind = dp ) :: dos_temp , cuml , width , adaptive_smearing_temp , mean_height real ( kind = dp ) :: grad ( 1 : 3 ), step ( 1 : 3 ), EV ( 0 : 4 ), sub_cell_length ( 1 : 3 ) character ( len = 1 ), intent ( in ) :: jdos_type real ( kind = dp ), intent ( inout ), allocatable , optional :: weighted_jdos (:, :, :) real ( kind = dp ), intent ( in ), optional :: matrix_weights (:, :, :, :, :) real ( kind = dp ), intent ( out ), allocatable :: jdos (:, :) logical :: linear , fixed , adaptive , force_adaptive linear = . false . fixed = . false . adaptive = . false . select case ( jdos_type ) case ( \"l\" ) linear = . true . case ( \"a\" ) adaptive = . true . case ( \"f\" ) fixed = . true . case default call io_error ( \" ERROR : unknown jdos_type in calculate_jdos \" ) end select width = 0.0_dp if ( linear . or . adaptive ) step (:) = 1.0_dp / real ( kpoint_grid_dim (:), dp ) / 2.0_dp if ( adaptive . or . hybrid_linear ) then do i = 1 , 3 sub_cell_length ( i ) = sqrt ( recip_lattice ( i , 1 ) ** 2 + recip_lattice ( i , 2 ) ** 2 + recip_lattice ( i , 3 ) ** 2 ) * step ( i ) end do if ( photo ) then mean_height = ( photo_slab_min + photo_slab_max ) / ( 2 * 2 ) sub_cell_length ( 3 ) = sqrt ( recip_lattice ( 3 , 1 ) ** 2 + recip_lattice ( 3 , 2 ) ** 2 + ( pi / mean_height ) ** 2 ) * step ( 3 ) end if adaptive_smearing_temp = adaptive_smearing * sum ( sub_cell_length ) / 3.0_dp end if if ( fixed ) width = fixed_smearing call allocate_jdos ( jdos ) if ( calc_weighted_jdos ) then N_geom = size ( matrix_weights , 5 ) allocate ( weighted_jdos ( jdos_nbins , nspins , N_geom ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: calculate_jdos - failed to allocate weighted_jdos' ) weighted_jdos = 0.0_dp end if if ( iprint > 1 . and . on_root ) then write ( stdout , '(1x,a78)' ) '+------------------------------ Calculate JDOS ------------------------------+' end if do ik = 1 , num_kpoints_on_node ( my_node_id ) if ( iprint > 1 . and . on_root ) then if ( mod ( real ( ik , dp ), 1 0.0_dp ) == 0.0_dp ) write ( stdout , '(1x,a1,a38,i4,a3,i4,1x,a14,3x,a10)' ) ',' , & & \"Calculating k-point \" , ik , \" of\" , num_kpoints_on_node ( my_node_id ), 'on this node.' , \"<-- JDOS |\" end if do is = 1 , nspins occ_states : do ib = 1 , nbands if ( num_exclude_bands > 0 ) then if ( any ( exclude_bands == ib )) cycle end if if ( band_energy ( ib , is , ik ) . ge . efermi ) cycle occ_states unocc_states : do jb = 1 , nbands if ( band_energy ( jb , is , ik ) . lt . efermi ) cycle unocc_states if ( linear . or . adaptive ) grad (:) = band_gradient ( jb , :, ik , is ) - band_gradient ( ib , :, ik , is ) ! If the band is very flat linear broadening can have problems describing it. In this case, fall back to ! adaptive smearing (and take advantage of FBCS if required). force_adaptive = . false . if (. not . fixed ) then if ( hybrid_linear . and . ( hybrid_linear_grad_tol > sqrt ( dot_product ( grad , grad )))) force_adaptive = . true . if ( linear . and . . not . force_adaptive ) call doslin_sub_cell_corners ( grad , step , band_energy ( jb , is , ik ) - & & band_energy ( ib , is , ik ) + scissor_op , EV ) if ( adaptive . or . force_adaptive ) width = sqrt ( dot_product ( grad , grad )) * adaptive_smearing_temp end if ! Hybrid Adaptive -- This way we don't lose weight at very flat parts of the ! band. It's a kind of fudge that we wouldn't need if we had infinitely small bins. if ( finite_bin_correction . and . ( width < delta_bins )) width = delta_bins do idos = 1 , jdos_nbins ! The linear method has a special way to calculate the integrated dos ! we have to take account for this here. if ( linear . and . . not . force_adaptive ) then dos_temp = doslin ( EV ( 0 ), EV ( 1 ), EV ( 2 ), EV ( 3 ), EV ( 4 ), E ( idos ), cuml ) else dos_temp = gaussian ( band_energy ( jb , is , ik ) - band_energy ( ib , is , ik ) + scissor_op , width , E ( idos )) !& end if jdos ( idos , is ) = jdos ( idos , is ) + dos_temp * electrons_per_state * kpoint_weight ( ik ) ! this will become a loop over final index (polarisation) ! Also need to remove kpoints weights. if ( calc_weighted_jdos ) then do N2 = 1 , N_geom weighted_jdos ( idos , is , N2 ) = weighted_jdos ( idos , is , N2 ) + dos_temp * matrix_weights ( ib , jb , ik , is , N2 )& & * electrons_per_state * kpoint_weight ( ik ) end do end if end do end do unocc_states end do occ_states end do end do if ( iprint > 1 . and . on_root ) then write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end if end subroutine calculate_jdos !=============================================================================== subroutine jdos_utils_merge ( jdos , weighted_jdos ) !=============================================================================== ! The DOS was calculated accross nodes. Now give them all back to root ! and free up the memeory on the slaves !------------------------------------------------------------------------------- ! Arguments: dos          (in - slaves) (inout -  root)       : The DOS !            weighted_dos (in - slaves) (inout -  root) (opt) : Weighted DOS !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_comms , only : comms_reduce use od_electronic , only : nspins use od_parameters , only : photo implicit none real ( kind = dp ), intent ( inout ), allocatable , optional :: weighted_jdos (:, :, :) ! bins.spins, orbitals real ( kind = dp ), allocatable , intent ( inout ) :: jdos (:, :) integer :: N_geom if ( present ( weighted_jdos )) N_geom = size ( weighted_jdos , 3 ) call comms_reduce ( jdos ( 1 , 1 ), nspins * jdos_nbins , \"SUM\" ) if ( present ( weighted_jdos )) call comms_reduce ( weighted_jdos ( 1 , 1 , 1 ), nspins * jdos_nbins * N_geom , \"SUM\" ) !    if(.not.on_root) then !       if(allocated(jdos)) deallocate(jdos,stat=ierr) !       if (ierr/=0) call io_error (\" ERROR : jdos : merge_jdos : cannot deallocate dos\") !       if(present(weighted_jdos))  then !          if(allocated(weighted_jdos)) deallocate(weighted_jdos,stat=ierr) !          if (ierr/=0) call io_error (\" ERROR : jdos : merge_jdos : cannot deallocate weighted_dos\") !       end if !    endif end subroutine jdos_utils_merge end module od_jdos_utils","tags":"","loc":"sourcefile/jdos_utils.f90.html"},{"title":"optics.f90 – OptaDOS","text":"This file depends on sourcefile~~optics.f90~~EfferentGraph sourcefile~optics.f90 optics.f90 sourcefile~constants.f90 constants.f90 sourcefile~optics.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~cell.f90 cell.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~comms.f90 comms.F90 sourcefile~optics.f90->sourcefile~comms.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~io.f90 io.f90 sourcefile~optics.f90->sourcefile~io.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~optics.f90->sourcefile~xmgrace_utils.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~constants.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~io.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~algorithms.f90->sourcefile~io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~optics.f90~~AfferentGraph sourcefile~optics.f90 optics.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~optics.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_optics Source Code optics.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=============================================================================== module od_optics use od_constants , only : dp , epsilon_0 , e_charge , e_mass , hbar , c_speed implicit none private public :: optics_calculate public :: make_weights public :: calc_epsilon_2 public :: calc_epsilon_1 public :: calc_conduct public :: calc_refract public :: calc_loss_fn public :: calc_absorp public :: calc_reflect public :: write_epsilon public :: write_conduct public :: write_refract public :: write_loss_fn public :: write_absorp public :: write_reflect type :: graph_labels character ( 40 ) :: name character ( 40 ) :: title character ( 20 ) :: x_label character ( 20 ) :: y_label character ( 20 ) :: legend_a character ( 20 ) :: legend_b character ( 20 ) :: legend_c character ( 20 ) :: legend_d end type graph_labels !  integer, parameter :: dp=selected_real_kind(15,300) real ( kind = dp ), allocatable , public , dimension (:, :, :, :, :) :: matrix_weights real ( kind = dp ), allocatable , public , dimension (:, :, :, :) :: dos_matrix_weights real ( kind = dp ), allocatable , public , dimension (:, :, :) :: weighted_jdos real ( kind = dp ), allocatable , public , dimension (:, :) :: weighted_dos_at_e real ( kind = dp ), allocatable , public , dimension (:, :) :: dos_at_e real ( kind = dp ), allocatable , public , dimension (:, :, :, :) :: epsilon real ( kind = dp ), allocatable , public , dimension (:, :) :: conduct real ( kind = dp ), allocatable , public , dimension (:, :) :: refract real ( kind = dp ), allocatable , public , dimension (:, :) :: loss_fn real ( kind = dp ), allocatable , public , dimension (:) :: absorp real ( kind = dp ), allocatable , public , dimension (:) :: reflect real ( kind = dp ), allocatable , public , dimension (:) :: intra real ( kind = dp ) :: q_weight real ( kind = dp ) :: N_eff real ( kind = dp ) :: N_eff2 real ( kind = dp ) :: N_eff3 integer :: N_geom real ( kind = dp ) :: e_fermi integer :: N integer :: N2 real ( kind = dp ) :: slab_volume contains subroutine optics_calculate ! !  Program to calculate optical properties ! use od_electronic , only : optical_mat , elec_read_optical_mat , nbands , nspins , & efermi , efermi_set , elec_dealloc_optical use od_cell , only : cell_volume , num_kpoints_on_node , kpoint_r , real_lattice use od_jdos_utils , only : jdos_utils_calculate use od_comms , only : on_root , my_node_id use od_parameters , only : optics_geom , adaptive , linear , fixed , optics_intraband , & optics_drude_broadening , photo_slab_min , photo_slab_max , devel_flag use od_dos_utils , only : dos_utils_calculate_at_e , dos_utils_set_efermi use od_io , only : stdout if ( on_root ) then write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                                Optics Calculation                          +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '|                                                                            |' end if if (. not . efermi_set ) call dos_utils_set_efermi ! Get information from .cst_ome file call elec_read_optical_mat ! Form matrix element call make_weights ( matrix_weights ) ! Send matrix element to jDOS routine and get weighted jDOS back call jdos_utils_calculate ( matrix_weights , weighted_jdos = weighted_jdos ) ! Calculate weighted DOS at Ef for intraband term if ( optics_intraband ) then allocate ( dos_matrix_weights ( size ( matrix_weights , 5 ), nbands , num_kpoints_on_node ( my_node_id ), nspins )) allocate ( dos_at_e ( 3 , nspins )) allocate ( weighted_dos_at_e ( nspins , size ( matrix_weights , 5 ))) weighted_dos_at_e = 0.0_dp do N = 1 , size ( matrix_weights , 5 ) do N2 = 1 , nbands dos_matrix_weights ( N , N2 , :, :) = matrix_weights ( N2 , N2 , :, :, N ) end do end do call dos_utils_calculate_at_e ( efermi , dos_at_e , dos_matrix_weights , weighted_dos_at_e ) end if call elec_dealloc_optical ! don't need this large array anymore if ( on_root ) then if ( index ( devel_flag , 'slab_volume' ) > 0 ) then slab_volume = ( cell_volume / real_lattice ( 3 , 3 )) * ( photo_slab_max - photo_slab_min ) ! Calculate epsilon_2 call calc_epsilon_2 ( weighted_jdos , weighted_dos_at_e , slab_volume ) else ! Calculate epsilon_2 call calc_epsilon_2 ( weighted_jdos , weighted_dos_at_e ) end if ! Calculate epsilon_1 call calc_epsilon_1 ! Calculate other optical properties if (. not . index ( optics_geom , 'tensor' ) > 0 ) then call calc_conduct call calc_refract call calc_loss_fn call calc_absorp call calc_reflect end if ! Write everything out if ( index ( devel_flag , 'slab_volume' ) > 0 ) then call write_epsilon ( atom = 0 , photo_volume = slab_volume ) else call write_epsilon ( 0 ) end if if (. not . index ( optics_geom , 'tensor' ) > 0 ) then call write_conduct call write_loss_fn if ( index ( devel_flag , 'slab_volume' ) > 0 ) then call write_refract ( atom = 0 , photo_volume = slab_volume ) call write_absorp ( atom = 0 , photo_volume = slab_volume ) call write_reflect ( atom = 0 , photo_volume = slab_volume ) else call write_refract ( 0 ) call write_absorp ( 0 ) call write_reflect ( 0 ) end if end if end if end subroutine optics_calculate ! Subroutines go here !*************************************************************** subroutine make_weights ( matrix_weights ) !*************************************************************** use od_constants , only : dp use od_electronic , only : nbands , nspins , optical_mat , num_electrons , & electrons_per_state , band_energy , efermi use od_cell , only : nkpoints , cell_volume , num_kpoints_on_node , cell_get_symmetry , & num_crystal_symmetry_operations , crystal_symmetry_operations , kpoint_r use od_parameters , only : optics_geom , optics_qdir , legacy_file_format , scissor_op , devel_flag use od_io , only : io_error , stdout use od_comms , only : my_node_id real ( kind = dp ), intent ( out ), allocatable , dimension (:, :, :, :, :) :: matrix_weights real ( kind = dp ), dimension ( 3 ) :: qdir real ( kind = dp ), dimension ( 3 ) :: qdir1 real ( kind = dp ), dimension ( 3 ) :: qdir2 real ( kind = dp ) :: q_weight1 real ( kind = dp ) :: q_weight2 integer :: N , i , j , k integer :: N_in integer :: N_spin integer :: N2 , N3 integer :: n_eigen integer :: n_eigen2 integer :: num_symm real ( kind = dp ), dimension ( 2 ) :: num_occ complex ( kind = dp ), dimension ( 3 ) :: g real ( kind = dp ) :: factor integer :: gamma_is , top_filled_band , upper_window , lower_window character ( len = 30 ) :: rowfmt logical :: print_omes print_omes = . false . ! Only set to true if you want the experiemental OME writing top_filled_band = 0 gamma_is = - 1 if (. not . legacy_file_format . and . index ( devel_flag , 'old_filename' ) > 0 ) then num_symm = 0 call cell_get_symmetry end if ! otherwise we have already set this num_symm = num_crystal_symmetry_operations !      Do N=1,num_symm !         Do N2=1,3 !            print *, crystal_symmetry_operations(1,N2,N), crystal_symmetry_operations(2,N2,N), crystal_symmetry_operations(3,N2,N) !         end do !         print *,'# ' !      end do num_occ = 0.0_dp do N_spin = 1 , nspins num_occ ( N_spin ) = num_electrons ( N_spin ) end do if ( electrons_per_state == 2 ) then num_occ ( 1 ) = num_occ ( 1 ) / 2.0_dp end if if (. not . index ( optics_geom , 'tensor' ) > 0 ) then ! I can rewrite this in a simplier way?? N_geom = 1 elseif ( index ( optics_geom , 'tensor' ) > 0 ) then N_geom = 6 end if allocate ( matrix_weights ( nbands , nbands , num_kpoints_on_node ( my_node_id ), nspins , N_geom )) matrix_weights = 0.0_dp if ( index ( optics_geom , 'polar' ) > 0 ) then qdir = optics_qdir q_weight = (( qdir ( 1 ) ** 2 ) + ( qdir ( 2 ) ** 2 ) + ( qdir ( 3 ) ** 2 )) ** 0.5_dp if ( q_weight < 0.001_dp ) & call io_error ( \"Error:  please check optics_qdir, norm close to zero\" ) end if if ( index ( optics_geom , 'unpolar' ) > 0 ) then if ( optics_qdir ( 3 ) == 0 ) then qdir1 ( 1 ) = 0.0_dp qdir1 ( 2 ) = 0.0_dp qdir1 ( 3 ) = 1.0_dp else qdir1 ( 1 ) = 1.0_dp qdir1 ( 2 ) = 1.0_dp qdir1 ( 3 ) = - ( optics_qdir ( 1 ) + optics_qdir ( 2 )) / optics_qdir ( 3 ) end if qdir2 ( 1 ) = ( optics_qdir ( 2 ) * qdir1 ( 3 )) - ( optics_qdir ( 3 ) * qdir1 ( 2 )) qdir2 ( 2 ) = ( optics_qdir ( 3 ) * qdir1 ( 1 )) - ( optics_qdir ( 1 ) * qdir1 ( 3 )) qdir2 ( 3 ) = ( optics_qdir ( 1 ) * qdir1 ( 2 )) - ( optics_qdir ( 2 ) * qdir1 ( 1 )) q_weight1 = (( qdir1 ( 1 ) ** 2 ) + ( qdir1 ( 2 ) ** 2 ) + ( qdir1 ( 3 ) ** 2 )) ** 0.5_dp q_weight2 = (( qdir2 ( 1 ) ** 2 ) + ( qdir2 ( 2 ) ** 2 ) + ( qdir2 ( 3 ) ** 2 )) ** 0.5_dp end if N_in = 1 ! 0 = no inversion, 1 = inversion g = 0.0_dp do N = 1 , num_kpoints_on_node ( my_node_id ) ! Loop over kpoints if ( print_omes ) then ! If .not. then hopefully the compiler will get rid of this at ! compile time, and there's no 'if' overhead. AJM May 2018 if (( kpoint_r ( 1 , N ) ** 2 + kpoint_r ( 2 , N ) ** 2 + kpoint_r ( 3 , N ) ** 2 ) < 0.01 ) then write ( stdout , * ) kpoint_r ( 1 , N ) ** 2 + kpoint_r ( 2 , N ) ** 2 + kpoint_r ( 3 , N ) ** 2 , \" = kpoint norm \" write ( stdout , * ) \" N= \" , N gamma_is = N end if end if do N_spin = 1 , nspins ! Loop over spins do n_eigen = 1 , nbands ! Loop over state 1 do n_eigen2 = n_eigen , nbands ! Loop over state 2 if ( band_energy ( n_eigen , N_spin , N ) > efermi . and . n_eigen /= n_eigen2 ) cycle if ( band_energy ( n_eigen2 , N_spin , N ) < efermi . and . n_eigen /= n_eigen2 ) cycle factor = 0.0_dp if ( n_eigen2 == n_eigen ) then factor = 1.0_dp elseif ( band_energy ( n_eigen2 , N_spin , N ) > efermi ) then factor = 1.0_dp / (( band_energy ( n_eigen2 , N_spin , N ) - band_energy ( n_eigen , N_spin , N ) & + scissor_op ) ** 2 ) end if if ( index ( optics_geom , 'unpolar' ) > 0 ) then if ( num_symm == 0 ) then g ( 1 ) = ((( qdir1 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir1 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir1 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight1 ) g ( 2 ) = ((( qdir2 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir2 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir2 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight2 ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & 0.5_dp * factor * ( real ( g ( 1 ) * conjg ( g ( 1 )), dp ) + real ( g ( 2 ) * conjg ( g ( 2 )), dp )) else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in do i = 1 , 3 qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * qdir1 ( j )) end do end do g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight1 ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & ( 0.5_dp / Real (( num_symm * ( N_in + 1 )), dp )) * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) * factor g ( 1 ) = 0.0_dp do i = 1 , 3 ! if I include an extra variable I can merge this and the last do loops qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * qdir2 ( j )) end do end do g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight2 ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & ( 0.5_dp / Real (( num_symm * ( N_in + 1 )), dp )) * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) * factor end do end do end if elseif ( index ( optics_geom , 'polar' ) > 0 ) then if ( num_symm == 0 ) then g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) !           matrix_weights(n_eigen,n_eigen2,N,N_spin) = 1.0_dp  ! for JDOS else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in do i = 1 , 3 qdir ( i ) = 0.0_dp do j = 1 , 3 qdir ( i ) = qdir ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * & ( crystal_symmetry_operations ( j , i , N2 ) * optics_qdir ( j )) end do end do g ( 1 ) = 0.0_dp g ( 1 ) = ((( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) / q_weight ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & ( 1.0_dp / Real (( num_symm * ( N_in + 1 )), dp )) * factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) end do end do end if elseif ( index ( optics_geom , 'poly' ) > 0 ) then if ( num_symm == 0 ) then do N2 = 1 , 3 g ( N2 ) = optical_mat ( n_eigen , n_eigen2 , N2 , N , N_spin ) !if (n_eigen==1) then !if (n_eigen2==NINT(num_occ(N_spin)+1)) then !print *, N, N2 !print *, g(N2), abs(g(N2)) !print *, optical_mat(n_eigen2,n_eigen,N2,N,N_spin) !print *, optical_mat(n_eigen,n_eigen,N2,N,N_spin), optical_mat(n_eigen2,n_eigen2,N2,N,N_spin) !end if !end if end do matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = ( factor / 3.0_dp ) * & & ( real ( g ( 1 ) * conjg ( g ( 1 )), dp ) + real ( g ( 2 ) * conjg ( g ( 2 )), dp ) + & & real ( g ( 3 ) * conjg ( g ( 3 )), dp )) ! write (*, *) matrix_weights(n_eigen, n_eigen2, N, N_spin, N_geom) !                 print *, n_eigen, n_eigen2, N, matrix_weights(n_eigen,n_eigen2,N,N_spin,N_geom) !                 print *, band_energy(n_eigen2,N_spin,N), band_energy(n_eigen,N_spin,N) else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in qdir = 0.0_dp qdir1 = 0.0_dp qdir2 = 0.0_dp do i = 1 , 3 qdir ( i ) = (( - 1.0_dp ) ** ( N3 + 1 )) * crystal_symmetry_operations ( 1 , i , N2 ) qdir1 ( i ) = (( - 1.0_dp ) ** ( N3 + 1 )) * crystal_symmetry_operations ( 2 , i , N2 ) qdir2 ( i ) = (( - 1.0_dp ) ** ( N3 + 1 )) * crystal_symmetry_operations ( 3 , i , N2 ) end do g = 0.0_dp g ( 1 ) = (( qdir ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) g ( 2 ) = (( qdir1 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir1 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir1 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) g ( 3 ) = (( qdir2 ( 1 ) * optical_mat ( n_eigen , n_eigen2 , 1 , N , N_spin )) + & ( qdir2 ( 2 ) * optical_mat ( n_eigen , n_eigen2 , 2 , N , N_spin )) + & ( qdir2 ( 3 ) * optical_mat ( n_eigen , n_eigen2 , 3 , N , N_spin ))) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) = & matrix_weights ( n_eigen , n_eigen2 , N , N_spin , N_geom ) + & &( 1.0_dp / Real (( num_symm * ( N_in + 1 )), dp )) * factor * (( real ( g ( 1 ) * conjg ( g ( 1 )), dp ) + & & real ( g ( 2 ) * conjg ( g ( 2 )), dp ) + real ( g ( 3 ) * conjg ( g ( 3 )), dp )) / 3.0_dp ) !        write(*,*) \"mw =\", matrix_weights end do end do end if elseif ( index ( optics_geom , 'tensor' ) > 0 ) then if ( num_symm == 0 ) then do N2 = 1 , 3 g ( N2 ) = optical_mat ( n_eigen , n_eigen2 , N2 , N , N_spin ) end do matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 1 ) = factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 2 ) = factor * real ( g ( 2 ) * conjg ( g ( 2 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 3 ) = factor * real ( g ( 3 ) * conjg ( g ( 3 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 4 ) = factor * real ( g ( 1 ) * conjg ( g ( 2 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 5 ) = factor * real ( g ( 1 ) * conjg ( g ( 3 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 6 ) = factor * real ( g ( 2 ) * conjg ( g ( 3 )), dp ) else do N2 = 1 , num_symm do N3 = 1 , 1 + N_in g = 0.0_dp do i = 1 , 3 do j = 1 , 3 g ( i ) = g ( i ) + (( - 1.0_dp ) ** ( N3 + 1 )) * ( crystal_symmetry_operations ( i , j , N2 ) & * optical_mat ( n_eigen , n_eigen2 , j , N , N_spin )) end do end do matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 1 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 1 ) + factor * real ( g ( 1 ) * conjg ( g ( 1 )), dp ) & & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 2 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 2 ) + factor * real ( g ( 2 ) * conjg ( g ( 2 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 3 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 3 ) + factor * real ( g ( 3 ) * conjg ( g ( 3 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 4 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 4 ) + factor * real ( g ( 1 ) * conjg ( g ( 2 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 5 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 5 ) + factor * real ( g ( 1 ) * conjg ( g ( 3 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) matrix_weights ( n_eigen , n_eigen2 , N , N_spin , 6 ) = matrix_weights ( n_eigen , n_eigen2 , & & N , N_spin , 6 ) + factor * real ( g ( 2 ) * conjg ( g ( 3 )), dp )& & / Real (( num_symm * ( N_in + 1 )), dp ) end do end do end if end if end do end do end do end do if ( print_omes ) then ! This seems to be a rare thing to want to be able to do. So at the moment, I've made it a hard ! coded decision.  If you want the OMEs you probably know what you're doing enough to set this ! I haven't thought about spin or MPI. I think it behaves ok with symmetry. ! The results I wanted were polycrystalline. ! AJM May 2018 ! Above, we have already looked to label the gamma point. That is, ! the kpoint number at gamma. The variable was set to -1. So if it ! hasn't been set -- we didn't find the gamma point. ! If we didn't find it -- then we're not going to get the OMEs ! at the Gamma point. It's a critical stop. if ( gamma_is < 0 ) stop \"Couldnt find the gamma point\" ! Run through all the bands and find the last one that isn't above the Fermi level. ! This is inventivly called the \"top filled band\" do i = 1 , nbands if ( band_energy ( i , 1 , gamma_is ) . ge . efermi ) then exit else top_filled_band = i end if end do ! Set these for the number of bands either side of the Fermi energy that you want the ! OMES for. upper_window = top_filled_band + 2 lower_window = top_filled_band - 25 ! write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , * ) ' + PRINT OUT SOME OPTICAL MATRIX ELEMENTS -- EASTER EGG CODE                  +' write ( stdout , * ) ' + Note that I wrote this for a specific purpose. I have documented it as best+' write ( stdout , * ) \" + I can, but you should fully understand what's happening before you use it  +\" write ( stdout , * ) \" + AJM May 2018 B'ham                                                         +\" write ( stdout , * ) \" + Top filled band is\" , top_filled_band write ( rowfmt , '(A,I4,A)' ) '(8x,' , upper_window - lower_window + 1 , '(3X,f8.5))' ! write(*,*) rowfmt ! For debugging write ( stdout , * ) kpoint_r ( gamma_is , :) write ( stdout , '(1x,a78)' ) '+============================================================================+' ! I haven't really thought about spins. So if you have a spin system, you get both an up and down spin ! OME do k = 1 , nspins write ( stdout , * ) '+ For spin channel' , k write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , FMT = rowfmt ) ( band_energy ( i , k , gamma_is ) - band_energy ( top_filled_band , k , gamma_is ), & & i = lower_window , upper_window ) write ( rowfmt , '(A,I4,A)' ) '(f8.5,' , upper_window - lower_window + 1 , '(3X,f8.5))' do i = lower_window , upper_window write ( stdout , FMT = rowfmt ) band_energy ( i , k , gamma_is ) - band_energy ( top_filled_band , k , gamma_is ), & & ( matrix_weights ( i , j , gamma_is , k , :), j = lower_window , upper_window ) end do end do write ( stdout , '(1x,a78)' ) '+============================================================================+' stop \" Completed generating the OMEs -- see the odo file\" end if end subroutine make_weights !*************************************************************** subroutine calc_epsilon_2 ( weighted_jdos , weighted_dos_at_e , photo_atom_volume ) !*************************************************************** ! This subroutine calculates epsilon_2 use od_constants , only : dp , pi use od_cell , only : nkpoints , cell_volume use od_electronic , only : nspins , electrons_per_state , nbands use od_jdos_utils , only : E , jdos_nbins use od_parameters , only : optics_intraband , optics_drude_broadening , photo , iprint use od_io , only : stdout use od_comms , only : on_root real ( kind = dp ), intent ( in ), allocatable , dimension (:, :, :) :: weighted_jdos real ( kind = dp ), intent ( in ), allocatable , dimension (:, :) :: weighted_dos_at_e real ( kind = dp ), intent ( in ), optional :: photo_atom_volume integer :: N_energy integer :: N integer :: N_spin integer :: N2 integer :: jdos_bin integer :: i , j real ( kind = dp ) :: dE real ( kind = dp ) :: x real ( kind = dp ) :: epsilon2_const dE = E ( 2 ) - E ( 1 ) if ( present ( photo_atom_volume )) then epsilon2_const = ( e_charge * pi * 1E-20 ) / ( photo_atom_volume * 1E-30 * epsilon_0 ) write ( stdout , '(1x,a33,1x,f15.8,3x,a25)' ) '+------------ Using atom_volume =' , photo_atom_volume , '------------------------+' else write ( stdout , '(1x,a78)' ) '+----------------------------- Using cell_volume ----------------------------+' epsilon2_const = ( e_charge * pi * 1E-20 ) / ( cell_volume * 1E-30 * epsilon_0 ) end if !epsilon2_const = (e_charge*pi*1E-20)/(cell_volume*1E-30*epsilon_0) if ( optics_intraband ) then allocate ( intra ( N_geom )) intra = 0.0_dp do N = 1 , N_geom do N_spin = 1 , nspins intra ( N ) = intra ( N ) + weighted_dos_at_e ( N_spin , N ) end do end do if ( present ( photo_atom_volume )) then write ( stdout , '(1x,a33,1x,f15.8,3x,a25)' ) '+------------ Using atom_volume =' , photo_atom_volume , '------------------------+' intra = intra * e_charge / ( photo_atom_volume * 1E-10 * epsilon_0 ) else write ( stdout , '(1x,a78)' ) '+----------------------------- Using cell_volume ----------------------------+' intra = intra * e_charge / ( cell_volume * 1E-10 * epsilon_0 ) end if ! intra = intra*e_charge/(cell_volume*1E-10*epsilon_0) end if if (. not . optics_intraband ) then allocate ( epsilon ( jdos_nbins , 2 , N_geom , 1 )) else allocate ( epsilon ( jdos_nbins , 2 , N_geom , 3 )) end if epsilon = 0.0_dp do N2 = 1 , N_geom do N_spin = 1 , nspins ! Loop over spins do N_energy = 2 , jdos_nbins epsilon ( N_energy , 2 , N2 , 1 ) = epsilon ( N_energy , 2 , N2 , 1 ) + & epsilon2_const * weighted_jdos ( N_energy , N_spin , N2 ) if ( optics_intraband ) then epsilon ( N_energy , 2 , N2 , 2 ) = epsilon ( N_energy , 2 , N2 , 2 ) + & &(( intra ( N2 ) * ( e_charge ** 2 ) * hbar * optics_drude_broadening ) & & / ((( E ( N_energy ) * e_charge ) ** 2 ) & & + (( optics_drude_broadening * hbar ) ** 2 ))) epsilon ( N_energy , 2 , N2 , 3 ) = epsilon ( N_energy , 2 , N2 , 3 ) + & & epsilon ( N_energy , 2 , N2 , 2 ) & & + epsilon ( N_energy , 2 , N2 , 1 ) * E ( N_energy ) * e_charge end if end do end do end do ! Sum rule if ( N_geom == 1 ) then x = 0.0_dp do N = 2 , jdos_nbins !! don't include 0eV as it makes in intraband case blow up (and should be zero otherwise) if (. not . optics_intraband ) then x = x + (( N * ( dE ** 2 ) * epsilon ( N , 2 , 1 , 1 )) / ( hbar ** 2 )) else x = x + (( N * ( dE ** 2 ) * epsilon ( N , 2 , 1 , 3 )) / (( hbar ** 2 ) * E ( N ) * e_charge )) end if end do if ( present ( photo_atom_volume )) then N_eff = ( x * e_mass * photo_atom_volume * 1E-30 * epsilon_0 * 2 ) / ( pi ) else write ( stdout , '(1x,a78)' ) '+----------------------------- Using cell_volume ----------------------------+' N_eff = ( x * e_mass * cell_volume * 1E-30 * epsilon_0 * 2 ) / ( pi ) end if ! N_eff = (x*e_mass*cell_volume*1E-30*epsilon_0*2)/(pi) end if end subroutine calc_epsilon_2 !*************************************************************** subroutine calc_epsilon_1 !*************************************************************** ! This subroutine uses kramers kronig to calculate epsilon_1 use od_constants , only : dp , pi use od_jdos_utils , only : E , jdos_nbins use od_parameters , only : optics_intraband , optics_drude_broadening , iprint use od_comms , only : on_root use od_io , only : stdout integer :: N_energy integer :: N_energy2 integer :: N2 real ( kind = dp ), allocatable , dimension (:) :: q real ( kind = dp ) :: energy1 real ( kind = dp ) :: energy2 real ( kind = dp ) :: dE integer :: i , jdos_bin , j dE = E ( 2 ) - E ( 1 ) if (. not . optics_intraband ) then allocate ( q ( 1 )) else allocate ( q ( 3 )) end if do N2 = 1 , N_geom do N_energy = 1 , jdos_nbins q = 0.0_dp do N_energy2 = 1 , jdos_nbins if ( N_energy2 . ne . N_energy ) then energy1 = E ( N_energy ) energy2 = E ( N_energy2 ) q ( 1 ) = q ( 1 ) + ((( energy2 * epsilon ( N_energy2 , 2 , N2 , 1 )) / (( energy2 ** 2 ) - ( energy1 ** 2 ))) * dE ) if ( optics_intraband ) then q ( 2 ) = q ( 2 ) + (( dE * epsilon ( N_energy2 , 2 , N2 , 2 )) / ((( energy2 ** 2 ) - ( energy1 ** 2 )) * e_charge )) q ( 3 ) = q ( 3 ) + (( dE * epsilon ( N_energy2 , 2 , N2 , 3 )) / ((( energy2 ** 2 ) - ( energy1 ** 2 )) * e_charge )) end if end if end do if ( N2 . le . 3 ) then epsilon ( N_energy , 1 , N2 , 1 ) = (( 2.0_dp / pi ) * q ( 1 )) + 1.0_dp else epsilon ( N_energy , 1 , N2 , 1 ) = (( 2.0_dp / pi ) * q ( 1 )) end if if ( optics_intraband ) then !             epsilon(N_energy,1,N2,2)=((2.0_dp/pi)*q(2))+1.0_dp  !! old KK method epsilon ( N_energy , 1 , N2 , 2 ) = 1.0_dp - ( intra ( N2 ) / (( E ( N_energy ) ** 2 ) & & + ((( optics_drude_broadening * hbar ) / e_charge ) ** 2 ))) !             epsilon(N_energy,1,N2,3)=((2.0_dp/pi)*q(3))+1.0_dp  !! old KK method epsilon ( N_energy , 1 , N2 , 3 ) = epsilon ( N_energy , 1 , N2 , 1 ) + epsilon ( N_energy , 1 , N2 , 2 ) - 1.0_dp end if end do end do end subroutine calc_epsilon_1 !*************************************************************** subroutine calc_loss_fn !*************************************************************** ! This subroutine calculates the loss function and the sum rules use od_constants , only : dp , cmplx_i , pi use od_jdos_utils , only : E , jdos_nbins use od_cell , only : cell_volume use od_parameters , only : optics_intraband , optics_lossfn_broadening , optics_lossfn_gaussian complex ( kind = dp ) :: g integer :: N_energy integer :: N_energy2 real ( kind = dp ) :: x real ( kind = dp ) :: dE if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then allocate ( loss_fn ( jdos_nbins , 2 )) else allocate ( loss_fn ( jdos_nbins , 1 )) end if else if ( optics_lossfn_broadening ) then allocate ( loss_fn ( jdos_nbins , 4 )) else allocate ( loss_fn ( jdos_nbins , 3 )) end if end if loss_fn = 0.0_dp dE = E ( 2 ) - E ( 1 ) g = ( 0.0_dp , 0.0_dp ) do N_energy = 1 , jdos_nbins g = epsilon ( N_energy , 1 , 1 , 1 ) + ( cmplx_i * epsilon ( N_energy , 2 , 1 , 1 )) loss_fn ( N_energy , 1 ) = - 1 * aimag ( 1.0_dp / g ) if ( optics_intraband ) then if ( N_energy == 1 ) then loss_fn ( 1 , 2 ) = 0.0_dp loss_fn ( 1 , 3 ) = 0.0_dp else g = epsilon ( N_energy , 1 , 1 , 2 ) + ( cmplx_i * epsilon ( N_energy , 2 , 1 , 2 ) / ( E ( N_energy ) * e_charge )) loss_fn ( N_energy , 2 ) = - 1 * aimag ( 1.0_dp / g ) g = epsilon ( N_energy , 1 , 1 , 3 ) + ( cmplx_i * epsilon ( N_energy , 2 , 1 , 3 ) / ( E ( N_energy ) * e_charge )) loss_fn ( N_energy , 3 ) = - 1 * aimag ( 1.0_dp / g ) end if end if end do ! Broadening if ( optics_lossfn_broadening ) then if (. not . optics_intraband ) then do N_energy = 1 , jdos_nbins ! Loop over energy do N_energy2 = 1 , jdos_nbins ! Turn each energy value into a function g = ((( 4.0_dp * log ( 2.0_dp )) / pi ) ** ( 0.5_dp )) * & & ( 1.0_dp / optics_lossfn_gaussian ) * exp ( - 4.0_dp * ( log ( 2.0_dp )) * & & ((( E ( N_energy2 ) - E ( N_energy )) / optics_lossfn_gaussian ) ** 2.0_dp )) ! Gaussian loss_fn ( N_energy2 , 2 ) = loss_fn ( N_energy2 , 2 ) + ( g * loss_fn ( N_energy , 1 ) * dE ) end do end do ! End loop over energy end if if ( optics_intraband ) then do N_energy = 1 , jdos_nbins ! Loop over energy do N_energy2 = 1 , jdos_nbins ! Turn each energy value into a function g = ((( 4.0_dp * log ( 2.0_dp )) / pi ) ** ( 0.5_dp )) * & & ( 1.0_dp / optics_lossfn_gaussian ) * exp ( - 4.0_dp * ( log ( 2.0_dp )) * & & ((( E ( N_energy2 ) - E ( N_energy )) / optics_lossfn_gaussian ) ** 2.0_dp )) ! Gaussian loss_fn ( N_energy2 , 4 ) = loss_fn ( N_energy2 , 4 ) + ( g * loss_fn ( N_energy , 3 ) * dE ) end do end do ! End loop over energy end if end if ! Sum rule 1 x = 0.0_dp do N_energy = 2 , jdos_nbins if (. not . optics_intraband ) then x = x + ( N_energy * ( dE ** 2 ) * loss_fn ( N_energy , 1 )) else x = x + ( N_energy * ( dE ** 2 ) * loss_fn ( N_energy , 3 )) end if end do N_eff2 = x * ( e_mass * cell_volume * 1E-30 * epsilon_0 * 2 ) / ( pi * ( hbar ** 2 )) ! Sum rule 2 x = 0 do N_energy = 2 , jdos_nbins if (. not . optics_intraband ) then x = x + ( loss_fn ( N_energy , 1 ) / N_energy ) else x = x + ( loss_fn ( N_energy , 3 ) / N_energy ) end if end do N_eff3 = x end subroutine calc_loss_fn !*************************************************************** subroutine calc_conduct !*************************************************************** ! This subroutine calculates the conductivity use od_jdos_utils , only : jdos_nbins , E use od_parameters , only : optics_intraband integer :: N_energy allocate ( conduct ( 1 : jdos_nbins , 2 )) conduct = 0.0_dp if (. not . optics_intraband ) then do N_energy = 1 , jdos_nbins conduct ( N_energy , 1 ) = ( E ( N_energy ) * e_charge / hbar ) * epsilon_0 * epsilon ( N_energy , 2 , 1 , 1 ) end do do N_energy = 1 , jdos_nbins conduct ( N_energy , 2 ) = ( E ( N_energy ) * e_charge / hbar ) * epsilon_0 * ( 1.0_dp - epsilon ( N_energy , 1 , 1 , 1 )) end do else do N_energy = 1 , jdos_nbins conduct ( N_energy , 1 ) = epsilon_0 * epsilon ( N_energy , 2 , 1 , 3 ) / hbar end do do N_energy = 1 , jdos_nbins conduct ( N_energy , 2 ) = ( E ( N_energy ) * e_charge / hbar ) * epsilon_0 * ( 1.0_dp - epsilon ( N_energy , 1 , 1 , 3 )) end do end if end subroutine calc_conduct !*************************************************************** subroutine calc_refract !*************************************************************** ! This subroutine calculates the refractive index use od_jdos_utils , only : jdos_nbins , E use od_parameters , only : optics_intraband integer :: N_energy allocate ( refract ( jdos_nbins , 2 )) refract = 0.0_dp if (. not . optics_intraband ) then do N_energy = 1 , jdos_nbins refract ( N_energy , 1 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 1 ) ** 2 ) + & &( epsilon ( N_energy , 2 , 1 , 1 ) ** 2 )) ** 0.5_dp ) + epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do do N_energy = 1 , jdos_nbins refract ( N_energy , 2 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 1 ) ** 2 ) + & &( epsilon ( N_energy , 2 , 1 , 1 ) ** 2 )) ** 0.5_dp ) - epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do else do N_energy = 2 , jdos_nbins refract ( N_energy , 1 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 3 ) ** 2 ) + & &(( epsilon ( N_energy , 2 , 1 , 3 ) / ( E ( N_energy ) * e_charge )) ** 2 )) ** 0.5_dp ) + epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do do N_energy = 2 , jdos_nbins refract ( N_energy , 2 ) = ( 0.5_dp * (((( epsilon ( N_energy , 1 , 1 , 1 ) ** 2 ) + & &(( epsilon ( N_energy , 2 , 1 , 3 ) / ( E ( N_energy ) * e_charge )) ** 2 )) ** 0.5_dp ) - epsilon ( N_energy , 1 , 1 , 1 ))) ** ( 0.5_dp ) end do end if end subroutine calc_refract !*************************************************************** subroutine calc_absorp !*************************************************************** ! This subroutine calculates the absorption coefficient use od_jdos_utils , only : jdos_nbins , E integer :: N_energy allocate ( absorp ( jdos_nbins )) absorp = 0.0_dp do N_energy = 1 , jdos_nbins absorp ( N_energy ) = 2 * refract ( N_energy , 2 ) * E ( N_energy ) * e_charge / ( hbar * c_speed ) end do end subroutine calc_absorp !*************************************************************** subroutine calc_reflect !*************************************************************** ! This subroutine calculates the reflection coefficient use od_jdos_utils , only : E , jdos_nbins integer :: N_energy allocate ( reflect ( jdos_nbins )) reflect = 0.0_dp do N_energy = 1 , jdos_nbins reflect ( N_energy ) = ((( refract ( N_energy , 1 ) - 1 ) ** 2 ) + ( refract ( N_energy , 2 ) ** 2 )) / & &((( refract ( N_energy , 1 ) + 1 ) ** 2 ) + ( refract ( N_energy , 2 ) ** 2 )) end do end subroutine calc_reflect !*************************************************************** subroutine write_epsilon ( atom , photo_at_e , photo_volume ) !*************************************************************** ! This subroutine writes out the dielectric function use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , & & output_format , fixed , adaptive , linear , optics_intraband use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : E , jdos_nbins use od_io , only : seedname , io_file_unit , stdout integer :: N , N2 , N3 real ( kind = dp ) :: dE integer :: epsilon_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), dimension (:, :), optional :: photo_at_e real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"epsilon_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"epsilon\" end if label % title = \"Dielectric Function\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"Real\" label % legend_b = \"Imaginary\" dE = E ( 2 ) - E ( 1 ) ! Open the output file epsilon_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = epsilon_unit , action = 'write' , file = trim ( seedname ) // '_epsilon_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = epsilon_unit , action = 'write' , file = trim ( seedname ) // '_epsilon.dat' ) end if ! Write into the output file write ( epsilon_unit , * ) '#*********************************************' write ( epsilon_unit , * ) '#            Dielectric function                 ' write ( epsilon_unit , * ) '#*********************************************' write ( epsilon_unit , * ) '#' write ( epsilon_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( epsilon_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( epsilon_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( epsilon_unit , * ) '# Number of bands:' , nbands if ( present ( photo_volume )) then write ( epsilon_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( epsilon_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( epsilon_unit , * ) '#' write ( epsilon_unit , '(1x,a,f10.6,1x,a,f10.6,1x,a)' ) & & '# Dielectric function calculated to' , jdos_max_energy , 'eV in' , dE , 'eV steps' write ( epsilon_unit , * ) '#' write ( epsilon_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( epsilon_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , & & optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( epsilon_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( epsilon_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( epsilon_unit , * ) '#' if ( optics_intraband ) then write ( epsilon_unit , * ) '# Calculation includes intraband term' if ( present ( photo_at_e )) then if ( fixed ) write ( epsilon_unit , * ) '# DOS at Ef:' , photo_at_e ( 1 , :) if ( adaptive ) write ( epsilon_unit , * ) '# DOS at Ef:' , photo_at_e ( 2 , :) if ( linear ) write ( epsilon_unit , * ) '# DOS at Ef:' , photo_at_e ( 3 , :) else if ( fixed ) write ( epsilon_unit , * ) '# DOS at Ef:' , dos_at_e ( 1 , :) if ( adaptive ) write ( epsilon_unit , * ) '# DOS at Ef:' , dos_at_e ( 2 , :) if ( linear ) write ( epsilon_unit , * ) '# DOS at Ef:' , dos_at_e ( 3 , :) end if do N = 1 , N_geom write ( epsilon_unit , * ) '# Plasmon energy:' , ( intra ( N ) ** 0.5 ) end do end if if ( N_geom == 1 ) then write ( epsilon_unit , * ) '# Result of sum rule: Neff(E) =  ' , N_eff write ( epsilon_unit , * ) '#' if (. not . optics_intraband ) then do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), ',' , epsilon ( N , 1 , 1 , 1 ), ',' , epsilon ( N , 2 , 1 , 1 ) end do else write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), ',' , epsilon ( N , 1 , 1 , 1 ), ',' , epsilon ( N , 2 , 1 , 1 ) end do do N2 = 2 , 3 write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' do N = 2 , jdos_nbins write ( epsilon_unit , * ) E ( N ), ',' , epsilon ( N , 1 , 1 , N2 ), ',' , epsilon ( N , 2 , 1 , N2 ) / ( E ( N ) * e_charge ) end do end do end if if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , epsilon (:, 1 , 1 , 1 ), epsilon (:, 2 , 1 , 1 )) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , epsilon (:, 1 , 1 , 1 ), epsilon (:, 2 , 1 , 1 )) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end if if ( index ( optics_geom , 'tensor' ) > 0 ) then write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' do N2 = 1 , N_geom write ( epsilon_unit , * ) '# Component ' , N2 write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' if (. not . optics_intraband ) then do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), epsilon ( N , 1 , N2 , 1 ), epsilon ( N , 2 , N2 , 1 ) end do else do N3 = 1 , 3 do N = 1 , jdos_nbins write ( epsilon_unit , * ) E ( N ), epsilon ( N , 1 , N2 , N3 ), epsilon ( N , 2 , N2 , N3 ) end do write ( epsilon_unit , * ) '' write ( epsilon_unit , * ) '' end do end if ! I don't think we want to plot in the tensor case, so this is commented out (it's broke anyhow!) jry !!$          label%name=\"epsilon\"//trim(achar(N2)) !!$          if(trim(output_format)==\"xmgrace\") then !!$             call write_optics_xmgrace(label,E,epsilon(:,1,N2,1),epsilon(:,2,N2,1)) !!$          elseif(trim(output_format)==\"gnuplot\") then !!$             write(stdout,*)  \" WARNING: GNUPLOT output not yet available, continuing...\" !!$          else !!$             write(stdout,*)  \" WARNING: Unknown output format requested, continuing...\" !!$          endif end do end if ! Close output file close ( unit = epsilon_unit ) end subroutine write_epsilon !*************************************************************** subroutine write_loss_fn !*************************************************************** ! This subroutine writes out the loss function use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format , & optics_intraband , optics_lossfn_broadening use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N , N2 integer :: loss_fn_unit type ( graph_labels ) :: label label % name = \"loss_fn\" label % title = \"Loss Function\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then label % legend_a = \"\" label % legend_b = \"Broadened\" else label % legend_a = \"\" end if else if ( optics_lossfn_broadening ) then label % legend_a = \"Interband\" label % legend_b = \"Intraband\" label % legend_c = \"Total\" label % legend_d = \"Broadened\" else label % legend_a = \"Interband\" label % legend_b = \"Intraband\" label % legend_c = \"Total\" end if end if ! Open the output file loss_fn_unit = io_file_unit () open ( unit = loss_fn_unit , action = 'write' , file = trim ( seedname ) // '_loss_fn.dat' ) ! Write into the output file write ( loss_fn_unit , * ) '#*********************************************' write ( loss_fn_unit , * ) '#               Loss function                 ' write ( loss_fn_unit , * ) '#*********************************************' write ( loss_fn_unit , * ) '#' write ( loss_fn_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( loss_fn_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( loss_fn_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( loss_fn_unit , * ) '# No of bands:' , nbands write ( loss_fn_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume write ( loss_fn_unit , * ) '#' write ( loss_fn_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( loss_fn_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( loss_fn_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( loss_fn_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( loss_fn_unit , * ) '#' write ( loss_fn_unit , * ) '# Result of first sum rule: Neff(E) = ' , N_eff2 write ( loss_fn_unit , * ) '# Result of second sum rule (pi/2 = 1.570796327):' , N_eff3 write ( loss_fn_unit , * ) '#' if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , 1 ), loss_fn ( N , 2 ) end do else do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , 1 ) end do end if else if ( optics_lossfn_broadening ) then do N2 = 1 , 4 do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , N2 ) end do end do else do N2 = 1 , 3 do N = 1 , jdos_nbins write ( loss_fn_unit , * ) E ( N ), loss_fn ( N , N2 ) end do end do end if end if ! Close output file close ( unit = loss_fn_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then if (. not . optics_intraband ) then if ( optics_lossfn_broadening ) then call write_optics_xmgrace ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 )) else call write_optics_xmgrace ( label , E , loss_fn (:, 1 )) end if else if ( optics_lossfn_broadening ) then call write_optics_xmgrace ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 ), loss_fn (:, 3 ), loss_fn (:, 4 )) else call write_optics_xmgrace ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 ), loss_fn (:, 3 )) end if end if elseif ( trim ( output_format ) == \"gnuplot\" ) then if (. not . optics_intraband ) then call write_optics_gnuplot ( label , E , loss_fn (:, 1 )) else call write_optics_gnuplot ( label , E , loss_fn (:, 1 ), loss_fn (:, 2 ), loss_fn (:, 3 )) end if else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_loss_fn !*************************************************************** subroutine write_conduct !*************************************************************** ! This subroutine writes out the conductivity use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N integer :: conduct_unit type ( graph_labels ) :: label label % name = \"conductivity\" label % title = \"Conductivity (S m-1)\" ! Siemens per metre label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"Real\" label % legend_b = \"Imaginary\" ! Open the output file conduct_unit = io_file_unit () open ( unit = conduct_unit , action = 'write' , file = trim ( seedname ) // '_conductivity.dat' ) ! Write into the output file write ( conduct_unit , * ) '#*********************************************' write ( conduct_unit , * ) '#               Conductivity                ' write ( conduct_unit , * ) '#*********************************************' write ( conduct_unit , * ) '#' write ( conduct_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( conduct_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( conduct_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( conduct_unit , * ) '# No of bands:' , nbands write ( conduct_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume write ( conduct_unit , * ) '#' write ( conduct_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( conduct_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( conduct_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( conduct_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( conduct_unit , * ) '# Note: the conductivity is outputted in SI units, Siemens per metre' write ( conduct_unit , * ) '# to convert from SI units (Sm-1) to cgs units (s) divide by 4pixepsilon_0' write ( conduct_unit , * ) '# to convert from cgs (s) units to SI units (Sm-1) multiply by 4pixepsilon_0, ' write ( conduct_unit , * ) '#' do N = 1 , jdos_nbins write ( conduct_unit , * ) E ( N ), conduct ( N , 1 ), conduct ( N , 2 ) end do ! Close output file close ( unit = conduct_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , conduct (:, 1 ), conduct (:, 2 )) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , conduct (:, 1 ), conduct (:, 2 )) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_conduct !*************************************************************** subroutine write_refract ( atom , photo_volume ) !*************************************************************** ! This subroutine writes out the refractive index use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N integer :: refract_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"refractive_index_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"refractive_index\" end if label % title = \"Refractive Index\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"Real\" label % legend_b = \"Imaginary\" ! Open the output file refract_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = refract_unit , action = 'write' , file = trim ( seedname ) // '_refractive_index_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = refract_unit , action = 'write' , file = trim ( seedname ) // '_refractive_index.dat' ) end if ! Write into the output file write ( refract_unit , * ) '#*********************************************' write ( refract_unit , * ) '#             Refractive index                 ' write ( refract_unit , * ) '#*********************************************' write ( refract_unit , * ) '#' write ( refract_unit , * ) '# N=n+ik' write ( refract_unit , * ) '#' write ( refract_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( refract_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( refract_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( refract_unit , * ) '# No of bands:' , nbands if ( present ( photo_volume )) then write ( refract_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( refract_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( refract_unit , * ) '#' write ( refract_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( refract_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( refract_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( refract_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( refract_unit , * ) '#' do N = 1 , jdos_nbins write ( refract_unit , * ) E ( N ), ',' , refract ( N , 1 ), ',' , refract ( N , 2 ) end do ! Close output file close ( unit = refract_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , refract (:, 1 ), refract (:, 2 )) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , refract (:, 1 ), refract (:, 2 )) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_refract !*************************************************************** subroutine write_absorp ( atom , photo_volume ) !*************************************************************** ! This subroutine writes out the absorption coefficient use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_jdos_utils , only : jdos_nbins , E use od_io , only : seedname , io_file_unit , stdout integer :: N integer :: absorp_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"absorption_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"absorption\" end if label % title = \"Absorption Coefficient (m-1)\" ! per metre label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"A\" ! Open the output file absorp_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = absorp_unit , action = 'write' , file = trim ( seedname ) // '_absorption_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = absorp_unit , action = 'write' , file = trim ( seedname ) // '_absorption.dat' ) end if ! Write into the output file write ( absorp_unit , * ) '#*********************************************' write ( absorp_unit , * ) '#             Absorption coefficent                 ' write ( absorp_unit , * ) '#*********************************************' write ( absorp_unit , * ) '#' write ( absorp_unit , * ) '#' write ( absorp_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( absorp_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( absorp_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( absorp_unit , * ) '# No of bands:' , nbands if ( present ( photo_volume )) then write ( absorp_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( absorp_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( absorp_unit , * ) '#' write ( absorp_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( absorp_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( absorp_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( absorp_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( absorp_unit , * ) '#' do N = 1 , jdos_nbins write ( absorp_unit , * ) E ( N ), ',' , absorp ( N ) end do ! Close output file close ( unit = absorp_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , absorp ) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , absorp ) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_absorp !*************************************************************** subroutine write_reflect ( atom , photo_volume ) !*************************************************************** ! This subroutine writes out the reflection coefficient use od_cell , only : nkpoints , cell_volume use od_parameters , only : optics_geom , optics_qdir , jdos_max_energy , scissor_op , output_format use od_electronic , only : nbands , num_electrons , nspins use od_io , only : seedname , io_file_unit , stdout use od_jdos_utils , only : jdos_nbins , E integer :: N integer :: reflect_unit integer , intent ( in ), optional :: atom real ( kind = dp ), intent ( in ), optional :: photo_volume character ( len = 3 ) :: atom_char type ( graph_labels ) :: label if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom label % name = \"reflection_atom_\" // trim ( adjustl ( atom_char )) else label % name = \"reflection\" end if label % title = \"Reflection Coefficient\" ! Dimensionless label % x_label = \"Energy (eV)\" label % y_label = \"\" label % legend_a = \"R\" ! Open the output file reflect_unit = io_file_unit () if ( atom . gt . 0 ) then write ( atom_char , '(I3)' ) atom open ( unit = reflect_unit , action = 'write' , file = trim ( seedname ) // '_reflection_atom_' // trim ( adjustl ( atom_char )) // '.dat' ) else open ( unit = reflect_unit , action = 'write' , file = trim ( seedname ) // '_reflection.dat' ) end if ! Write into the output file write ( reflect_unit , * ) '#*********************************************' write ( reflect_unit , * ) '#           Reflection coefficient                ' write ( reflect_unit , * ) '#*********************************************' write ( reflect_unit , * ) '#' write ( reflect_unit , * ) '# N=n+ik' write ( reflect_unit , * ) '#' write ( reflect_unit , * ) '# Number of k-points: ' , nkpoints if ( nspins == 1 ) then write ( reflect_unit , * ) '# Number of electrons:' , num_electrons ( 1 ) else write ( reflect_unit , * ) '# Number of electrons:' , num_electrons ( 1 ), num_electrons ( 2 ) end if write ( reflect_unit , * ) '# No of bands:' , nbands if ( present ( photo_volume )) then write ( reflect_unit , * ) '# Volume calculated for optics and photoemission (Ang&#94;3):' , photo_volume else write ( reflect_unit , * ) '# Volume of the unit cell (Ang&#94;3):' , cell_volume end if write ( reflect_unit , * ) '#' write ( reflect_unit , * ) '# optics_geom:  ' , optics_geom if ( index ( optics_geom , 'polar' ) > 0 ) then write ( reflect_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# q-vector' , optics_qdir ( 1 ), optics_qdir ( 2 ), optics_qdir ( 3 ) write ( reflect_unit , * ) '# q_weight:' , q_weight end if if ( scissor_op > 0 ) then write ( reflect_unit , '(1x,a,f10.3,f10.3,f10.3)' ) '# Scissor operator:' , scissor_op end if write ( reflect_unit , * ) '#' do N = 1 , jdos_nbins write ( reflect_unit , * ) E ( N ), ',' , reflect ( N ) end do ! Close output file close ( unit = reflect_unit ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_optics_xmgrace ( label , E , reflect ) elseif ( trim ( output_format ) == \"gnuplot\" ) then call write_optics_gnuplot ( label , E , reflect ) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if end subroutine write_reflect !=============================================================================== subroutine write_optics_xmgrace ( label , E , column1 , column2 , column3 , column4 ) !=============================================================================== use xmgrace_utils use od_io , only : io_file_unit , io_error , seedname implicit none type ( graph_labels ), intent ( in ) :: label real ( dp ), intent ( in ) :: E (:) real ( dp ), intent ( in ) :: column1 (:) real ( dp ), optional , intent ( in ) :: column2 (:) real ( dp ), optional , intent ( in ) :: column3 (:) real ( dp ), optional , intent ( in ) :: column4 (:) real ( dp ) :: min_x , max_x , min_y , max_y , range integer :: batch_file , ierr batch_file = io_file_unit () open ( unit = batch_file , file = trim ( seedname ) // '_' // trim ( label % name ) // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in optics: write_optics_xmgrace\" ) min_x = minval ( E ) max_x = maxval ( E ) if ( present ( column4 )) then min_y = min ( minval ( column1 ), minval ( column2 ), minval ( column3 ), minval ( column4 )) elseif ( present ( column3 )) then min_y = min ( minval ( column1 ), minval ( column2 ), minval ( column3 )) elseif ( present ( column2 )) then min_y = min ( minval ( column1 ), minval ( column2 )) else min_y = minval ( column1 ) end if if ( present ( column4 )) then max_y = max ( maxval ( column1 ), maxval ( column2 ), maxval ( column3 ), maxval ( column4 )) elseif ( present ( column3 )) then max_y = max ( maxval ( column1 ), maxval ( column2 ), maxval ( column3 )) elseif ( present ( column2 )) then max_y = max ( maxval ( column1 ), maxval ( column2 )) else max_y = maxval ( column1 ) end if ! For aesthetic reasons we make the axis range 1% larger than the data range range = abs ( max_y - min_y ) max_y = max_y + 0.01_dp * range min_y = min_y - 0.01_dp * range call xmgu_setup ( batch_file ) call xmgu_legend ( batch_file ) call xmgu_title ( batch_file , min_x , max_x , min_y , max_y , trim ( label % title )) !    call  xmgu_subtitle(batch_file,\"Generated by OptaDOS\") call xmgu_axis ( batch_file , \"x\" , trim ( label % x_label )) call xmgu_axis ( batch_file , \"y\" , trim ( label % y_label )) if ( present ( column4 )) then call xmgu_data_header ( batch_file , 0 , 1 , trim ( label % legend_a )) call xmgu_data_header ( batch_file , 1 , 2 , trim ( label % legend_b )) call xmgu_data_header ( batch_file , 2 , 3 , trim ( label % legend_c )) call xmgu_data_header ( batch_file , 3 , 4 , trim ( label % legend_d )) call xmgu_data ( batch_file , 0 , E (:), column1 (:)) call xmgu_data ( batch_file , 1 , E (:), column2 (:)) call xmgu_data ( batch_file , 2 , E (:), column3 (:)) call xmgu_data ( batch_file , 3 , E (:), column4 (:)) elseif ( present ( column3 )) then call xmgu_data_header ( batch_file , 0 , 1 , trim ( label % legend_a )) call xmgu_data_header ( batch_file , 1 , 2 , trim ( label % legend_b )) call xmgu_data_header ( batch_file , 2 , 3 , trim ( label % legend_c )) call xmgu_data ( batch_file , 0 , E (:), column1 (:)) call xmgu_data ( batch_file , 1 , E (:), column2 (:)) call xmgu_data ( batch_file , 2 , E (:), column3 (:)) elseif ( present ( column2 )) then call xmgu_data_header ( batch_file , 0 , 1 , trim ( label % legend_a )) call xmgu_data_header ( batch_file , 1 , 2 , trim ( label % legend_b )) call xmgu_data ( batch_file , 0 , E (:), column1 (:)) call xmgu_data ( batch_file , 1 , E (:), column2 (:)) else call xmgu_data_header ( batch_file , 0 , 1 , trim ( label % legend_a )) call xmgu_data ( batch_file , 0 , E (:), column1 ) end if end subroutine write_optics_xmgrace !=============================================================================== subroutine write_optics_gnuplot ( label , E , column1 , column2 , column3 ) !=============================================================================== use od_io , only : io_file_unit , io_error , seedname implicit none type ( graph_labels ), intent ( in ) :: label real ( dp ), intent ( in ) :: E (:) real ( dp ), intent ( in ) :: column1 (:) real ( dp ), optional , intent ( in ) :: column2 (:) real ( dp ), optional , intent ( in ) :: column3 (:) integer :: gnu_unit , ierr gnu_unit = io_file_unit () open ( unit = gnu_unit , file = trim ( seedname ) // '_' // trim ( label % name ) // '.gnu' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open gnuplot batch file in optics: write_optics_gnupot\" ) gnu_unit = io_file_unit () open ( unit = gnu_unit , action = 'write' , file = trim ( seedname ) // '_' // trim ( label % name ) // '.gnu' ) write ( gnu_unit , * ) 'set xlabel ' , '\"' // trim ( label % x_label ) // '\"' write ( gnu_unit , * ) 'set ylabel ' , '\"' // trim ( label % y_label ) // '\"' write ( gnu_unit , * ) 'set title ' , '\"' // trim ( label % title ) // '\"' ! Note that char(92) is a backslash, which gnuplot uses as a continuation character ! We reference it this was to stop certain compilers treating it as an escape character if ( present ( column3 )) then write ( gnu_unit , * ) 'plot ' , '\"' // trim ( seedname ) // '_' // trim ( label % name ) // '.dat' // '\"' , ' u 1:2 t ' , '\"' // & & trim ( label % legend_a ) // '\"' // 'w l, ' , char ( 92 ) write ( gnu_unit , * ) '       \"' // trim ( seedname ) // '_' // trim ( label % name ) // '.dat' // '\"' , ' u 1:3 t ' , '\"' // & & trim ( label % legend_b ) // '\"' , ' w l,' , char ( 92 ) write ( gnu_unit , * ) '       \"' // trim ( seedname ) // '_' // trim ( label % name ) // '.dat' // '\"' , ' u 1:4 t ' , '\"' // & & trim ( label % legend_c ) // '\"' , ' w l' elseif ( present ( column2 )) then write ( gnu_unit , * ) 'plot ' , '\"' // trim ( seedname ) // '_' // trim ( label % name ) // '.dat' // '\"' , ' u 1:2 t ' , '\"' // & & trim ( label % legend_a ) // '\"' , ' w l,' , char ( 92 ) write ( gnu_unit , * ) '       \"' // trim ( seedname ) // '_' // trim ( label % name ) // '.dat' // '\"' , ' u 1:3 t ' , '\"' // & & trim ( label % legend_b ) // '\"' , ' w l' else write ( gnu_unit , * ) 'plot ' , '\"' // trim ( seedname ) // '_' // trim ( label % name ) // '.dat' // '\"' , ' u 1:2 t ' , '\"' // & trim ( label % legend_a ) // '\"' , ' w l' end if close ( gnu_unit ) end subroutine write_optics_gnuplot end module od_optics","tags":"","loc":"sourcefile/optics.f90.html"},{"title":"comms.F90 – OptaDOS","text":"This file depends on sourcefile~~comms.f90~~EfferentGraph sourcefile~comms.f90 comms.F90 sourcefile~constants.f90 constants.f90 sourcefile~comms.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~comms.f90~~AfferentGraph sourcefile~comms.f90 comms.F90 sourcefile~optics.f90 optics.f90 sourcefile~optics.f90->sourcefile~comms.f90 sourcefile~cell.f90 cell.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~pdis.f90->sourcefile~comms.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~pdis.f90->sourcefile~algorithms.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~dos.f90 dos.f90 sourcefile~dos.f90->sourcefile~comms.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~comms.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~optados.f90->sourcefile~cell.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~comms.f90 sourcefile~od2od.f90->sourcefile~cell.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~projection_utils.f90->sourcefile~comms.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~comms.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~pdos.f90->sourcefile~algorithms.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos.f90->sourcefile~comms.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~core.f90->sourcefile~comms.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_comms Subroutines my_DCOPY my_ZCOPY my_ICOPY Source Code comms.F90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! !                                                            ! !  COMMS: set of MPI wrappers                                ! ! (c) 2006-2010 Jonathan R. Yates                            ! !                                                            ! !------------------------------------------------------------! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! module od_comms use od_constants , only : dp implicit none private #ifdef MPI include 'mpif.h' #endif logical , public , save :: on_root integer , public , save :: num_nodes , my_node_id integer , public , parameter :: root_id = 0 integer , parameter :: mpi_send_tag = 77 !abitrary public :: comms_setup public :: comms_end public :: comms_bcast ! send data from the root node public :: comms_send ! send data from one node to another public :: comms_recv ! accept data from one node to another public :: comms_reduce ! reduce data onto root node (n.b. not allreduce) interface comms_bcast module procedure comms_bcast_int module procedure comms_bcast_logical module procedure comms_bcast_real module procedure comms_bcast_cmplx module procedure comms_bcast_char end interface comms_bcast interface comms_send module procedure comms_send_int module procedure comms_send_logical module procedure comms_send_real module procedure comms_send_cmplx module procedure comms_send_char end interface comms_send interface comms_recv module procedure comms_recv_int module procedure comms_recv_logical module procedure comms_recv_real module procedure comms_recv_cmplx module procedure comms_recv_char end interface comms_recv interface comms_reduce module procedure comms_reduce_int module procedure comms_reduce_real module procedure comms_reduce_cmplx end interface comms_reduce contains subroutine comms_setup implicit none integer :: ierr #ifdef MPI call mpi_init ( ierr ) if ( ierr . ne . 0 ) stop 'MPI initialisation error' call mpi_comm_rank ( mpi_comm_world , my_node_id , ierr ) call mpi_comm_size ( mpi_comm_world , num_nodes , ierr ) #else num_nodes = 1 my_node_id = 0 #endif on_root = . false . if ( my_node_id == root_id ) on_root = . true . end subroutine comms_setup subroutine comms_end implicit none integer :: ierr #ifdef MPI call mpi_finalize ( ierr ) #else stop #endif end subroutine comms_end subroutine comms_bcast_int ( array , size ) implicit none integer , intent ( inout ) :: array integer , intent ( in ) :: size integer :: error #ifdef MPI call MPI_bcast ( array , size , MPI_integer , root_id , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_bcast_int' call comms_error end if #endif return end subroutine comms_bcast_int subroutine comms_bcast_real ( array , size ) implicit none real ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size integer :: error #ifdef MPI call MPI_bcast ( array , size , MPI_double_precision , root_id , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_bcast_real' call comms_error end if #endif return end subroutine comms_bcast_real subroutine comms_bcast_logical ( array , size ) implicit none logical , intent ( inout ) :: array integer , intent ( in ) :: size integer :: error #ifdef MPI call MPI_bcast ( array , size , MPI_logical , root_id , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_bcast_logical' call comms_error end if #endif return end subroutine comms_bcast_logical subroutine comms_bcast_char ( array , size ) implicit none character ( len =* ), intent ( inout ) :: array integer , intent ( in ) :: size integer :: error #ifdef MPI call MPI_bcast ( array , size , MPI_character , root_id , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_bcast_char' call comms_error end if #endif return end subroutine comms_bcast_char subroutine comms_bcast_cmplx ( array , size ) implicit none complex ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size integer :: error #ifdef MPI call MPI_bcast ( array , size , MPI_double_complex , root_id , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_bcast_cmplx' call comms_error end if #endif return end subroutine comms_bcast_cmplx !--------- SEND ---------------- subroutine comms_send_logical ( array , size , to ) implicit none logical , intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: to integer :: error #ifdef MPI call MPI_send ( array , size , MPI_logical , to , & mpi_send_tag , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_send_logical' call comms_error end if #endif return end subroutine comms_send_logical subroutine comms_send_int ( array , size , to ) implicit none integer , intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: to integer :: error #ifdef MPI call MPI_send ( array , size , MPI_integer , to , & mpi_send_tag , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_send_int' call comms_error end if #endif return end subroutine comms_send_int subroutine comms_send_char ( array , size , to ) implicit none character ( len =* ), intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: to integer :: error #ifdef MPI call MPI_send ( array , size , MPI_character , to , & mpi_send_tag , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_send_char' call comms_error end if #endif return end subroutine comms_send_char subroutine comms_send_real ( array , size , to ) implicit none real ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: to integer :: error #ifdef MPI call MPI_send ( array , size , MPI_double_precision , to , & mpi_send_tag , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_send_real' call comms_error end if #endif return end subroutine comms_send_real subroutine comms_send_cmplx ( array , size , to ) implicit none complex ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: to integer :: error #ifdef MPI call MPI_send ( array , size , MPI_double_complex , to , & mpi_send_tag , mpi_comm_world , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_send_cmplx' call comms_error end if #endif return end subroutine comms_send_cmplx !--------- RECV ---------------- subroutine comms_recv_logical ( array , size , from ) implicit none logical , intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: from integer :: error #ifdef MPI integer :: status ( MPI_status_size ) call MPI_recv ( array , size , MPI_logical , from , & mpi_send_tag , mpi_comm_world , status , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_recv_logical' call comms_error end if #endif return end subroutine comms_recv_logical subroutine comms_recv_int ( array , size , from ) implicit none integer , intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: from integer :: error #ifdef MPI integer :: status ( MPI_status_size ) call MPI_recv ( array , size , MPI_integer , from , & mpi_send_tag , mpi_comm_world , status , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_recv_int' call comms_error end if #endif return end subroutine comms_recv_int subroutine comms_recv_char ( array , size , from ) implicit none character ( len =* ), intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: from integer :: error #ifdef MPI integer :: status ( MPI_status_size ) call MPI_recv ( array , size , MPI_character , from , & mpi_send_tag , mpi_comm_world , status , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_recv_char' call comms_error end if #endif return end subroutine comms_recv_char subroutine comms_recv_real ( array , size , from ) implicit none real ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: from integer :: error #ifdef MPI integer :: status ( MPI_status_size ) call MPI_recv ( array , size , MPI_double_precision , from , & mpi_send_tag , mpi_comm_world , status , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_recv_real' call comms_error end if #endif return end subroutine comms_recv_real subroutine comms_recv_cmplx ( array , size , from ) implicit none complex ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size integer , intent ( in ) :: from integer :: error #ifdef MPI integer :: status ( MPI_status_size ) call MPI_recv ( array , size , MPI_double_complex , from , & mpi_send_tag , mpi_comm_world , status , error ) if ( error . ne . MPI_success ) then print * , 'Error in comms_recv_cmplx' call comms_error end if #endif return end subroutine comms_recv_cmplx subroutine comms_error implicit none integer :: error #ifdef MPI call MPI_abort ( MPI_comm_world , 1 , error ) #endif end subroutine comms_error ! COMMS_REDUCE (collect data on the root node) subroutine comms_reduce_int ( array , size , op ) implicit none integer , intent ( inout ) :: array integer , intent ( in ) :: size character ( len =* ), intent ( in ) :: op integer :: error , ierr #ifdef MPI integer :: status ( MPI_status_size ) integer , allocatable :: array_red (:) allocate ( array_red ( size ), stat = ierr ) if ( ierr /= 0 ) then print * , 'failure to allocate array_red in comms_reduce_int' call comms_error end if select case ( op ) case ( 'SUM' ) call MPI_reduce ( array , array_red , size , MPI_integer , MPI_sum , 0 , mpi_comm_world , error ) case ( 'PRD' ) call MPI_reduce ( array , array_red , size , MPI_integer , MPI_prod , 0 , mpi_comm_world , error ) case default print * , 'Unknown operation in comms_reduce_int' call comms_error end select call my_icopy ( size , array , 1 , array_red , 1 ) if ( error . ne . MPI_success ) then print * , 'Error in comms_reduce_real' call comms_error end if #endif return end subroutine comms_reduce_int subroutine comms_reduce_real ( array , size , op ) implicit none real ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size character ( len =* ), intent ( in ) :: op integer :: error , ierr #ifdef MPI integer :: status ( MPI_status_size ) real ( kind = dp ), allocatable :: array_red (:) allocate ( array_red ( size ), stat = ierr ) if ( ierr /= 0 ) then print * , 'failure to allocate array_red in comms_reduce_real' call comms_error end if select case ( op ) case ( 'SUM' ) call MPI_reduce ( array , array_red , size , MPI_double_precision , MPI_sum , 0 , mpi_comm_world , error ) case ( 'PRD' ) call MPI_reduce ( array , array_red , size , MPI_double_precision , MPI_prod , 0 , mpi_comm_world , error ) case ( 'MIN' ) call MPI_reduce ( array , array_red , size , MPI_double_precision , MPI_MIN , 0 , mpi_comm_world , error ) case ( 'MAX' ) call MPI_reduce ( array , array_red , size , MPI_double_precision , MPI_max , 0 , mpi_comm_world , error ) case default print * , 'Unknown operation in comms_reduce_real' call comms_error end select call my_dcopy ( size , array_red , 1 , array , 1 ) if ( error . ne . MPI_success ) then print * , 'Error in comms_reduce_real' call comms_error end if #endif return end subroutine comms_reduce_real subroutine comms_reduce_cmplx ( array , size , op ) implicit none complex ( kind = dp ), intent ( inout ) :: array integer , intent ( in ) :: size character ( len =* ), intent ( in ) :: op integer :: error , ierr #ifdef MPI integer :: status ( MPI_status_size ) complex ( kind = dp ), allocatable :: array_red (:) allocate ( array_red ( size ), stat = ierr ) if ( ierr /= 0 ) then print * , 'failure to allocate array_red in comms_reduce_cmplx' call comms_error end if select case ( op ) case ( 'SUM' ) call MPI_reduce ( array , array_red , size , MPI_double_complex , MPI_sum , 0 , mpi_comm_world , error ) case ( 'PRD' ) call MPI_reduce ( array , array_red , size , MPI_double_complex , MPI_prod , 0 , mpi_comm_world , error ) case default print * , 'Unknown operation in comms_reduce_cmplx' call comms_error end select call my_zcopy ( size , array_red , 1 , array , 1 ) if ( error . ne . MPI_success ) then print * , 'Error in comms_reduce_cmplx' call comms_error end if #endif return end subroutine comms_reduce_cmplx end module od_comms subroutine my_DCOPY ( N , DX , INCX , DY , INCY ) use od_constants , only : dp !     .. Scalar Arguments .. integer INCX , INCY , N !     .. !     .. Array Arguments .. real ( kind = dp ) DX ( * ), DY ( * ) !     .. ! !  Purpose !  ======= ! !     copies a vector, x, to a vector, y. !     uses unrolled loops for increments equal to one. !     jack dongarra, linpack, 3/11/78. !     modified 12/3/93, array(1) declarations changed to array(*) ! ! !     .. Local Scalars .. integer I , IX , IY , M , MP1 !     .. !     .. Intrinsic Functions .. intrinsic MOD !     .. if ( N . le . 0 ) return if ( INCX . eq . 1 . and . INCY . eq . 1 ) GO TO 20 ! !        code for unequal increments or equal increments !          not equal to 1 ! IX = 1 IY = 1 if ( INCX . lt . 0 ) IX = ( - N + 1 ) * INCX + 1 if ( INCY . lt . 0 ) IY = ( - N + 1 ) * INCY + 1 do I = 1 , N DY ( IY ) = DX ( IX ) IX = IX + INCX IY = IY + INCY end do return ! !        code for both increments equal to 1 ! ! !        clean-up loop ! 20 M = mod ( N , 7 ) if ( M . eq . 0 ) GO TO 40 do I = 1 , M DY ( I ) = DX ( I ) end do if ( N . lt . 7 ) return 40 MP1 = M + 1 do I = MP1 , N , 7 DY ( I ) = DX ( I ) DY ( I + 1 ) = DX ( I + 1 ) DY ( I + 2 ) = DX ( I + 2 ) DY ( I + 3 ) = DX ( I + 3 ) DY ( I + 4 ) = DX ( I + 4 ) DY ( I + 5 ) = DX ( I + 5 ) DY ( I + 6 ) = DX ( I + 6 ) end do return end subroutine my_DCOPY subroutine my_ZCOPY ( N , ZX , INCX , ZY , INCY ) use od_constants , only : dp !     .. Scalar Arguments .. integer INCX , INCY , N !     .. !     .. Array Arguments .. complex ( kind = dp ) ZX ( * ), ZY ( * ) !     .. ! !  Purpose !  ======= ! !     copies a vector, x, to a vector, y. !     jack dongarra, linpack, 4/11/78. !     modified 12/3/93, array(1) declarations changed to array(*) ! ! !     .. Local Scalars .. integer I , IX , IY !     .. if ( N . le . 0 ) return if ( INCX . eq . 1 . and . INCY . eq . 1 ) GO TO 20 ! !        code for unequal increments or equal increments !          not equal to 1 ! IX = 1 IY = 1 if ( INCX . lt . 0 ) IX = ( - N + 1 ) * INCX + 1 if ( INCY . lt . 0 ) IY = ( - N + 1 ) * INCY + 1 do I = 1 , N ZY ( IY ) = ZX ( IX ) IX = IX + INCX IY = IY + INCY end do return ! !        code for both increments equal to 1 ! 20 do I = 1 , N ZY ( I ) = ZX ( I ) end do return end subroutine my_ZCOPY subroutine my_ICOPY ( N , ZX , INCX , ZY , INCY ) !     .. Scalar Arguments .. integer INCX , INCY , N !     .. !     .. Array Arguments .. integer ZX ( * ), ZY ( * ) !     .. ! !  Purpose !  ======= ! !     copies a vector, x, to a vector, y. !     jack dongarra, linpack, 4/11/78. !     modified 12/3/93, array(1) declarations changed to array(*) ! ! !     .. Local Scalars .. integer I , IX , IY !     .. if ( N . le . 0 ) return if ( INCX . eq . 1 . and . INCY . eq . 1 ) GO TO 20 ! !        code for unequal increments or equal increments !          not equal to 1 ! IX = 1 IY = 1 if ( INCX . lt . 0 ) IX = ( - N + 1 ) * INCX + 1 if ( INCY . lt . 0 ) IY = ( - N + 1 ) * INCY + 1 do I = 1 , N ZY ( IY ) = ZX ( IX ) IX = IX + INCX IY = IY + INCY end do return ! !        code for both increments equal to 1 ! 20 do I = 1 , N ZY ( I ) = ZX ( I ) end do return end subroutine my_ICOPY","tags":"","loc":"sourcefile/comms.f90.html"},{"title":"electronic.f90 – OptaDOS","text":"This file depends on sourcefile~~electronic.f90~~EfferentGraph sourcefile~electronic.f90 electronic.f90 sourcefile~constants.f90 constants.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~io.f90 io.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~cell.f90 cell.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~comms.f90 comms.F90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~electronic.f90~~AfferentGraph sourcefile~electronic.f90 electronic.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~dos.f90 dos.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~optics.f90 optics.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_electronic Source Code electronic.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! E L E C T R O N I C ! Stores variables to do with the electrons and energy eigenvalues in the ! system. At this stage I don't see it contining many functions, but it ! was important for the dos module not to have too many global variables ! AJM Dec 2010 !=========================================================================! module od_electronic use od_constants , only : dp implicit none !-------------------------------------------------------------------------! ! G L O B A L   V A R I A B L E S real ( kind = dp ), allocatable , public , save :: band_energy (:, :, :) real ( kind = dp ), allocatable , public , save :: band_gradient (:, :, :, :) complex ( kind = dp ), allocatable , public , save :: optical_mat (:, :, :, :, :) complex ( kind = dp ), allocatable , public , save :: elnes_mat (:, :, :, :, :) !Additional variables for photoemission.- V.Chang Nov-2020 real ( kind = dp ), allocatable , public , save :: band_curvature (:, :, :, :, :) complex ( kind = dp ), allocatable , public , save :: foptical_mat (:, :, :, :, :) ! F. Mildner April-2023 character ( len = 80 ), public , save :: femfile_header real ( kind = dp ), public , save :: efermi ! The fermi energy we finally decide on logical , public , save :: efermi_set = . false . ! Have we set efermi? real ( kind = dp ), public , save :: unshifted_efermi ! The fermi energy we finally decide on, perhaps not set to 0 real ( kind = dp ), public , save :: efermi_castep ! Fermi energy as reported by CASTEP real ( kind = dp ), allocatable , public , save :: num_electrons (:) ! Holds up-spin and ! down-spin integer , public , save :: nbands , nspins real ( kind = dp ), public , save :: electrons_per_state ! 2 for non-spin-P ! 1 for spin-P logical , public , save :: spin_polarised type , public :: matrix_weights_array_boundaries integer :: norbitals integer :: nbands integer :: nkpoints integer :: nspins end type matrix_weights_array_boundaries type , public :: orbitals integer , allocatable :: ion_no (:) ! Unique ion number integer , allocatable :: species_no (:) ! Unique species number integer , allocatable :: rank_in_species (:) ! Unique ion number within species integer , allocatable :: am_channel (:) ! The angular momentum Channel (l) integer , allocatable :: shell (:) ! Principal quantum number (n) !n.b typically only know this for core states character ( len = 10 ), allocatable :: am_channel_name (:) ! Name of angular momentum channel s,p,d, etc end type orbitals ! On writing the od2od it became necessary to have some variables moved from ! the individual routines into the module. integer , allocatable , public , save :: nbands_occ (:, :) ! All these are len=80 to be consistent with CASTEP. character ( len = 80 ), public , save :: omefile_header character ( len = 80 ), public , save :: domefile_header character ( len = 80 ), public , save :: pdosfile_header character ( len = 80 ), public , save :: elnesfile_header integer , public , save :: omefile_version integer , public , save :: domefile_version integer , public , save :: pdosfile_version integer , public , save :: elnesfile_version type ( orbitals ), public , save :: pdos_orbital real ( kind = dp ), public , allocatable , save :: pdos_weights (:, :, :, :) real ( kind = dp ), allocatable :: all_pdos_weights (:, :, :, :) type ( matrix_weights_array_boundaries ), public , save :: pdos_mwab type ( orbitals ), public , save :: elnes_orbital type ( matrix_weights_array_boundaries ), public , save :: elnes_mwab real ( kind = dp ), public , allocatable , save :: all_kpoints (:, :) ! We need this to be available if we're ! doing bandgap analysis. real ( kind = dp ), public , allocatable , save :: all_kpoint_weight (:) !-------------------------------------------------------------------------! private !-------------------------------------------------------------------------! ! G L O B A L   F U N C T I O N S public :: elec_report_parameters public :: elec_read_band_energy public :: elec_read_band_energy_ordered public :: elec_read_band_gradient public :: elec_read_optical_mat public :: elec_read_elnes_mat public :: elec_pdos_read public :: elec_pdis_read public :: elec_dealloc_elnes public :: elec_dealloc_pdos public :: elec_dealloc_band_gradient public :: elec_dealloc_optical public :: elec_elnes_find_channel_names public :: elec_elnes_find_channel_numbers !Additional functions for photoemission - V.Chang Nov-2020 public :: elec_read_band_curvature public :: elec_read_foptical_mat !-------------------------------------------------------------------------! contains !========================================================================= subroutine elec_report_parameters !========================================================================= ! Report the electronic properties in the calculation !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables nbands,num_electrons,nkpoints,kpoint_grid_dim !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_io , only : stdout use od_cell , only : kpoint_grid_dim , nkpoints use od_parameters , only : pdis implicit none write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+----------------------- Electronic Data ------------------------------------+' write ( stdout , '(1x,a46,i14,a18)' ) '|  Number of Bands                           :' , nbands , \"|\" if (. not . pdis ) then write ( stdout , '(1x,a46,6x,i3,1x,a1,i3,1x,a1,i3,12x,a1)' ) '|  Grid size                                 :' & , kpoint_grid_dim ( 1 ), 'x' , kpoint_grid_dim ( 2 ), 'x' , kpoint_grid_dim ( 3 ), '|' end if write ( stdout , '(1x,a46,i14,a18)' ) '|  Number of K-points                        :' , nkpoints , \"|\" if ( nspins > 1 ) then write ( stdout , '(1x,a78)' ) '|  Spin-Polarised Calculation                :           True                |' write ( stdout , '(1x,a46,f17.2,a15)' ) \"|  Number of up-spin electrons               :\" , num_electrons ( 1 ), \"|\" write ( stdout , '(1x,a46,f17.2,a15)' ) \"|  Number of down-spin electrons             :\" , num_electrons ( 2 ), \"|\" else write ( stdout , '(1x,a78)' ) '|  Spin-Polarised Calculation                :           False               |' write ( stdout , '(1x,a46,f17.2,a15)' ) \"|  Number of electrons                       :\" , num_electrons ( 1 ), \"|\" end if write ( stdout , '(1x,a78)' ) '+----------------------------------------------------------------------------+' end subroutine elec_report_parameters !========================================================================= subroutine elec_read_band_gradient !========================================================================= ! Read the .cst_ome file in paralell if appropriate. These are the ! gradients of the bands at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_gradient,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send , comms_bcast use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: gradient_unit , i , ib , jb , is , ik , inodes , ierr , loop character ( filename_len ) :: gradient_filename logical :: exists real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp ! Check that we haven't already done this. if ( allocated ( band_gradient )) return ! first try to read a velocity file if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then gradient_filename = trim ( seedname ) // \".cst_vel\" else gradient_filename = trim ( seedname ) // \".dome_bin\" end if if ( on_root ) inquire ( file = gradient_filename , exist = exists ) call comms_bcast ( exists , 1 ) if ( exists ) then ! good. We are reading from a velocity file time0 = io_time () if ( on_root ) then !if (iprint > 1) write (stdout, '(a)') ' ' if ( iprint > 1 ) write ( stdout , '(a)' ) ' Reading band gradients from file: ' // trim ( gradient_filename ) gradient_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then gradient_filename = trim ( seedname ) // \".cst_vel\" open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 101 ) else gradient_filename = trim ( seedname ) // \".dome_bin\" open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( gradient_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of dome_bin file. Update optados!' ) read ( gradient_unit ) domefile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( domefile_header ) end if end if ! Figure out how many kpoint should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( band_gradient ( 1 : nbands , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_gradient in elec_read_band_gradient' ) band_gradient = 0.0_dp if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins read ( gradient_unit ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), i = 1 , 3 ) end do end do call comms_send ( band_gradient ( 1 , 1 , 1 , 1 ), nbands * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins read ( gradient_unit ) (( band_gradient ( ib , i , ik , is ), ib = 1 , nbands ), i = 1 , 3 ) end do end do end if if (. not . on_root ) then call comms_recv ( band_gradient ( 1 , 1 , 1 , 1 ), nbands * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if !        write(*,*) \"I'm node\", my_node_id, \"k-pts:\", num_kpoints_on_node(my_node_id),\"bgarray:\", & !& size(band_gradient), \"or:\", nbands*3*nspins*num_kpoints_on_node(my_node_id) if ( on_root ) close ( unit = gradient_unit ) ! Convert all band gradients to eV Ang band_gradient = band_gradient * bohr2ang * H2eV time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a30,29x,f11.3,a8)' ) '+ Time to read band gradients ' , time1 - time0 , ' (sec) +' end if else ! lets try to get the data from the cst_ome file allocate ( band_gradient ( 1 : nbands , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_gradient (b) in elec_read_band_gradient' ) if ( allocated ( optical_mat )) then do loop = 1 , nbands band_gradient ( loop , :, :, :) = real ( optical_mat ( loop , loop , :, :, :), dp ) end do else call elec_read_optical_mat do loop = 1 , nbands band_gradient ( loop , :, :, :) = real ( optical_mat ( loop , loop , :, :, :), dp ) end do call elec_dealloc_optical ! given that it is a large matrix we'll let it go ! potentially that means reading it twice... end if end if return 101 call io_error ( 'Error: Problem opening cst_vel file in read_band_gradient' ) 102 call io_error ( 'Error: Problem opening dome_bin file in read_band_gradient' ) end subroutine elec_read_band_gradient !========================================================================= subroutine elec_read_band_curvature !========================================================================= ! Read the .ddome file in paralell if appropriate. These are the ! curvatures of the bands at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_curvature,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  V Chang                                             Nov 2020 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send , comms_bcast use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: curvature_unit , i , j , ib , jb , is , ik , inodes , ierr , loop character ( filename_len ) :: curvature_filename character ( len = 80 ) :: header logical :: exists real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp ! Check that we haven't already done this. if ( allocated ( band_curvature )) return ! first try to read a effective mass file curvature_filename = trim ( seedname ) // \".ddome_bin\" if ( on_root ) inquire ( file = curvature_filename , exist = exists ) call comms_bcast ( exists , 1 ) if ( exists ) then ! good. We are reading from a velocity file time0 = io_time () if ( on_root ) then if ( iprint > 1 ) write ( stdout , '(a)' ) ' ' if ( iprint > 1 ) write ( stdout , '(a)' ) ' Reading band curvature from file:' // trim ( curvature_filename ) curvature_unit = io_file_unit () curvature_filename = trim ( seedname ) // \".ddome_bin\" open ( unit = curvature_unit , file = curvature_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( curvature_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of ddome_bin file. Update optados!' ) read ( curvature_unit ) femfile_header if ( iprint > 1 ) write ( stdout , * ) trim ( femfile_header ) end if ! Figure out how many kpoint should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( band_curvature ( 1 : nbands , 1 : 3 , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_curvature in elec_read_band_curvature' ) if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins do ib = 1 , nbands do i = 1 , 3 do j = 1 , 3 read ( curvature_unit ) band_curvature ( ib , i , j , ik , is ) end do end do end do end do end do call comms_send ( band_curvature ( 1 , 1 , 1 , 1 , 1 ), nbands * 3 * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins do ib = 1 , nbands do i = 1 , 3 do j = 1 , 3 read ( curvature_unit ) band_curvature ( ib , i , j , ik , is ) end do end do end do end do end do end if if (. not . on_root ) then call comms_recv ( band_curvature ( 1 , 1 , 1 , 1 , 1 ), nbands * 3 * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = curvature_unit ) ! Convert all band curvatures to eV Ang&#94;2 band_curvature = band_curvature * bohr2ang * bohr2ang * H2eV time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read band curvature' , time1 - time0 , ' (sec)' end if return 101 call io_error ( 'Error: Problem opening cst_vel file in read_band_curvature' ) 102 call io_error ( 'Error: Problem opening dome_bin file in read_band_curvature' ) end subroutine elec_read_band_curvature !========================================================================= subroutine elec_read_optical_mat !========================================================================= ! Read the .cst_ome file in paralell if appropriate. These are the ! gradients of the bands at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_gradient,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: gradient_unit , i , ib , jb , is , ik , inodes , ierr character ( filename_len ) :: gradient_filename real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp ! Check that we haven't already done this. if ( allocated ( optical_mat )) return time0 = io_time () if ( on_root ) then gradient_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then gradient_filename = trim ( seedname ) // \".cst_ome\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading optical matrix elements from file: ' // trim ( gradient_filename ) open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 101 ) else gradient_filename = trim ( seedname ) // \".ome_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading optical matrix elements from file: ' // trim ( gradient_filename ) open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( gradient_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of ome_bin file. Update optados!' ) read ( gradient_unit ) omefile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( omefile_header ) end if end if ! Figure out how many kpoints should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( optical_mat ( 1 : nbands , 1 : nbands , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating optical_mat in elec_read_optical_mat' ) if ( legacy_file_format ) then if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins do i = 1 , 3 do jb = 1 , nbands do ib = 1 , nbands ! Read in units of Ha Bohr&#94;2 / Ang read ( gradient_unit ) optical_mat ( ib , jb , i , ik , is ) end do end do end do end do end do call comms_send ( optical_mat ( 1 , 1 , 1 , 1 , 1 ), nbands * nbands * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins do i = 1 , 3 do jb = 1 , nbands do ib = 1 , nbands ! Read in units of Ha Bohr&#94;2 / Ang read ( gradient_unit ) optical_mat ( ib , jb , i , ik , is ) end do end do end do end do end do end if else ! sane file format if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins read ( gradient_unit ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ) & , jb = 1 , nbands ), i = 1 , 3 ) end do end do call comms_send ( optical_mat ( 1 , 1 , 1 , 1 , 1 ), nbands * nbands * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins read ( gradient_unit ) ((( optical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands ), jb = 1 , nbands ), i = 1 , 3 ) end do end do end if end if if (. not . on_root ) then call comms_recv ( optical_mat ( 1 , 1 , 1 , 1 , 1 ), nbands * nbands * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = gradient_unit ) ! Convert all band gradients to eV Ang if ( legacy_file_format ) then optical_mat = optical_mat * bohr2ang * bohr2ang * H2eV else optical_mat = optical_mat * bohr2ang * H2eV end if time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to read Optical Matrix Elements                   & &      ' , time1 - time0 , ' (sec) +' end if return 101 call io_error ( 'Error: Problem opening cst_ome file in read_band_optical_mat' ) 102 call io_error ( 'Error: Problem opening ome_bin file in read_band_optical_mat' ) end subroutine elec_read_optical_mat !========================================================================= subroutine elec_read_foptical_mat !========================================================================= ! Read the .fem_bin file in paralell if appropriate. These are the ! free electron matrix at each kpoint. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: foptical_mat,nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  V Chang                                             Nov 2020 !========================================================================= use od_comms , only : on_root , my_node_id , num_nodes , root_id ,& & comms_recv , comms_send , comms_reduce use od_io , only : io_time , filename_len , seedname , stdout , io_file_unit ,& & io_error use od_cell , only : num_kpoints_on_node , nkpoints , kpoint_r use od_constants , only : bohr2ang , H2eV use od_parameters , only : legacy_file_format , iprint , devel_flag use od_algorithms , only : algor_dist_array implicit none integer :: gradient_unit , i , ib , jb , is , ik , inodes , ierr , gam_unit = 23 , inode = 0 , ktmp character ( filename_len ) :: gradient_filename real ( kind = dp ) :: time0 , time1 , file_version , tolerance = 0.000001_dp real ( kind = dp ), parameter :: file_ver = 1.0_dp complex ( kind = dp ), dimension (:,:,:), allocatable :: foptical_mat_temp logical :: have_gamma = . False . ! Check that we haven't already done this. if ( allocated ( foptical_mat )) return time0 = io_time () if ( on_root ) then gradient_unit = io_file_unit () gradient_filename = trim ( seedname ) // \".fem_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading foptical matrix elements from file: ' // trim ( gradient_filename ) open ( unit = gradient_unit , file = gradient_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( gradient_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of fem_bin file. Update optados!' ) read ( gradient_unit ) femfile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( femfile_header ) end if ! Figure out how many kpoints should be on each node call algor_dist_array ( nkpoints , num_kpoints_on_node ) allocate ( foptical_mat ( 1 : nbands + 1 , 1 : nbands + 1 , 1 : 3 , 1 : num_kpoints_on_node ( my_node_id ), 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating foptical_mat in elec_read_optical_mat' ) if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do is = 1 , nspins read ( gradient_unit ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ) & , jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do call comms_send ( foptical_mat ( 1 , 1 , 1 , 1 , 1 ), ( nbands + 1 ) * ( nbands + 1 ) * 3 * nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do is = 1 , nspins read ( gradient_unit ) ((( foptical_mat ( ib , jb , i , ik , is ), ib = 1 , nbands + 1 ), jb = 1 , nbands + 1 ), i = 1 , 3 ) end do end do end if if (. not . on_root ) then call comms_recv ( foptical_mat ( 1 , 1 , 1 , 1 , 1 ), ( nbands + 1 ) * ( nbands + 1 ) * 3 * nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = gradient_unit ) ! Convert all band gradients to eV Ang if ( legacy_file_format ) then foptical_mat = foptical_mat * bohr2ang * bohr2ang * H2eV else foptical_mat = foptical_mat * bohr2ang * H2eV end if if ( index ( devel_flag , 'write_gam_fome' ) . gt . 0 ) then do ik = 1 , num_kpoints_on_node ( my_node_id ) if ( kpoint_r ( 1 , ik ) . lt . tolerance . and . kpoint_r ( 2 , ik ) . lt . tolerance . and . kpoint_r ( 3 , ik ) . lt . tolerance ) then inode = my_node_id ktmp = ik have_gamma = . True . write ( stdout , * ) 'node' , my_node_id , 'k#' , ktmp end if end do call comms_reduce ( inode , 1 , 'SUM' ) if ( have_gamma . and . . not . on_root ) then ! allocate the tmp array allocate ( foptical_mat_temp ( 1 : nbands + 1 , 1 : 3 , 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating foptical_mat_temp in elec_read_foptical_mat' ) ! write to tmp array foptical_mat_temp = foptical_mat (:, nbands + 1 ,:, ktmp ,:) ! send the tmp array to root node call comms_send ( foptical_mat_temp ( 1 , 1 , 1 ),( nbands + 1 ) * 3 * nspins , root_id ) ! deallocate the tmp array deallocate ( foptical_mat_temp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating foptical_mat_temp in elec_read_foptical_mat' ) end if if ( on_root ) then if ( have_gamma ) then ! Write out the fomes open ( unit = gam_unit , action = 'write' , file = trim ( seedname ) // '_gamma_fomes.dat' ) write ( gam_unit , '(1x,a28)' ) '############################' write ( gam_unit , * ) '# Free electron OMEs for' , seedname write ( gam_unit , '(1x,a28)' ) '############################' do is = 1 , nspins write ( gam_unit , * ) 'Spin Channel' , is write ( gam_unit , * ) '# bands + free electron band' , nbands + 1 do ib = 1 , nbands + 1 write ( gam_unit , '(1x, I3, 6(1x,ES24.16E2))' ) ib , ( foptical_mat ( ib , nbands + 1 , i , ktmp , is ), i = 1 , 3 ) end do end do close ( unit = gam_unit ) else ! allocate the tmp array allocate ( foptical_mat_temp ( 1 : nbands + 1 , 1 : 3 , 1 : nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating foptical_mat_temp in elec_read_foptical_mat' ) ! receive the tmp array to root node call comms_recv ( foptical_mat_temp ( 1 , 1 , 1 ),( nbands + 1 ) * 3 * nspins , inode ) ! write out the tmp array open ( unit = gam_unit , action = 'write' , file = trim ( seedname ) // '_gamma_fomes.dat' ) write ( gam_unit , '(1x,a28)' ) '############################' write ( gam_unit , * ) '# Free electron OMEs for' , seedname write ( gam_unit , '(1x,a28)' ) '############################' do is = 1 , nspins write ( gam_unit , * ) 'Spin Channel' , is write ( gam_unit , * ) '# bands + free electron band' , nbands do ib = 1 , nbands + 1 write ( gam_unit , '(1x, I3, 3(1x,ES24.16E2))' ) ib , ( foptical_mat_temp ( ib , i , is ), i = 1 , 3 ) end do end do close ( unit = gam_unit ) ! deallocate the tmp array deallocate ( foptical_mat_temp , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating foptical_mat_temp in elec_read_foptical_mat' ) end if end if end if time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to read Free electron Matrix Elements                   & &      ' , time1 - time0 , ' (sec) +' end if return 102 call io_error ( 'Error: Problem opening fem_bin file in read_band_foptical_mat' ) end subroutine elec_read_foptical_mat !========================================================================= subroutine elec_read_band_energy !(band_energy,kpoint_r,kpoint_weight) !========================================================================= ! Read the .bands file in the kpoint list, kpoint weights and band energies ! also obtain, nkpoints, nspins, num_electrons(:),nbands, efermi_castep !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_energy, efermi_castep, num_electrons ! spin_polarised, electrons_per_state, nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_constants , only : H2eV use od_cell , only : nkpoints , kpoint_r , kpoint_weight , cell_find_MP_grid ,& & real_lattice , kpoint_grid_dim , num_kpoints_on_node use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time ,& & io_error use od_algorithms , only : algor_dist_array use od_parameters , only : iprint , compute_band_gap , kpoint_mp_grid implicit none integer :: inodes , ik , is , ib , band_unit , iall_kpoints , i integer :: dum_i1 , ierr , str_pos character ( filename_len ) :: band_filename character ( len = 80 ) :: dummy real ( kind = dp ) :: time0 , time1 time0 = io_time () ! Check that we haven't already read in the energies if ( allocated ( band_energy )) return !Open the bands file band_unit = io_file_unit () band_filename = trim ( seedname ) // \".bands\" ! Read the header from the bands file if ( on_root ) then open ( unit = band_unit , file = band_filename , status = \"old\" , form = 'formatted' , err = 100 ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'k-points' ) read ( dummy ( str_pos + 8 :), * ) nkpoints read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'components' ) read ( dummy ( str_pos + 10 :), * ) nspins read ( band_unit , '(a)' ) dummy allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" str_pos = index ( dummy , 'electrons' ) read ( dummy ( str_pos + 10 :), * ) num_electrons (:) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'eigenvalues' ) read ( dummy ( str_pos + 11 :), * ) nbands read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'units)' ) read ( dummy ( str_pos + 6 :), '(f12.4)' ) efermi_castep read ( band_unit , '(a)' ) dummy read ( band_unit , * ) real_lattice (:, 1 ) read ( band_unit , * ) real_lattice (:, 2 ) read ( band_unit , * ) real_lattice (:, 3 ) end if call comms_bcast ( nspins , 1 ) if (. not . on_root ) then allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" end if call comms_bcast ( num_electrons ( 1 ), nspins ) call comms_bcast ( nkpoints , 1 ) call comms_bcast ( nbands , 1 ) call comms_bcast ( efermi_castep , 1 ) ! call algor_dist_array ( nkpoints , num_kpoints_on_node ) ! allocate ( band_energy ( 1 : nbands , 1 : nspins , 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_energy in read_band_energy' ) allocate ( kpoint_weight ( 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_weight in read_band_energy' ) allocate ( kpoint_r ( 1 : 3 , 1 : num_kpoints_on_node ( my_node_id )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_r in read_band_energy' ) if ( on_root ) then allocate ( all_kpoints ( 1 : 3 , nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating all_kpoints in read_band_energy' ) iall_kpoints = 1 do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'K-point' ) read ( dummy ( str_pos + 7 :), * ) dum_i1 , kpoint_r ( 1 , ik ), kpoint_r ( 2 , ik ), kpoint_r ( 3 , ik ), kpoint_weight ( ik ) do i = 1 , 3 all_kpoints ( i , iall_kpoints ) = kpoint_r ( i , ik ) end do iall_kpoints = iall_kpoints + 1 do is = 1 , nspins read ( band_unit , * ) dummy do ib = 1 , nbands read ( band_unit , * ) band_energy ( ib , is , ik ) !NB spin <-> kpt swapped end do end do end do call comms_send ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( inodes ), inodes ) call comms_send ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( inodes ), inodes ) call comms_send ( kpoint_weight ( 1 ), num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'K-point' ) read ( dummy ( str_pos + 7 :), * ) dum_i1 , kpoint_r ( 1 , ik ), kpoint_r ( 2 , ik ), kpoint_r ( 3 , ik ), kpoint_weight ( ik ) do i = 1 , 3 all_kpoints ( i , iall_kpoints ) = kpoint_r ( i , ik ) end do iall_kpoints = iall_kpoints + 1 do is = 1 , nspins read ( band_unit , * ) dummy do ib = 1 , nbands read ( band_unit , * ) band_energy ( ib , is , ik ) !NB spin <-> kpt swapped end do end do end do ! Do this here so we can free up the all_kpoints memory, unless we need it to calculate ! the kpoints at the band-gap. if ( kpoint_mp_grid ( 1 ) > 0 ) then ! we must have set this manually kpoint_grid_dim = kpoint_mp_grid else call cell_find_MP_grid ( all_kpoints , nkpoints , kpoint_grid_dim ) end if if ((. not . compute_band_gap )) then deallocate ( all_kpoints , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoints in read_band_energy' ) end if end if if (. not . on_root ) then call comms_recv ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( my_node_id ), root_id ) call comms_recv ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( my_node_id ), root_id ) call comms_recv ( kpoint_weight ( 1 ), num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( unit = band_unit ) band_energy = band_energy * H2eV efermi_castep = efermi_castep * H2eV ! Things that follow if ( nspins . lt . 2 ) then spin_polarised = . false . electrons_per_state = 2.0_dp else spin_polarised = . true . electrons_per_state = 1.0_dp end if time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read band energies  ' , time1 - time0 , ' (sec)' return 100 call io_error ( 'Error: Problem opening bands file in read_band_energy' ) end subroutine elec_read_band_energy !========================================================================= subroutine elec_read_band_energy_ordered !(band_energy,kpoint_r,kpoint_weight) !========================================================================= ! Read the .bands file in the kpoint list, kpoint weights and band energies ! also obtain, nkpoints, nspins, num_electrons(:),nbands, efermi_castep ! in the correct order. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_energy, efermi_castep, num_electrons ! spin_polarised, electrons_per_state, nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_constants , only : H2eV use od_cell , only : nkpoints , kpoint_r , kpoint_weight , cell_find_MP_grid ,& & real_lattice , kpoint_grid_dim , num_kpoints_on_node use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : io_file_unit , seedname , filename_len , stdout , io_time ,& & io_error use od_algorithms , only : algor_dist_array use od_parameters , only : iprint , compute_band_gap , kpoint_mp_grid , pdis implicit none integer :: inodes , ik , is , ib , band_unit , iall_kpoints , i integer :: ik_bandfile , ierr , str_pos character ( filename_len ) :: band_filename character ( len = 80 ) :: dummy real ( kind = dp ) :: time0 , time1 real ( kind = dp ), allocatable :: all_band_energy (:, :, :) real ( kind = dp ) :: dummy_kpt ( 4 ) time0 = io_time () ! Check that we haven't already read in the energies if ( allocated ( band_energy )) return !Open the bands file band_unit = io_file_unit () band_filename = trim ( seedname ) // \".bands\" ! Read the header from the bands file if ( on_root ) then open ( unit = band_unit , file = band_filename , status = \"old\" , form = 'formatted' , err = 100 ) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'k-points' ) read ( dummy ( str_pos + 8 :), * ) nkpoints read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'components' ) read ( dummy ( str_pos + 10 :), * ) nspins read ( band_unit , '(a)' ) dummy allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" str_pos = index ( dummy , 'electrons' ) read ( dummy ( str_pos + 10 :), * ) num_electrons (:) read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'eigenvalues' ) read ( dummy ( str_pos + 11 :), * ) nbands read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'units)' ) read ( dummy ( str_pos + 6 :), '(f12.4)' ) efermi_castep read ( band_unit , '(a)' ) dummy read ( band_unit , * ) real_lattice (:, 1 ) read ( band_unit , * ) real_lattice (:, 2 ) read ( band_unit , * ) real_lattice (:, 3 ) end if call comms_bcast ( nspins , 1 ) if (. not . on_root ) then allocate ( num_electrons ( nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate num_electrons\" end if call comms_bcast ( num_electrons ( 1 ), nspins ) call comms_bcast ( nkpoints , 1 ) call comms_bcast ( nbands , 1 ) call comms_bcast ( efermi_castep , 1 ) ! call algor_dist_array ( nkpoints , num_kpoints_on_node ) ! allocate ( band_energy ( 1 : nbands , 1 : nspins , 1 : num_kpoints_on_node ( 0 )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating band_energy in read_band_energy' ) allocate ( all_band_energy ( 1 : nbands , 1 : nspins , 1 : nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating all_band_energy in read_band_energy' ) allocate ( kpoint_weight ( 1 : num_kpoints_on_node ( 0 )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_weight in read_band_energy' ) allocate ( kpoint_r ( 1 : 3 , 1 : num_kpoints_on_node ( 0 )), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating kpoint_r in read_band_energy' ) if ( on_root ) then allocate ( all_kpoints ( 1 : 3 , nkpoints ), stat = ierr ) allocate ( all_kpoint_weight ( nkpoints ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating all_kpoints in read_band_energy' ) do ik = 1 , nkpoints read ( band_unit , '(a)' ) dummy str_pos = index ( dummy , 'K-point' ) dummy_kpt = 0 read ( dummy ( str_pos + 7 :), * ) ik_bandfile , dummy_kpt ( 1 ), dummy_kpt ( 2 ), dummy_kpt ( 4 ) do i = 1 , 3 all_kpoints ( i , ik_bandfile ) = dummy_kpt ( i ) end do all_kpoint_weight ( ik_bandfile ) = dummy_kpt ( 4 ) do is = 1 , nspins read ( band_unit , * ) dummy do ib = 1 , nbands read ( band_unit , * ) all_band_energy ( ib , is , ik_bandfile ) !NB spin <-> kpt swapped end do end do end do ! split bands across node-level arrays iall_kpoints = 0 do inodes = 0 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do i = 1 , 3 kpoint_r ( i , ik ) = all_kpoints ( i , ik + iall_kpoints ) end do kpoint_weight ( ik ) = all_kpoint_weight ( ik + iall_kpoints ) do is = 1 , nspins do ib = 1 , nbands band_energy ( ib , is , ik ) = all_band_energy ( ib , is , ik + iall_kpoints ) !NB spin <-> kpt swapped end do end do end do iall_kpoints = iall_kpoints + num_kpoints_on_node ( inodes ) ! distribute bands across kpoints if ( inodes /= 0 ) then call comms_send ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( 0 ), inodes ) call comms_send ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( 0 ), inodes ) call comms_send ( kpoint_weight ( 1 ), num_kpoints_on_node ( 0 ), inodes ) end if end do ! Do this here so we can free up the all_kpoints memory, unless we need it to calculate ! the kpoints at the band-gap or do a pdispersion if ( kpoint_mp_grid ( 1 ) > 0 ) then ! we must have set this manually kpoint_grid_dim = kpoint_mp_grid else call cell_find_MP_grid ( all_kpoints , nkpoints , kpoint_grid_dim ) end if if ((. not . compute_band_gap ) . and . (. not . pdis )) then deallocate ( all_kpoints , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoints in read_band_energy' ) deallocate ( all_band_energy , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_band_energy in read_band_energy' ) deallocate ( all_kpoint_weight , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem deallocating all_kpoint_weight in read_band_energy' ) end if end if if (. not . on_root ) then call comms_recv ( band_energy ( 1 , 1 , 1 ), nbands * nspins * num_kpoints_on_node ( 0 ), root_id ) call comms_recv ( kpoint_r ( 1 , 1 ), 3 * num_kpoints_on_node ( 0 ), root_id ) call comms_recv ( kpoint_weight ( 1 ), num_kpoints_on_node ( 0 ), root_id ) end if if ( on_root ) close ( unit = band_unit ) band_energy = band_energy * H2eV efermi_castep = efermi_castep * H2eV ! Things that follow if ( nspins . lt . 2 ) then spin_polarised = . false . electrons_per_state = 2.0_dp else spin_polarised = . true . electrons_per_state = 1.0_dp end if time1 = io_time () if ( on_root . and . iprint > 1 ) write ( stdout , '(1x,a40,f11.3,a)' ) 'Time to read band energies  ' , time1 - time0 , ' (sec)' return 100 call io_error ( 'Error: Problem opening bands file in read_band_energy' ) end subroutine elec_read_band_energy_ordered !========================================================================= subroutine elec_read_elnes_mat !========================================================================= ! Read the .bands file in the kpoint list, kpoint weights and band energies ! also obtain, nkpoints, nspins, num_electrons(:),nbands, efermi_castep !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: band_energy, efermi_castep, num_electrons ! spin_polarised, electrons_per_state, nspins,nbands !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_cell , only : num_kpoints_on_node use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : io_file_unit , seedname , filename_len , io_time ,& & io_error , stdout use od_parameters , only : legacy_file_format , devel_flag , iprint implicit none integer :: inodes , ik , ns , nb , indx integer :: ierr , elnes_unit , orb , loop character ( filename_len ) :: elnes_filename real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp time0 = io_time () ! Check that we haven't already read in the energies if ( allocated ( elnes_mat )) return !Open the elnes sfile if ( on_root ) then elnes_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then elnes_filename = trim ( seedname ) // \".eels_mat\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading elnes matrix elements from file: ' // trim ( elnes_filename ) open ( unit = elnes_unit , file = elnes_filename , form = 'unformatted' , err = 100 , status = 'old' ) else elnes_filename = trim ( seedname ) // \".elnes_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading elnes matrix elements from file: ' // trim ( elnes_filename ) open ( unit = elnes_unit , file = elnes_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( elnes_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of elnes_bin file. Update optados!' ) read ( elnes_unit ) elnesfile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( elnesfile_header ) end if read ( elnes_unit ) elnes_mwab % norbitals read ( elnes_unit ) elnes_mwab % nbands read ( elnes_unit ) elnes_mwab % nkpoints read ( elnes_unit ) elnes_mwab % nspins ! check these agree with band data? allocate ( elnes_orbital % ion_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%ion_no' ) allocate ( elnes_orbital % species_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%species_no' ) allocate ( elnes_orbital % rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%rank_in_species' ) allocate ( elnes_orbital % shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%shell' ) allocate ( elnes_orbital % am_channel ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel' ) allocate ( elnes_orbital % am_channel_name ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel_name' ) read ( elnes_unit ) elnes_orbital % species_no ( 1 : elnes_mwab % norbitals ) read ( elnes_unit ) elnes_orbital % rank_in_species ( 1 : elnes_mwab % norbitals ) read ( elnes_unit ) elnes_orbital % shell ( 1 : elnes_mwab % norbitals ) read ( elnes_unit ) elnes_orbital % am_channel ( 1 : elnes_mwab % norbitals ) end if call comms_bcast ( elnes_mwab % norbitals , 1 ) call comms_bcast ( elnes_mwab % nbands , 1 ) call comms_bcast ( elnes_mwab % nkpoints , 1 ) call comms_bcast ( elnes_mwab % nspins , 1 ) if (. not . on_root ) then allocate ( elnes_orbital % ion_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%ion_no' ) allocate ( elnes_orbital % species_no ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%species_no' ) allocate ( elnes_orbital % rank_in_species ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%rank_in_species' ) allocate ( elnes_orbital % shell ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbitall%shell' ) allocate ( elnes_orbital % am_channel ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel' ) allocate ( elnes_orbital % am_channel_name ( elnes_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( ' Error : elec_read_elnes_mat cannot allocate elnes_orbital%am_channel_name' ) end if call comms_bcast ( elnes_orbital % species_no ( 1 ), elnes_mwab % norbitals ) call comms_bcast ( elnes_orbital % rank_in_species ( 1 ), elnes_mwab % norbitals ) call comms_bcast ( elnes_orbital % shell ( 1 ), elnes_mwab % norbitals ) call comms_bcast ( elnes_orbital % am_channel ( 1 ), elnes_mwab % norbitals ) ! assume same data distribution as bands allocate ( elnes_mat ( 1 : elnes_mwab % norbitals , 1 : elnes_mwab % nbands , 1 : 3 , & 1 : num_kpoints_on_node ( 0 ), 1 : elnes_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error: Problem allocating elnes_mat in elec_read_elnes_mat' ) if ( on_root ) then if ( legacy_file_format ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do ns = 1 , elnes_mwab % nspins do orb = 1 , elnes_mwab % norbitals do nb = 1 , elnes_mwab % nbands read ( elnes_unit ) ( elnes_mat ( orb , nb , indx , ik , ns ), indx = 1 , 3 ) end do end do end do end do call comms_send ( elnes_mat ( 1 , 1 , 1 , 1 , 1 ), elnes_mwab % norbitals * elnes_mwab % nbands * 3 * & nspins * num_kpoints_on_node ( 0 ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do ns = 1 , elnes_mwab % nspins do orb = 1 , elnes_mwab % norbitals do nb = 1 , elnes_mwab % nbands read ( elnes_unit ) ( elnes_mat ( orb , nb , indx , ik , ns ), indx = 1 , 3 ) end do end do end do end do else ! sane format do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) do ns = 1 , elnes_mwab % nspins read ( elnes_unit ) ((( elnes_mat ( orb , nb , indx , ik , ns ), orb = 1 , elnes_mwab % norbitals ), & nb = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do call comms_send ( elnes_mat ( 1 , 1 , 1 , 1 , 1 ), elnes_mwab % norbitals * elnes_mwab % nbands * 3 * nspins * & num_kpoints_on_node ( 0 ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) do ns = 1 , elnes_mwab % nspins read ( elnes_unit ) ((( elnes_mat ( orb , nb , indx , ik , ns ), orb = 1 , elnes_mwab % norbitals ), & nb = 1 , elnes_mwab % nbands ), indx = 1 , 3 ) end do end do end if end if if (. not . on_root ) then call comms_recv ( elnes_mat ( 1 , 1 , 1 , 1 , 1 ), elnes_mwab % norbitals * elnes_mwab % nbands * 3 * nspins * & num_kpoints_on_node ( 0 ), root_id ) end if if ( on_root ) close ( elnes_unit ) call elec_elnes_find_channel_names () time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to read Elnes Matrix Elements                     & &      ' , time1 - time0 , ' (sec) +' end if return 100 call io_error ( 'Error: Problem opening elnes file in elec_read_elnes_mat' ) 102 call io_error ( 'Error: Problem opening elnes_bin file in elec_read_elnes_mat' ) end subroutine elec_read_elnes_mat !========================================================================= subroutine elec_elnes_find_channel_names !========================================================================= ! ! fill in some extra indexing data ! Moved from within elec_read_elnes_mat when I made od2od ! AJM 5/12/2019 use od_io , only : io_error implicit none integer :: loop !  elnes_mwab is a module variable so don't declare. do loop = 1 , elnes_mwab % norbitals if ( elnes_orbital % am_channel ( loop ) == 1 ) then elnes_orbital % am_channel ( loop ) = 0 elnes_orbital % am_channel_name ( loop ) = 's' elseif ( elnes_orbital % am_channel ( loop ) == 2 ) then elnes_orbital % am_channel ( loop ) = 1 elnes_orbital % am_channel_name ( loop ) = 'px' elseif ( elnes_orbital % am_channel ( loop ) == 3 ) then elnes_orbital % am_channel ( loop ) = 1 elnes_orbital % am_channel_name ( loop ) = 'py' elseif ( elnes_orbital % am_channel ( loop ) == 4 ) then elnes_orbital % am_channel ( loop ) = 1 elnes_orbital % am_channel_name ( loop ) = 'pz' elseif ( elnes_orbital % am_channel ( loop ) == 5 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dzz' elseif ( elnes_orbital % am_channel ( loop ) == 6 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dzy' elseif ( elnes_orbital % am_channel ( loop ) == 7 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dzx' elseif ( elnes_orbital % am_channel ( loop ) == 8 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dxx-yy' elseif ( elnes_orbital % am_channel ( loop ) == 9 ) then elnes_orbital % am_channel ( loop ) = 2 elnes_orbital % am_channel_name ( loop ) = 'dxy' elseif ( elnes_orbital % am_channel ( loop ) == 10 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fxxx' elseif ( elnes_orbital % am_channel ( loop ) == 11 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fyyy' elseif ( elnes_orbital % am_channel ( loop ) == 12 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fzzz' elseif ( elnes_orbital % am_channel ( loop ) == 13 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fxyz' elseif ( elnes_orbital % am_channel ( loop ) == 14 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fz(xx-yy)' elseif ( elnes_orbital % am_channel ( loop ) == 15 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fy(zz-xx)' elseif ( elnes_orbital % am_channel ( loop ) == 16 ) then elnes_orbital % am_channel ( loop ) = 3 elnes_orbital % am_channel_name ( loop ) = 'fx(yy-zz)' else call io_error ( ' Error : unknown angular momentum state in elec_elnes_find_channel_names' ) end if end do end subroutine elec_elnes_find_channel_names !========================================================================= subroutine elec_elnes_find_channel_numbers !========================================================================= ! ! The elnes_bin has channel numbers 1-16 internally optados thinks about ! channel names. So we need to be able to go back and forth. ! ! CASTEP (hence the bin file) and OptaDOS think about am_channel numbers ! differently. To keep consistent we convert to CASTEP's numbering scheme ! before we write out. ! AJM 5/12/2019 use od_io , only : io_error implicit none integer :: loop do loop = 1 , elnes_mwab % norbitals selectcase ( trim ( elnes_orbital % am_channel_name ( loop ))) case ( 's' ) elnes_orbital % am_channel ( loop ) = 1 case ( 'px' ) elnes_orbital % am_channel ( loop ) = 2 case ( 'py' ) elnes_orbital % am_channel ( loop ) = 3 case ( 'pz' ) elnes_orbital % am_channel ( loop ) = 4 case ( 'dzz' ) elnes_orbital % am_channel ( loop ) = 5 case ( 'dzy' ) elnes_orbital % am_channel ( loop ) = 6 case ( 'dzx' ) elnes_orbital % am_channel ( loop ) = 7 case ( 'dxx-yy' ) elnes_orbital % am_channel ( loop ) = 8 case ( 'dxy' ) elnes_orbital % am_channel ( loop ) = 9 case ( 'fxxx' ) elnes_orbital % am_channel ( loop ) = 10 case ( 'fyyy' ) elnes_orbital % am_channel ( loop ) = 11 case ( 'fzzz' ) elnes_orbital % am_channel ( loop ) = 12 case ( 'fxyz' ) elnes_orbital % am_channel ( loop ) = 13 case ( 'fz(xx-yy)' ) elnes_orbital % am_channel ( loop ) = 14 case ( 'fy(zz-xx)' ) elnes_orbital % am_channel ( loop ) = 15 case ( 'fx(yy-zz)' ) elnes_orbital % am_channel ( loop ) = 16 case default call io_error ( ' Error : unknown angular momentum state in elec_elnes_find_channel_numbers' ) end select end do end subroutine elec_elnes_find_channel_numbers !========================================================================= subroutine elec_pdos_read !========================================================================= ! Read in the full pdos_weights. Write out any variables that we find on the ! way. These will be checked for consistency in the dos module. We can't do it ! yet as we haven't read the bands file. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: pw, pdos_weights, pdos_orbital !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Written by  A J Morris                                         Dec 2010 !========================================================================= use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : stdout , io_file_unit , io_error , seedname , filename_len use od_cell , only : num_kpoints_on_node use od_parameters , only : legacy_file_format , devel_flag , iprint implicit none ! Band indices used in the read-in of the pdos real ( kind = dp ) :: dummyr1 , dummyr2 , dummyr3 integer :: dummyi , ib , ik , is integer :: pdos_in_unit , ierr , inodes logical :: full_debug_pdos_weights = . false . character ( filename_len ) :: pdos_filename real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp if ( allocated ( pdos_weights )) return !-------------------------------------------------------------------------! ! R E A D   T H E   D A T A   H E A D E R if ( on_root ) then pdos_in_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then pdos_filename = trim ( seedname ) // \".pdos_weights\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , form = 'unformatted' , err = 100 , status = 'old' ) else pdos_filename = trim ( seedname ) // \".pdos_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( pdos_in_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of pdos_bin file. Update optados!' ) read ( pdos_in_unit ) pdosfile_header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( pdosfile_header ) end if read ( pdos_in_unit ) pdos_mwab % nkpoints read ( pdos_in_unit ) pdos_mwab % nspins read ( pdos_in_unit ) pdos_mwab % norbitals read ( pdos_in_unit ) pdos_mwab % nbands if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) \"pdos_mwab%nkpoints= \" , pdos_mwab % nkpoints write ( stdout , * ) \"pdos_mwab%nspins= \" , pdos_mwab % nspins write ( stdout , * ) \"pdos_mwab%norbitals= \" , pdos_mwab % norbitals write ( stdout , * ) \"pdos_mwab%nbands= \" , pdos_mwab % nbands write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) read ( pdos_in_unit ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! end if call comms_bcast ( pdos_mwab % norbitals , 1 ) call comms_bcast ( pdos_mwab % nbands , 1 ) call comms_bcast ( pdos_mwab % nkpoints , 1 ) call comms_bcast ( pdos_mwab % nspins , 1 ) if (. not . on_root ) then allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) end if call comms_bcast ( pdos_orbital % species_no ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % rank_in_species ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % am_channel ( 1 ), pdos_mwab % norbitals ) !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A allocate ( nbands_occ ( 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate nbands_occ\" allocate ( pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : num_kpoints_on_node ( my_node_id ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate pdos_weights\" if ( on_root ) then do inodes = 1 , num_nodes - 1 do ik = 1 , num_kpoints_on_node ( inodes ) ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit ) dummyi , dummyr1 , dummyr2 , dummyr3 do is = 1 , pdos_mwab % nspins read ( pdos_in_unit ) dummyi ! this is the spin number read ( pdos_in_unit ) nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) write ( nbands_occ ( ik , is )) do ib = 1 , nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) ib , ik , is write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if read ( pdos_in_unit ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) end do end do end do call comms_send ( pdos_weights ( 1 , 1 , 1 , 1 ), pdos_mwab % norbitals * pdos_mwab % nbands * & nspins * num_kpoints_on_node ( inodes ), inodes ) end do do ik = 1 , num_kpoints_on_node ( 0 ) ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit ) dummyi , dummyr1 , dummyr2 , dummyr3 do is = 1 , pdos_mwab % nspins read ( pdos_in_unit ) dummyi ! this is the spin number read ( pdos_in_unit ) nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) write ( stdout , * ) nbands_occ ( ik , is ) do ib = 1 , nbands_occ ( ik , is ) if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) ib , ik , is write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if read ( pdos_in_unit ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) if ( full_debug_pdos_weights ) write ( stdout , * ) pdos_weights ( 1 : pdos_mwab % norbitals , ib , ik , is ) end do end do end do end if if (. not . on_root ) then call comms_recv ( pdos_weights ( 1 , 1 , 1 , 1 ), pdos_mwab % norbitals * pdos_mwab % nbands * & nspins * num_kpoints_on_node ( my_node_id ), root_id ) end if if ( on_root ) close ( pdos_in_unit ) return 100 call io_error ( 'Error: Problem opening pdos_weights file in elec_pdos_read' ) 102 call io_error ( 'Error: Problem opening pdos_bin file in elec_pdos_read' ) end subroutine elec_pdos_read !========================================================================= subroutine elec_pdis_read !========================================================================= ! Read in the full pdos_weights, in correct kpoint path order. !------------------------------------------------------------------------- ! Arguments: None !------------------------------------------------------------------------- ! Parent module variables: pw, pdos_weights, pdos_orbital !------------------------------------------------------------------------- ! Modules used:  See below !------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------- ! Necessary conditions: None !------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------- ! Adapted by M L Evans from elec_pdos_read written by A J Morris Aug 2018 !========================================================================= use od_comms , only : comms_bcast , comms_send , comms_recv , num_nodes , my_node_id ,& & on_root , root_id use od_io , only : stdout , io_file_unit , io_error , seedname , filename_len use od_cell , only : num_kpoints_on_node , nkpoints use od_parameters , only : legacy_file_format , devel_flag , iprint implicit none ! Band indices used in the read-in of the pdos integer , allocatable , dimension (:, :) :: all_nbands_occ real ( kind = dp ) :: dummyr1 , dummyr2 , dummyr3 integer :: dummyk , cachek , dummyi , ib , ik , is , stride , iorb integer :: pdos_in_unit , ierr , inodes , iall_kpoints logical :: full_debug_pdos_weights = . false . character ( filename_len ) :: pdos_filename character ( len = 80 ) :: header real ( kind = dp ) :: time0 , time1 , file_version real ( kind = dp ), parameter :: file_ver = 1.0_dp if ( allocated ( pdos_weights )) return !-------------------------------------------------------------------------! ! R E A D   T H E   D A T A   H E A D E R !-------------------------------------------------------------------------! if ( on_root ) then pdos_in_unit = io_file_unit () if ( index ( devel_flag , 'old_filename' ) > 0 . or . legacy_file_format ) then pdos_filename = trim ( seedname ) // \".pdos_weights\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , form = 'unformatted' , err = 100 , status = 'old' ) else pdos_filename = trim ( seedname ) // \".pdos_bin\" if ( iprint > 1 ) write ( stdout , '(1x,a)' ) 'Reading pdos weights from file: ' // trim ( pdos_filename ) open ( unit = pdos_in_unit , file = pdos_filename , status = \"old\" , form = 'unformatted' , err = 102 ) read ( pdos_in_unit ) file_version if (( file_version - file_ver ) > 0.001_dp ) & call io_error ( 'Error: Trying to read newer version of pdos_bin file. Update optados!' ) read ( pdos_in_unit ) header if ( iprint > 1 ) write ( stdout , '(1x,a)' ) trim ( header ) end if read ( pdos_in_unit ) pdos_mwab % nkpoints read ( pdos_in_unit ) pdos_mwab % nspins read ( pdos_in_unit ) pdos_mwab % norbitals read ( pdos_in_unit ) pdos_mwab % nbands if ( full_debug_pdos_weights ) then write ( stdout , * ) \" ***** F U L L _ D E B U G _ P D O S _ W E I G H T S ***** \" write ( stdout , * ) \"pdos_mwab%nkpoints= \" , pdos_mwab % nkpoints write ( stdout , * ) \"pdos_mwab%nspins= \" , pdos_mwab % nspins write ( stdout , * ) \"pdos_mwab%norbitals= \" , pdos_mwab % norbitals write ( stdout , * ) \"pdos_mwab%nbands= \" , pdos_mwab % nbands write ( stdout , * ) \"   **** ***** *****  ***** ***** *****  ***** ***** *****  \" end if allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) read ( pdos_in_unit ) pdos_orbital % species_no ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % rank_in_species ( 1 : pdos_mwab % norbitals ) read ( pdos_in_unit ) pdos_orbital % am_channel ( 1 : pdos_mwab % norbitals ) !-------------------------------------------------------------------------! call comms_bcast ( pdos_mwab % norbitals , 1 ) call comms_bcast ( pdos_mwab % nbands , 1 ) call comms_bcast ( pdos_mwab % nkpoints , 1 ) call comms_bcast ( pdos_mwab % nspins , 1 ) end if if (. not . on_root ) then allocate ( pdos_orbital % species_no ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % rank_in_species ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) allocate ( pdos_orbital % am_channel ( pdos_mwab % norbitals ), stat = ierr ) if ( ierr /= 0 ) call io_error ( \" Error : cannot allocate pdos_orbital\" ) end if call comms_bcast ( pdos_orbital % species_no ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % rank_in_species ( 1 ), pdos_mwab % norbitals ) call comms_bcast ( pdos_orbital % am_channel ( 1 ), pdos_mwab % norbitals ) !-------------------------------------------------------------------------! ! N O W   R E A D   T H E   D A T A allocate ( all_nbands_occ ( 1 : nkpoints , 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate all_nbands_occ\" allocate ( pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : num_kpoints_on_node ( 0 ), 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate pdos_weights\" allocate ( all_pdos_weights ( 1 : pdos_mwab % norbitals , 1 : pdos_mwab % nbands , & 1 : nkpoints , 1 : pdos_mwab % nspins ), stat = ierr ) if ( ierr /= 0 ) stop \" Error : cannot allocate all_pdos_weights\" if ( on_root ) then ! Read in the k-points in the correct path ordering, not the file ordering cachek = 0 stride = 1 do ik = 1 , nkpoints ! The kpoint number, followed by the kpoint-vector read ( pdos_in_unit ) dummyk , dummyr1 , dummyr2 , dummyr3 if ( ik == 2 ) then stride = dummyk - cachek end if if (( dummyk - cachek ) < stride ) then if ( mod ( ik , ( nkpoints / stride )) == 1 ) then dummyk = dummyk else dummyk = cachek + stride end if end if cachek = dummyk do is = 1 , pdos_mwab % nspins read ( pdos_in_unit ) dummyi ! this is the spin number read ( pdos_in_unit ) all_nbands_occ ( dummyk , is ) do ib = 1 , all_nbands_occ ( dummyk , is ) read ( pdos_in_unit ) all_pdos_weights ( 1 : pdos_mwab % norbitals , ib , dummyk , is ) end do end do end do close ( pdos_in_unit ) end if call comms_bcast ( all_pdos_weights ( 1 , 1 , 1 , 1 ), size ( all_pdos_weights )) iall_kpoints = 0 do inodes = 0 , my_node_id - 1 iall_kpoints = iall_kpoints + inodes * num_kpoints_on_node ( inodes ) end do do ik = 1 , num_kpoints_on_node ( my_node_id ) do is = 1 , pdos_mwab % nspins do ib = 1 , all_nbands_occ ( ik + iall_kpoints , is ) do iorb = 1 , pdos_mwab % norbitals pdos_weights ( iorb , ib , ik , is ) = all_pdos_weights ( iorb , ib , ik + iall_kpoints , is ) end do end do end do end do deallocate ( all_pdos_weights ) return 100 call io_error ( 'Error: Problem opening pdos_weights file in elec_pdis_read' ) 102 call io_error ( 'Error: Problem opening pdos_bin file in elec_pdis_read' ) end subroutine elec_pdis_read subroutine elec_dealloc_pdos use od_io , only : io_error implicit none integer :: ierr if ( allocated ( pdos_weights )) then deallocate ( pdos_weights , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating pdos_weights in elec_dealloc_pdos' ) end if end subroutine elec_dealloc_pdos subroutine elec_dealloc_elnes use od_io , only : io_error implicit none integer :: ierr if ( allocated ( elnes_mat )) then deallocate ( elnes_mat , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating elnes_mat in elec_dealloc_elnes' ) end if !    if(allocated(elnes_orbital)) then !       deallocate(elnes_orbital,stat=ierr) !       if (ierr/=0) call io_error('Error in deallocating elnes_orbital in elec_dealloc_elnes') !    end if end subroutine elec_dealloc_elnes subroutine elec_dealloc_band_gradient use od_io , only : io_error implicit none integer :: ierr if ( allocated ( band_gradient )) then deallocate ( band_gradient , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating band_gradient in elec_dealloc_band_gradient' ) end if end subroutine elec_dealloc_band_gradient subroutine elec_dealloc_optical use od_io , only : io_error implicit none integer :: ierr if ( allocated ( optical_mat )) then deallocate ( optical_mat , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error in deallocating optical_mat in elec_dealloc_optical' ) end if end subroutine elec_dealloc_optical end module od_electronic","tags":"","loc":"sourcefile/electronic.f90.html"},{"title":"io.f90 – OptaDOS","text":"This file depends on sourcefile~~io.f90~~EfferentGraph sourcefile~io.f90 io.f90 sourcefile~constants.f90 constants.f90 sourcefile~io.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~io.f90~~AfferentGraph sourcefile~io.f90 io.f90 sourcefile~optics.f90 optics.f90 sourcefile~optics.f90->sourcefile~io.f90 sourcefile~cell.f90 cell.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~optics.f90->sourcefile~xmgrace_utils.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~pdis.f90->sourcefile~io.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~pdis.f90->sourcefile~algorithms.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~dos.f90 dos.f90 sourcefile~dos.f90->sourcefile~io.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~dos.f90->sourcefile~xmgrace_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~io.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~optados.f90->sourcefile~cell.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~io.f90 sourcefile~od2od.f90->sourcefile~cell.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~projection_utils.f90->sourcefile~io.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~io.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~algorithms.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~jdos_utils.f90->sourcefile~io.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~jdos.f90->sourcefile~io.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~jdos.f90->sourcefile~xmgrace_utils.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~core.f90->sourcefile~io.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~core.f90->sourcefile~xmgrace_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_io Source Code io.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This module contains GPL routines from Wannier90           ! ! Copyright (C) 2007 Jonathan Yates, Arash Mostofi,          ! !  Young-Su Lee, Nicola Marzari, Ivo Souza, David Vanderbilt ! !                                                            ! ! This version (c) Jonathan Yates 2010                       ! !                                                            ! ! This file is distributed under the terms of the GNU        ! ! General Public License. See the file `COPYING' in          ! ! the root directory of the present distribution, or         ! ! http://www.gnu.org/copyleft/gpl.txt .                      ! !                                                            ! !------------------------------------------------------------! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! module od_io use od_constants , only : dp implicit none private integer , public , save :: stdout integer , public , save :: stderr integer , parameter , public :: filename_len = 80 character ( len = filename_len ), public , save :: seedname character ( len = filename_len ), public , save :: options character ( len = filename_len ), public , save :: temp_dir integer , parameter , public :: maxlen = 120 ! Max column width of input file public :: io_get_seedname public :: io_time public :: io_date public :: io_error public :: io_file_unit contains subroutine io_get_seedname () !==================================================================! !                                                                  ! ! Get the seedname from the commandline                            ! ! Note iargc and getarg are not standard                           ! ! Some platforms require them to be external or provide            ! ! equivalent routines. Not a problem in f2003!                     ! !=================================================================== implicit none integer :: num_arg num_arg = command_argument_count () if ( num_arg == 0 ) then seedname = '--help' elseif ( num_arg == 1 ) then call get_command_argument ( 1 , seedname ) ! Added by F. Mildner to allow for multi_output runs elseif ( num_arg == 3 ) then call get_command_argument ( 1 , options ) call get_command_argument ( 2 , temp_dir ) call get_command_argument ( 3 , seedname ) else call get_command_argument ( 1 , seedname ) !do something else end if ! If on the command line the whole seedname.odi was passed, I strip the last \".win\" if ( len ( trim ( seedname )) . ge . 5 ) then if ( seedname ( len ( trim ( seedname )) - 4 + 1 :) . eq . \".odi\" ) then seedname = seedname (: len ( trim ( seedname )) - 4 ) end if end if end subroutine io_get_seedname !==================================================================! subroutine io_error ( error_msg ) !==================================================================! !                                                                  ! ! Aborts giving error message                                      ! !                                                                  ! !=================================================================== implicit none character ( len =* ), intent ( in ) :: error_msg write ( stderr , * ) 'Exiting.......' write ( stderr , '(1x,a)' ) trim ( error_msg ) close ( stderr ) error stop \"Optados error: examine the output/error file for details\" end subroutine io_error !==================================================================! subroutine io_date ( cdate , ctime ) !==================================================================! !                                                                  ! !     Returns two strings containing the date and the time         ! !     in human-readable format. Uses a standard f90 call.          ! !                                                                  ! !=================================================================== implicit none character ( len = 11 ), intent ( out ) :: cdate character ( len = 9 ), intent ( out ) :: ctime character ( len = 3 ), dimension ( 12 ) :: months data months / 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , & 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' / integer date_time ( 8 ) ! call date_and_time ( values = date_time ) ! write ( cdate , '(i2,1x,a3,1x,i4)' ) date_time ( 3 ), months ( date_time ( 2 )), date_time ( 1 ) write ( ctime , '(i2.2,\":\",i2.2,\":\",i2.2)' ) date_time ( 5 ), date_time ( 6 ), date_time ( 7 ) end subroutine io_date !==================================================================! function io_time () !==================================================================! !                                                                  ! ! Returns elapsed CPU time in seconds since its first call         ! ! uses standard f90 call                                           ! !                                                                  ! !=================================================================== use od_constants , only : dp implicit none real ( kind = dp ) :: io_time ! t0 contains the time of the first call ! t1 contains the present time real ( kind = dp ) :: t0 , t1 logical :: first = . true . save first , t0 ! call cpu_time ( t1 ) ! if ( first ) then t0 = t1 io_time = 0.0_dp first = . false . else io_time = t1 - t0 end if return end function io_time !==================================================================! function io_file_unit () !==================================================================! !                                                                  ! ! Returns an unused unit number                                    ! ! (so we can open a file on that unit                              ! !                                                                  ! !=================================================================== implicit none integer :: io_file_unit , unit logical :: file_open unit = 9 file_open = . true . do while ( file_open ) unit = unit + 1 inquire ( unit , OPENED = file_open ) end do io_file_unit = unit return end function io_file_unit end module od_io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"pdis.f90 – OptaDOS","text":"This file depends on sourcefile~~pdis.f90~~EfferentGraph sourcefile~pdis.f90 pdis.f90 sourcefile~constants.f90 constants.f90 sourcefile~pdis.f90->sourcefile~constants.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~comms.f90 comms.F90 sourcefile~pdis.f90->sourcefile~comms.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~io.f90 io.f90 sourcefile~pdis.f90->sourcefile~io.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~pdis.f90->sourcefile~algorithms.f90 sourcefile~cell.f90 cell.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~constants.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90->sourcefile~comms.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~io.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pdis.f90~~AfferentGraph sourcefile~pdis.f90 pdis.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~pdis.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_pdis Source Code pdis.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! MODULE od_pdis ! This module implements output of projected dispersion curves using ! routines from od_projection_utils. !-------------------------------------------------------------------------! module od_pdis !-------------------------------------------------------------------------! ! G L O B A L   V A R I A B L E S !-------------------------------------------------------------------------! use od_constants , only : dp use od_projection_utils , only : projection_array , matrix_weights , max_am , proj_symbol , num_proj !-------------------------------------------------------------------------! private public :: pdis_calculate contains subroutine pdis_calculate use od_electronic , only : elec_pdis_read , efermi_castep , efermi use od_projection_utils , only : projection_merge , projection_get_string , projection_analyse_orbitals use od_comms , only : on_root use od_parameters , only : set_efermi_zero , iprint use od_io , only : stdout implicit none if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                 Projected Dispersion Curve Calculation                     +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) end if ! read in the pdos weights call elec_pdis_read ! look at the orbitals and figure out which atoms / states we have call projection_analyse_orbitals ! parse the pdis string to see what we want call projection_get_string ! form the right matrix elements call projection_merge ! set efermi if ( on_root ) write ( stdout , '(1x,a1,a46,f8.4,a3,12x,a8)' ) \"|\" ,& & \" Set fermi energy from file : \" , efermi_castep , \" eV\" , \"  <- EfC\" efermi = efermi_castep ! write everything out if ( on_root . and . ( iprint > 2 )) then call pdis_report_projectors end if if ( on_root ) then call pdis_write end if end subroutine pdis_calculate !=============================================================================== subroutine pdis_write !=============================================================================== ! Write out the pdis that was requested. Write them all to the same file, kpoint ! by kpoint. !=============================================================================== use od_io , only : seedname implicit none character ( len = 512 ) :: name ! write everything to one file name = trim ( seedname ) // '.pdis.dat' call write_pdis_to_file ( 1 , num_proj , name ) end subroutine pdis_write subroutine write_pdis_to_file ( start_proj , stop_proj , name ) !=============================================================================== ! Write out projectors, start_proj, stop_proj, to file name, one kpoint at a time !=============================================================================== use od_parameters , only : iprint , set_efermi_zero use od_algorithms , only : channel_to_am use od_electronic , only : pdos_mwab , all_kpoints , band_energy , efermi use od_cell , only : atoms_species_num , num_species , nkpoints use od_io , only : io_file_unit , io_error , io_date , stdout implicit none integer , intent ( in ) :: start_proj , stop_proj character ( len = 512 ), intent ( in ) :: name character ( len = 11 ) :: cdate character ( len = 9 ) :: ctime character ( len = 20 ) :: string integer :: iproj , iam , ispecies_num , ispecies integer :: i , pdis_file , ierr integer :: N , n_eigen if ( set_efermi_zero ) then band_energy = band_energy - efermi end if write ( string , '(I4,\"(x,es14.7)\")' ) ( stop_proj - start_proj ) + 1 pdis_file = io_file_unit () open ( unit = pdis_file , file = trim ( name ), iostat = ierr ) if ( iprint > 2 ) write ( stdout , '(1x,a30,a30,17x,a1)' ) \"| Writing PDIS projectors to: \" , trim ( name ), \"|\" if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open output file in pdis: pdis_write\" ) write ( pdis_file , * ) \"##############################################################################\" write ( pdis_file , * ) \"#\" write ( pdis_file , * ) \"#                  O p t a D O S   o u t p u t   f i l e \" write ( pdis_file , '(1x,a1)' ) \"#\" call io_date ( cdate , ctime ) write ( pdis_file , * ) '#  Generated on ' , cdate , ' at ' , ctime write ( pdis_file , '(1x,a78)' ) \"##############################################################################\" write ( pdis_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' write ( pdis_file , '(1a,a)' ) '#' , '|                    Projected Dispersion Curve -- Projectors                |' write ( pdis_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' if ( pdos_mwab % nspins > 1 ) then call io_error ( 'pDIS not implemented for multiple spin channels.' ) else do iproj = start_proj , stop_proj write ( pdis_file , '(1a,a1,a12,i4,a10,50x,a1)' ) '#' , '|' , ' Projector: ' , iproj , ' contains:' , '|' write ( pdis_file , '(1a,a1,a16,10x,a14,36x,a1)' ) '#' , '|' , ' Atom ' , ' AngM Channel ' , '|' do ispecies = 1 , num_species do ispecies_num = 1 , atoms_species_num ( ispecies ) do iam = 1 , max_am if ( projection_array ( ispecies , ispecies_num , iam , iproj ) == 1 ) then write ( pdis_file , '(1a,a1,a13,i3,a18,42x,a1)' ) \"#\" , \"|\" , proj_symbol ( ispecies ), & & ispecies_num , channel_to_am ( iam ), '|' end if end do end do end do write ( pdis_file , '(1a,a)' ) '#' , '+----------------------------------------------------------------------------+' end do do N = 1 , nkpoints write ( pdis_file , '(a10, i4, a10, es18.7, es18.7, es18.7)' ) 'K-point   ' , N , '     ' , ( all_kpoints ( i , N ), i = 1 , 3 ) do n_eigen = 1 , pdos_mwab % nbands write ( pdis_file , '(es20.7,' // trim ( string ) // ')' ) band_energy ( n_eigen , 1 , N ), & ( matrix_weights ( i , n_eigen , N , 1 ), i = start_proj , stop_proj ) end do end do end if close ( pdis_file ) end subroutine write_pdis_to_file subroutine pdis_report_projectors use od_algorithms , only : channel_to_am use od_cell , only : atoms_species_num , num_species use od_io , only : stdout implicit none integer :: iproj , iam , ispecies_num , ispecies write ( stdout , * ) write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' write ( stdout , '(1x,a)' ) '|                    Projected Dispersion Curve -- Projectors                |' write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' do iproj = 1 , num_proj write ( stdout , '(1x,a1,a12,i4,a10,50x,a1)' ) '|' , ' Projector: ' , iproj , ' contains:' , '|' write ( stdout , '(1x,a1,a16,10x,a14,36x,a1)' ) '|' , ' Atom ' , ' AngM Channel ' , '|' do ispecies = 1 , num_species do ispecies_num = 1 , atoms_species_num ( ispecies ) do iam = 1 , max_am if ( projection_array ( ispecies , ispecies_num , iam , iproj ) == 1 ) then write ( stdout , '(1x,a1,a13,i3,a18,42x,a1)' ) \"|\" , proj_symbol ( ispecies ), & ispecies_num , channel_to_am ( iam ), '|' !, \" |  DEBUG :\",  ispecies ,iam end if end do end do end do write ( stdout , '(1x,a)' ) '+----------------------------------------------------------------------------+' end do end subroutine pdis_report_projectors end module od_pdis","tags":"","loc":"sourcefile/pdis.f90.html"},{"title":"dos.f90 – OptaDOS","text":"This file depends on sourcefile~~dos.f90~~EfferentGraph sourcefile~dos.f90 dos.f90 sourcefile~constants.f90 constants.f90 sourcefile~dos.f90->sourcefile~constants.f90 sourcefile~io.f90 io.f90 sourcefile~dos.f90->sourcefile~io.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~comms.f90 comms.F90 sourcefile~dos.f90->sourcefile~comms.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~dos.f90->sourcefile~xmgrace_utils.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~cell.f90 cell.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~dos.f90~~AfferentGraph sourcefile~dos.f90 dos.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~dos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_dos Source Code dos.f90 Source Code !-*- mode: F90; mode: font-lock; column-number-mode: true -*-! ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=============================================================================== module od_dos use od_constants , only : dp !use od_dos_utils, only : dos_utils_calculate implicit none !------------------------------------------------------------------------------- ! P U B L I C   F U N C T I O N S public :: dos_calculate contains subroutine dos_calculate !=============================================================================== ! Main routine in dos module, drives the calculation of density of states for ! both task : dos and also if it is required elsewhere. !------------------------------------------------------------------------------- ! Arguments: matrix_weigths (in) (opt) : LCAO or other weightings for DOS !            weighted_dos   (out)(opt) : Output DOS weigthed by matrix_weights !------------------------------------------------------------------------------- ! Parent Module Varables Used: mw, E, dos_adaptive, dos_fixed, dos_linear ! intdos_adaptive, intdos_fixed, intdos_linear, efermi_fixed, efermi_adaptive ! efermi_linear, delta_bins, calc_weighted_dos !------------------------------------------------------------------------------- ! Modules Used: see below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: One of linear, adaptive or fixed must be .true. !------------------------------------------------------------------------------- ! Known Worries: (1) If more than one of linear, adaptive or fixed are set it ! uses the most complicated method. ! (2) It should be possible to pass optioinal arguments to sub programs as ! optional argumnets without checking whether they are there or not. g95 will ! allow this behaviour. gfotran will not. !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_io , only : stdout , io_time use od_dos_utils , only : E , dos_fixed , intdos_fixed , dos_adaptive , & & intdos_adaptive , dos_linear , intdos_linear , dos_utils_calculate ,& & dos_utils_compute_dos_at_efermi , dos_utils_compute_bandgap ,& & dos_utils_compute_band_energies , dos_utils_set_efermi use od_parameters , only : fixed , adaptive , linear , compute_band_gap ,& & compute_band_energy , set_efermi_zero , iprint use od_comms , only : on_root use od_electronic , only : nspins , efermi , band_energy , efermi_set real ( dp ) :: time0 , time1 , unshifted_efermi if ( on_root ) then write ( stdout , * ) write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) '+                              Density of States                             +' write ( stdout , '(1x,a78)' ) '+============================================================================+' write ( stdout , '(1x,a78)' ) end if call dos_utils_calculate ! Will return if this has already been done. if (. not . efermi_set ) call dos_utils_set_efermi time0 = io_time () !------------------------------------------------------------------------------- ! D O S   A T   F E R M I  L E V E L   A N A L Y S I S call dos_utils_compute_dos_at_efermi !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! B A N D  G A P  A N A L Y S I S ! The compute_dos_at_efermi routine may have set compute_band_gap to true if ( compute_band_gap ) call dos_utils_compute_bandgap !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- ! B A N D   E N E R G Y   A N A L Y S I S ! Now for a bit of crosschecking  band energies ! These should all converge to the same number as the number of bins is increased if ( compute_band_energy ) call dos_utils_compute_band_energies !------------------------------------------------------------------------------- !!$ !!$    unshifted_efermi=efermi !!$ !!$    if(set_efermi_zero) then !!$       if(on_root) then !!$          write(stdout,*) !!$          write(stdout,'(1x,a71)')  '+----------------------- Shift Fermi Energy --------------------------+' !!$          write(stdout,'(1x,a1,a46,a24)')\"|\", \" Setting Fermi energy to 0 : \",\"|\" !!$       endif !!$       E(:)=E(:)-efermi !!$       band_energy(:,:,:) = band_energy(:,:,:) - efermi !!$       efermi=0.0_dp !!$    endif !!$ !!$    if(on_root) then !!$       write(stdout,'(1x,a1,a46,f8.4,a3,12x,a8)')\"|\", \" Fermi energy used : \", unshifted_efermi,\"eV\",\"| <- Ef \" !!$       write(stdout,'(1x,a71)')  '+---------------------------------------------------------------------+' !!$ !!$       time1=io_time() !!$       write(stdout,'(1x,a40,f11.3,a)') 'Time to perfom analysis ',time1-time0,' (sec)' !!$       !------------------------------------------------------------------------------- !!$    end if ! W R I T E   O U T   D O S time0 = io_time () ! Otherwise we have written to wdos and dos, so they can be called ! by whatever. if ( on_root ) then if ( fixed ) call write_dos ( E , dos_fixed , intdos_fixed , \"fixed\" ) if ( adaptive ) call write_dos ( E , dos_adaptive , intdos_adaptive , \"adaptive\" ) if ( linear ) call write_dos ( E , dos_linear , intdos_linear , \"linear\" ) !if(quad)    call write_dos(E, dos_quad, intdos_quad, \"quad\") end if time1 = io_time () if ( on_root . and . iprint > 1 ) then write ( stdout , '(1x,a59,f11.3,a8)' ) & '+ Time to write DOS to disk                              & &      ' , time1 - time0 , ' (sec) +' end if !------------------------------------------------------------------------------- end subroutine dos_calculate !=============================================================================== subroutine write_dos ( E , dos , intdos , dos_name ) !=============================================================================== ! This routine receives an energy scale, a density of states and a file name ! and writes out the DOS to disk !------------------------------------------------------------------------------- ! Arguments: E       (in) : The energy scale !            dos     (in) : The density of states !            intdos  (in) : The integrated DOS !            dos_name(in) : Name of the output file !------------------------------------------------------------------------------- ! Parent Module Varables Used: None !------------------------------------------------------------------------------- ! Modules Used: See below !------------------------------------------------------------------------------- ! Key Internal Variables: None !------------------------------------------------------------------------------- ! Necessary Conditions: None !------------------------------------------------------------------------------- ! Known Worries: None !------------------------------------------------------------------------------- ! Written by : A J Morris December 2010 !=============================================================================== use od_electronic , only : nspins , efermi , efermi_set use od_parameters , only : dos_nbins , dos_per_volume , output_format , set_efermi_zero use od_io , only : seedname , io_file_unit , io_date , io_error , stdout use od_dos_utils , only : dos_utils_set_efermi implicit none real ( dp ), intent ( in ) :: E ( dos_nbins ) real ( dp ), intent ( in ) :: dos ( dos_nbins , nspins ) real ( dp ), intent ( in ) :: intdos ( dos_nbins , nspins ) character ( len =* ), intent ( in ) :: dos_name integer :: i , dos_file , ierr character ( len = 11 ) :: cdate character ( len = 9 ) :: ctime character ( len = 22 ) :: dos_units , intdos_units real ( kind = dp ), allocatable :: E_shift (:) allocate ( E_shift ( dos_nbins ), stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error allocating E_shift in write_dos' ) if ( set_efermi_zero ) then E_shift = E - efermi else E_shift = E end if dos_file = io_file_unit () open ( unit = dos_file , file = trim ( seedname ) // '.' // trim ( dos_name ) // '.dat' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open output file in dos: write_dos\" ) dos_units = \"(electrons per eV)\" ; intdos_units = \"(electrons)\" if ( dos_per_volume ) then dos_units = \"(electrons per eV/A&#94;3)\" intdos_units = \"(electrons per A&#94;3)\" end if write ( dos_file , * ) \"##############################################################################\" write ( dos_file , * ) \"#\" write ( dos_file , * ) \"#                  O p t a D O S   o u t p u t   f i l e \" write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , * ) \"#    Density of States using \" , trim ( dos_name ), \" broadening\" call io_date ( cdate , ctime ) write ( dos_file , * ) '#  Generated on ' , cdate , ' at ' , ctime write ( dos_file , * ) \"# Column        Data\" write ( dos_file , * ) \"#    1        Energy (eV)\" if ( nspins > 1 ) then write ( dos_file , * ) \"#    2        Up-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Down-spin DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    4        Up-spin Integrated DOS \" , trim ( intdos_units ) write ( dos_file , * ) \"#    5        Down-spin Integrated DOS \" , trim ( intdos_units ) else write ( dos_file , * ) \"#    2        DOS \" , trim ( dos_units ) write ( dos_file , * ) \"#    3        Integrated DOS \" , trim ( intdos_units ) end if write ( dos_file , '(1x,a1)' ) \"#\" write ( dos_file , '(1x,a78)' ) \"##############################################################################\" if ( nspins > 1 ) then do i = 1 , dos_nbins write ( dos_file , '(5(E21.13,2x))' ) E_shift ( i ), dos ( i , 1 ), - dos ( i , 2 ), intdos ( i , 1 ), - intdos ( i , 2 ) end do else do i = 1 , dos_nbins write ( dos_file , '(3(E21.13,2x))' ) E_shift ( i ), dos ( i , 1 ), intdos ( i , 1 ) end do end if close ( dos_file ) if ( trim ( output_format ) == \"xmgrace\" ) then call write_dos_xmgrace ( dos_name , E_shift , dos ) elseif ( trim ( output_format ) == \"gnuplot\" ) then write ( stdout , * ) \" WARNING: GNUPLOT output not yet available, calling xmgrace\" call write_dos_xmgrace ( dos_name , E_shift , dos ) !     call write_dos_gnuplot(dos_name,E,dos) else write ( stdout , * ) \" WARNING: Unknown output format requested, continuing...\" end if deallocate ( E_shift , stat = ierr ) if ( ierr /= 0 ) call io_error ( 'Error deallocating E_shift in write_dos' ) end subroutine write_dos !=============================================================================== subroutine write_dos_xmgrace ( dos_name , E , dos ) !=============================================================================== use xmgrace_utils use od_parameters , only : dos_nbins , set_efermi_zero use od_electronic , only : nspins , efermi , efermi_set use od_io , only : io_file_unit , io_error , seedname implicit none real ( dp ), intent ( in ) :: E ( dos_nbins ) real ( dp ), intent ( in ) :: dos ( dos_nbins , nspins ) real ( dp ) :: min_x , max_x , min_y , max_y integer :: batch_file , ierr character ( len =* ), intent ( in ) :: dos_name batch_file = io_file_unit () open ( unit = batch_file , file = trim ( seedname ) // '.' // trim ( dos_name ) // '.agr' , iostat = ierr ) if ( ierr . ne . 0 ) call io_error ( \" ERROR: Cannot open xmgrace batch file in dos: write_dos_xmgrace\" ) min_x = minval ( E ) max_x = maxval ( E ) min_y = 0 max_y = maxval ( dos ) if ( nspins > 1 ) then min_y = - max_y end if call xmgu_setup ( batch_file ) call xmgu_legend ( batch_file ) call xmgu_title ( batch_file , min_x , max_x , min_y , max_y , \"Electronic Density of States\" ) call xmgu_subtitle ( batch_file , \"Generated by OptaDOS\" ) call xmgu_axis ( batch_file , \"x\" , \"Energy eV\" ) call xmgu_axis ( batch_file , \"y\" , \"eDOS\" ) if ( set_efermi_zero ) then call xmgu_vertical_line ( batch_file , 0.0_dp , max_y , min_y ) else if ( efermi_set ) call xmgu_vertical_line ( batch_file , efermi , max_y , min_y ) end if if ( nspins > 1 ) then call xmgu_data_header ( batch_file , 0 , 1 , \"up-spin channel\" ) call xmgu_data_header ( batch_file , 1 , 2 , \"down-spin channel\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) call xmgu_data ( batch_file , 1 , E (:), - dos (:, 2 )) else call xmgu_data_header ( batch_file , 0 , 1 , \"Total DOS\" ) call xmgu_data ( batch_file , 0 , E (:), dos (:, 1 )) end if close ( batch_file ) end subroutine write_dos_xmgrace end module od_dos","tags":"","loc":"sourcefile/dos.f90.html"},{"title":"constants.f90 – OptaDOS","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~jdos.f90 jdos.f90 sourcefile~jdos.f90->sourcefile~constants.f90 sourcefile~parameters.f90 parameters.f90 sourcefile~jdos.f90->sourcefile~parameters.f90 sourcefile~electronic.f90 electronic.f90 sourcefile~jdos.f90->sourcefile~electronic.f90 sourcefile~io.f90 io.f90 sourcefile~jdos.f90->sourcefile~io.f90 sourcefile~comms.f90 comms.F90 sourcefile~jdos.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90 jdos_utils.f90 sourcefile~jdos.f90->sourcefile~jdos_utils.f90 sourcefile~xmgrace_utils.f90 xmgrace_utils.f90 sourcefile~jdos.f90->sourcefile~xmgrace_utils.f90 sourcefile~algorithms.f90 algorithms.f90 sourcefile~algorithms.f90->sourcefile~constants.f90 sourcefile~algorithms.f90->sourcefile~io.f90 sourcefile~algorithms.f90->sourcefile~comms.f90 sourcefile~parameters.f90->sourcefile~constants.f90 sourcefile~parameters.f90->sourcefile~algorithms.f90 sourcefile~cell.f90 cell.f90 sourcefile~parameters.f90->sourcefile~cell.f90 sourcefile~parameters.f90->sourcefile~io.f90 sourcefile~parameters.f90->sourcefile~comms.f90 sourcefile~pdis.f90 pdis.f90 sourcefile~pdis.f90->sourcefile~constants.f90 sourcefile~pdis.f90->sourcefile~algorithms.f90 sourcefile~pdis.f90->sourcefile~parameters.f90 sourcefile~pdis.f90->sourcefile~electronic.f90 sourcefile~pdis.f90->sourcefile~cell.f90 sourcefile~pdis.f90->sourcefile~io.f90 sourcefile~projection_utils.f90 projection_utils.f90 sourcefile~pdis.f90->sourcefile~projection_utils.f90 sourcefile~pdis.f90->sourcefile~comms.f90 sourcefile~dos.f90 dos.f90 sourcefile~dos.f90->sourcefile~constants.f90 sourcefile~dos.f90->sourcefile~parameters.f90 sourcefile~dos.f90->sourcefile~electronic.f90 sourcefile~dos.f90->sourcefile~io.f90 sourcefile~dos.f90->sourcefile~comms.f90 sourcefile~dos_utils.f90 dos_utils.f90 sourcefile~dos.f90->sourcefile~dos_utils.f90 sourcefile~dos.f90->sourcefile~xmgrace_utils.f90 sourcefile~optados.f90 optados.f90 sourcefile~optados.f90->sourcefile~constants.f90 sourcefile~optados.f90->sourcefile~jdos.f90 sourcefile~optados.f90->sourcefile~parameters.f90 sourcefile~optados.f90->sourcefile~pdis.f90 sourcefile~optados.f90->sourcefile~dos.f90 sourcefile~optics.f90 optics.f90 sourcefile~optados.f90->sourcefile~optics.f90 sourcefile~pdos.f90 pdos.F90 sourcefile~optados.f90->sourcefile~pdos.f90 sourcefile~optados.f90->sourcefile~electronic.f90 sourcefile~optados.f90->sourcefile~cell.f90 sourcefile~optados.f90->sourcefile~io.f90 sourcefile~optados.f90->sourcefile~comms.f90 sourcefile~core.f90 core.f90 sourcefile~optados.f90->sourcefile~core.f90 sourcefile~od2od.f90 od2od.f90 sourcefile~od2od.f90->sourcefile~constants.f90 sourcefile~od2od.f90->sourcefile~parameters.f90 sourcefile~od2od.f90->sourcefile~electronic.f90 sourcefile~od2od.f90->sourcefile~cell.f90 sourcefile~od2od.f90->sourcefile~io.f90 sourcefile~od2od.f90->sourcefile~comms.f90 sourcefile~optics.f90->sourcefile~constants.f90 sourcefile~optics.f90->sourcefile~parameters.f90 sourcefile~optics.f90->sourcefile~electronic.f90 sourcefile~optics.f90->sourcefile~cell.f90 sourcefile~optics.f90->sourcefile~io.f90 sourcefile~optics.f90->sourcefile~comms.f90 sourcefile~optics.f90->sourcefile~dos_utils.f90 sourcefile~optics.f90->sourcefile~jdos_utils.f90 sourcefile~optics.f90->sourcefile~xmgrace_utils.f90 sourcefile~pdos.f90->sourcefile~constants.f90 sourcefile~pdos.f90->sourcefile~algorithms.f90 sourcefile~pdos.f90->sourcefile~parameters.f90 sourcefile~pdos.f90->sourcefile~electronic.f90 sourcefile~pdos.f90->sourcefile~cell.f90 sourcefile~pdos.f90->sourcefile~io.f90 sourcefile~pdos.f90->sourcefile~projection_utils.f90 sourcefile~pdos.f90->sourcefile~comms.f90 sourcefile~pdos.f90->sourcefile~dos_utils.f90 sourcefile~electronic.f90->sourcefile~constants.f90 sourcefile~electronic.f90->sourcefile~algorithms.f90 sourcefile~electronic.f90->sourcefile~parameters.f90 sourcefile~electronic.f90->sourcefile~cell.f90 sourcefile~electronic.f90->sourcefile~io.f90 sourcefile~electronic.f90->sourcefile~comms.f90 sourcefile~cell.f90->sourcefile~constants.f90 sourcefile~cell.f90->sourcefile~algorithms.f90 sourcefile~cell.f90->sourcefile~io.f90 sourcefile~cell.f90->sourcefile~comms.f90 sourcefile~io.f90->sourcefile~constants.f90 sourcefile~projection_utils.f90->sourcefile~constants.f90 sourcefile~projection_utils.f90->sourcefile~parameters.f90 sourcefile~projection_utils.f90->sourcefile~electronic.f90 sourcefile~projection_utils.f90->sourcefile~cell.f90 sourcefile~projection_utils.f90->sourcefile~io.f90 sourcefile~projection_utils.f90->sourcefile~comms.f90 sourcefile~comms.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~constants.f90 sourcefile~dos_utils.f90->sourcefile~algorithms.f90 sourcefile~dos_utils.f90->sourcefile~parameters.f90 sourcefile~dos_utils.f90->sourcefile~electronic.f90 sourcefile~dos_utils.f90->sourcefile~cell.f90 sourcefile~dos_utils.f90->sourcefile~io.f90 sourcefile~dos_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~constants.f90 sourcefile~jdos_utils.f90->sourcefile~algorithms.f90 sourcefile~jdos_utils.f90->sourcefile~parameters.f90 sourcefile~jdos_utils.f90->sourcefile~electronic.f90 sourcefile~jdos_utils.f90->sourcefile~cell.f90 sourcefile~jdos_utils.f90->sourcefile~io.f90 sourcefile~jdos_utils.f90->sourcefile~comms.f90 sourcefile~jdos_utils.f90->sourcefile~dos_utils.f90 sourcefile~xmgrace_utils.f90->sourcefile~constants.f90 sourcefile~xmgrace_utils.f90->sourcefile~io.f90 sourcefile~core.f90->sourcefile~constants.f90 sourcefile~core.f90->sourcefile~parameters.f90 sourcefile~core.f90->sourcefile~electronic.f90 sourcefile~core.f90->sourcefile~cell.f90 sourcefile~core.f90->sourcefile~io.f90 sourcefile~core.f90->sourcefile~comms.f90 sourcefile~core.f90->sourcefile~dos_utils.f90 sourcefile~core.f90->sourcefile~xmgrace_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules od_constants Source Code constants.f90 Source Code ! ! This file is part of OptaDOS ! ! OptaDOS - For obtaining electronic structure properties based on !             integrations over the Brillouin zone ! Copyright (C) 2011  Andrew J. Morris,  R. J. Nicholls, C. J. Pickard !                         and J. R. Yates ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !=========================================================================! ! Module: Constants                                                       ! ! For global constants                                                    ! !-------------------------------------------------------------------------! ! Modules used:  None                                                     ! !-------------------------------------------------------------------------! ! Key Internal Variables:                                                 ! !-------------------------------------------------------------------------! ! Written by Andrew Morris                                     11/10/2010 ! !=========================================================================! module od_constants implicit none private ! unless otherise stated character ( len = 6 ), parameter , public :: optados_version = \" 1.3 \" character ( len = 14 ), parameter , public :: copyright = \" (c) 2010-2022\" integer , parameter , public :: dp = selected_real_kind ( 15 , 300 ) real ( kind = dp ), parameter , public :: pi = 3.141592653589793238462643383279502884197_dp real ( kind = dp ), parameter , public :: H2eV = 2 7.21138342902473_dp real ( kind = dp ), parameter , public :: bohr2ang = 0.52917720859_dp real ( kind = dp ), parameter , public :: inv_sqrt_two_pi = 0.3989422804014326779399460599_dp real ( kind = dp ), parameter , public :: twopi = 6.283185307179586476925286766559005768394_dp real ( kind = dp ), parameter , public :: sqrt_two = 1.414213562373095048801688724209698079_dp complex ( dp ), parameter , public :: cmplx_0 = ( 0.0_dp , 0.0_dp ) complex ( dp ), parameter , public :: cmplx_i = ( 0.0_dp , 1.0_dp ) !Optics constants real ( kind = dp ), parameter , public :: epsilon_0 = 8.8541878176E-12_dp real ( kind = dp ), parameter , public :: e_charge = 1.602176487E-19_dp real ( kind = dp ), parameter , public :: e_mass = 9.10938215E-31_dp real ( kind = dp ), parameter , public :: hbar = 1.054571628E-34_dp real ( kind = dp ), parameter , public :: c_speed = 29979245 8.0_dp !Photoemission constants real ( kind = dp ), parameter , public :: epsilon_zero = 5 5.26349406_dp !e&#94;2 GeV&#94;-1 fm&#94;-1 real ( kind = dp ), parameter , public :: j_to_ev = 6.24150934E+18_dp !J eV&#94;-1 real ( kind = dp ), parameter , public :: ev_to_j = 1.602176565E-19_dp !eV J&#94;-1 real ( kind = dp ), parameter , public :: ev_to_hartree = 0.03674932379_dp !eV Ha&#94;-1 real ( kind = dp ), parameter , public :: rad_to_deg = 5 7.2957795_dp !deg rad&#94;-1 real ( kind = dp ), parameter , public :: deg_to_rad = 0.0174532925_dp !rad&#94;-1 to deg real ( kind = dp ), parameter , public :: boltzmann = 1.38064852E-23_dp !J K&#94;-1 real ( kind = dp ), parameter , public :: kB = 8.617333262E-5_dp ! ev K&#94;-1 ! Constants for field emission in Photoemission Module real ( kind = dp ), parameter , public :: b_factor = 7 4.4412181295_dp real ( kind = dp ), parameter , public :: p1 = 0.03270530446_dp real ( kind = dp ), parameter , public :: p2 = 0.009157798739_dp real ( kind = dp ), parameter , public :: p3 = 0.002644272807_dp real ( kind = dp ), parameter , public :: p4 = 0.00008987173811_dp real ( kind = dp ), parameter , public :: q1 = 0.1874993441_dp real ( kind = dp ), parameter , public :: q2 = 0.01750636947_dp real ( kind = dp ), parameter , public :: q3 = 0.005527069444_dp real ( kind = dp ), parameter , public :: q4 = 0.001023904180_dp character ( len = 3 ), parameter , dimension ( 109 ), public :: periodic_table_name = ( / & & 'H ' , 'He' , & & 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , & & 'K ' , 'Ca' , 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & & 'Rb' , 'Sr' , 'Y ' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I ' , 'Xe' , & & 'Cs' , 'Ba' , & & 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , & & 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & & 'Fr' , 'Ra' , & & 'Ac' , 'Th' , 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , 'Lr' , & & 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' / ) ! Based on: S. Alvarez, Dalton Transactions, 2013, 42, 8617-8636. ! If value == 1.0_dp then no value was supplied, subject to change real ( kind = dp ), parameter , dimension ( 109 ), public :: periodic_table_vdw = ( / & & 1.20_dp , 1.43_dp , & & 2.12_dp , 1.98_dp , 1.91_dp , 1.77_dp , 1.66_dp , 1.50_dp , 1.46_dp , 1.58_dp , & & 2.50_dp , 2.51_dp , 2.25_dp , 2.19_dp , 1.90_dp , 1.89_dp , 1.82_dp , 1.83_dp , & & 2.73_dp , 2.62_dp , 2.58_dp , 2.46_dp , 2.42_dp , 2.45_dp , 2.45_dp , 2.44_dp , 2.40_dp , 2.40_dp , 2.38_dp , 2.39_dp , 2.32_dp , & & 2.29_dp , 1.88_dp , 1.82_dp , 1.86_dp , 2.25_dp , & & 3.21_dp , 2.84_dp , 2.75_dp , 2.52_dp , 2.56_dp , 2.45_dp , 2.44_dp , 2.46_dp , 2.44_dp , 2.15_dp , 2.53_dp , 2.49_dp , 2.43_dp , & & 2.42_dp , 2.47_dp , 1.99_dp , 2.04_dp , 2.06_dp , & & 3.48_dp , 3.03_dp , & & 2.98_dp , 2.88_dp , 2.92_dp , 2.95_dp , 1.0_dp , 2.90_dp , 2.87_dp , 2.83_dp , 2.79_dp , 2.87_dp , 2.81_dp , 2.83_dp , 2.79_dp , & & 2.80_dp , 2.74_dp , & & 2.63_dp , 2.53_dp , 2.57_dp , 2.49_dp , 2.48_dp , 2.41_dp , 2.29_dp , 2.32_dp , 2.45_dp , 2.47_dp , 2.60_dp , 2.54_dp , 1.0_dp , & & 1.0_dp , 1.0_dp , & & 1.0_dp , 1.0_dp , & & 2.8_dp , 2.93_dp , 2.88_dp , 2.71_dp , 2.82_dp , 2.81_dp , 2.83_dp , 3.05_dp , 3.4_dp , 3.05_dp , 2.7_dp , 1.0_dp , 1.0_dp , 1.0_dp ,& & 1.0_dp , & & 1.0_dp , 1.0_dp , 1.0_dp , 1.0_dp , 1.0_dp , 1.0_dp / ) end module od_constants","tags":"","loc":"sourcefile/constants.f90.html"}]}